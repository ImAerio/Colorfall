<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <title>Orbila</title>

    <style>
        body{font-family:'Inter',sans-serif;background-color:#1a1a1a;color:#e0e0e0;margin:0;display:flex;justify-content:center;align-items:flex-start;min-height:100vh;overflow:hidden}
        .screen{display:none;flex-direction:column;align-items:center;padding:0 20px 20px 20px;box-sizing:border-box;width:100%;max-width:1000px;text-align:center; height: 100vh;}
        #homeScreen{justify-content:center; align-items: center; padding-top: 20px;}
        .screen.active{display:flex !important}
        
        #gameScreenContainer { 
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px; 
        }
        #canvasArea { 
            position: relative;
            width: 100%; 
            height: auto; 
        }
        canvas#gameCanvas{border:1px solid #444;background:linear-gradient(80deg,#0f0e14,#211f29 23%,#211f29 30%,#1c1a24 50%,#211f29 70%,#211f29 77%,#0f0e14);cursor:none;position:relative;z-index:2; display: block;}
        #atmosphericCanvas{position:absolute;top:0;left:0;pointer-events:none;z-index:1; display: block;}
        
                
        #leaderboardsContainer {
            display:flex;
            justify-content: space-between; 
            width:100%;
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            padding-bottom:10px;
             
        }
        #replaysListContainerOuter { 
            display: flex; 
            flex-direction: column; 
            width: 100%; 
            flex-grow: 1; 
            overflow-y:auto; 
            min-height:0; 
            padding-bottom:10px;
        } 
        #replaysListContainer {
            display:flex;
            justify-content: space-between; 
            width:100%;
             
        }
#saveReplayBtn.limit-reached {
    background-color: #555 !important;
    border: 2px solid #444 !important;
    padding: 10px 23px !important; /* 12-2=10, 25-2=23 */
    cursor: not-allowed !important;
}

#saveReplayBtn.limit-reached:hover {
    background-color: #555 !important; 
    border: 2px solid #444 !important;
}
        
        .leaderboard ol, .replays-mode-list {
            list-style-type:none;
            padding-left:0;
            margin:0; 
            text-align:left;
            width: 100%; 
            flex-grow: 1; 
            overflow-y: auto; 
            display: flex;      
            flex-direction: column;
            gap: 6px; 
        }

        .score-list-entry, .replay-list-entry { 
        }

        
        .replay-list-entry {
            list-style-type: none;
            margin-bottom: 6px; 
        }

        .mode-tabs-container { 
    display: flex;
    flex-direction: column; 
    flex-grow: 1;
    overflow-y: auto; /* This scroll is for the content INSIDE the tabs if it's very long */
    width: 100%;
    box-sizing: border-box;
    min-height: 0; /* Allow shrinking if content is very small */
}

        .mode-tab-buttons {
    display: flex;
    margin-bottom: 20px; 
    border-bottom: 1px solid #444; 
    width: 100%; 
    padding: 0 20px; 
    position: sticky; 
    top: 0; /* Sticky relative to its scrollable parent (.mode-tabs-container or .scrollable-content-wrapper) */         
    background-color: #1a1a1a; 
    z-index: 5; 
    margin-left: -20px; /* Offset the padding of .scrollable-content-wrapper */
    margin-right: -20px; /* Offset the padding of .scrollable-content-wrapper */
    box-sizing: content-box; 
}
        .mode-tab-btn {
            font-family: inherit;
            background-color: transparent;
            color: #a0a0a0;
            border: 2px solid transparent; 
            padding: 10px 23px; /* 12-2=10, 25-2=23 */
            font-size: 1.1em;   
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            margin: 0 5px -1px 0; 
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            border-bottom-color: transparent; 
        }
        .mode-tab-btn:hover {
            background-color: #2a2a2a;
            border-color: #3a3a3a; 
            color: #e0e0e0;
        }
        .mode-tab-btn.active {
            background-color: #333;
            color: #61dafb;
            border: 1px solid #444; 
            border-bottom: 1px solid #333; 
            padding: 11px 24px; /* Revert for 1px structural border */
            font-weight: bold;
        }

        .mode-tab-panel {
    display: none;
    flex-direction: column;
    width: 100%;
    box-sizing: border-box;
    flex-grow: 1; 
}
        .mode-tab-panel.active {
            display: flex;
        }

        .score-mode-list, .replays-mode-list {
            list-style-type:none;
            padding-left:0;
            margin:0; 
            width: 100%; 
            display: flex;
            flex-direction: column;
            gap: 8px; 
            text-align:left;
        }

        .cosmetic-tabs-container {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid #444; 
    position: sticky; /* Make cosmetic tabs sticky */
    top: 0; /* Stick to the top of its scrollable parent */
    background-color: #1a1a1a;
    z-index: 5;
    margin-left: -20px; /* Offset parent padding */
    margin-right: -20px; /* Offset parent padding */
    padding-left: 20px; /* Re-add padding inside for content */
    padding-right: 20px; /* Re-add padding inside for content */
    box-sizing: border-box; /* Ensure padding is included in width */
}
        .cosmetic-tab-btn {
            font-family: inherit;
            background-color: transparent;
            color: #a0a0a0;
            border: 2px solid transparent; 
            padding: 8px 18px; /* 10-2=8, 20-2=18 */
            font-size: 1em;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            margin: 0 5px -1px 0; 
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            border-bottom-color: transparent;
        }
        .cosmetic-tab-btn:hover {
            background-color: #2a2a2a;
            border-color: #3a3a3a; 
            color: #e0e0e0;
        }
        .cosmetic-tab-btn.active {
            background-color: #333;
            color: #61dafb;
            border: 1px solid #444; 
            border-bottom: 1px solid #333; 
            padding: 9px 19px; /* Revert for 1px structural border */
            font-weight: bold;
        }

        .cosmetic-tab-panel {
            display: none;
            flex-direction: column;
            gap: 25px; 
        }
        .cosmetic-tab-panel.active {
            display: flex;
        }

        .cosmetic-section {
            background-color: #282828;
            padding: 15px;
            border-radius: 5px;
        }
        .cosmetic-section h3 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .cosmetic-type-group {
            margin-bottom: 20px;
        }
        .cosmetic-type-group:last-child {
            margin-bottom: 0;
        }
        .cosmetic-type-group h4 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .cosmetic-item-list {
            display: flex;
            flex-direction: column; 
            gap: 8px;
        }
        .cosmetic-item-list .no-items-text {
            font-style: italic;
            color: #888;
        }

        .cosmetic-item {
            background-color: #333;
            padding: 10px 15px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95em;
        }
        .cosmetic-item span {
            flex-grow: 1;
        }
        .cosmetic-equip-btn {
            background-color: #007bff;
            color: white;
            border: 2px solid #0056b3;
            padding: 4px 10px; /* 6-2=4, 12-2=10 */
            font-size: 0.9em;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 10px;
            min-width: 80px; 
            text-align: center;
            transition: background-color 0.2s, border-color 0.2s;
        }
         .cosmetic-equip-btn:hover {
            background-color: #0056b3;
            border-color: #004085;
        }
        .cosmetic-equip-btn.equipped {
            background-color: #28a745; 
            border: 2px solid #1e7e34;
            cursor: default;
        }
        .cosmetic-equip-btn.equipped:hover {
            background-color: #28a745;
            border-color: #1e7e34;
        }
        
        .score-list-entry {
            list-style-type: none;
            margin-bottom: 6px; 
        }
        
        .score-list-entry-ranked {
     display: flex;
     align-items: flex-start; 
}

        .score-rank { 
            font-size: 1.4em; 
            font-weight: bold;
            color: #e0e0e0; 
            margin-right: 15px;
            margin-top: 15px; 
            min-width: 47px; 
            text-align: right; 
        }

        
                .item-content-box {
            background-color:#333;
            padding: 8px 12px;
            border-radius:3px;
            font-size:0.95em;
            overflow-wrap: break-word; 
            word-wrap: break-word; 
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 42px;
            min-width: 0; 
            width: 100%;
            box-sizing: border-box;
        }
                .item-content-box.placeholder-message {
            justify-content: center !important; 
            text-align: center; 
            font-size: 1.1em !important; 
        }
.item-note-container {
    background-color: #444; 
    padding: 8px 12px;
    border-radius: 0 0 3px 3px;
    font-size: 1em;
    color: #e0e0e0;
    display: none;
    cursor: pointer;
    min-height: 20px;
    overflow-wrap: break-word; 
    word-wrap: break-word;     
    word-break: break-all;     
    width: 100%;
    box-sizing: border-box;
    position: relative;
    top: -3px;
    z-index: 1;
}

.item-note-container.visible {
    display: block;
}

.note-placeholder-text {
    color: #e0e0e0;
    font-style: italic;
}

.note-editable-area {
    color: #e0e0e0;
    background-color: #3f3f3f;
    padding: 5px;
    border: 1px solid #555;
    border-radius: 3px;
    min-height: 20px;
    outline: none;
    width: 100%; 
    box-sizing: border-box;
    cursor: text;
    overflow-wrap: break-word; 
    word-wrap: break-word;     
    word-break: break-all;     
}
        
        .score-list-entry-ranked {
     display: flex; 
     flex-wrap: wrap; 
     align-items: flex-start; 
}

        
                .item-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0; 
            overflow-wrap: break-word; 
            word-wrap: break-word; 
        }
                .item-info div {
            line-height: 1.4; 
            overflow-wrap: break-word; 
            word-wrap: break-word; 
            font-size: 1.1em; 
        }

        .item-actions { 
            display: flex; 
            align-items: center; 
            margin-left: 10px; 
        }
        
        
        .item-actions button { 
            margin-left: 5px; 
            padding: 0; 
            width: 36px; height: 36px; 
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            border: 2px solid transparent; 
            border-radius: 4px;
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .item-actions button.play-btn-geom { background-color: #28a745; border-color: #1e7e34;}
        .item-actions button.play-btn-geom:hover { background-color: #218838; border-color: #155724;}
        .item-actions button.delete-btn-geom { background-color: #dc3545; border-color: #c82333;}
        .item-actions button.delete-btn-geom:hover { background-color: #c82333; border-color: #9b1a26;}
        .item-actions button.export-btn-geom { background-color: #17a2b8; border-color: #117a8b;} 
        .item-actions button.export-btn-geom:hover { background-color: #138496; border-color: #0d6775;}

button.copied-success {
            background-color: #28a745 !important; 
            border-color: #1e7e34 !important;
        }
        button.copied-success:hover {
            background-color: #28a745 !important; 
            border-color: #1e7e34 !important;
        }
        
        .play-svg-icon, .delete-svg-icon, .import-svg-icon, .menu-btn-icon {
     width: 20px; height: 20px; fill: white; stroke: white;
}
.delete-svg-icon { stroke-width: 1.5; }
.export-svg-icon {
     width: 22px; height: 22px;
     stroke: white;
     fill: none;
     stroke-width: 2.2;
}
.import-svg-icon { stroke-width: 2.2; fill: none; }
        #settingsBtn .menu-btn-icon { 
            width: 23px; height: 23px;
        }
        .delete-svg-icon { stroke-width: 1.5; }
        .export-svg-icon { stroke-width: 2.2; fill: none; } 
        .import-svg-icon { stroke-width: 2.2; fill: none; } 
        .menu-btn-icon { margin-right: 10px; }
        .cancel-svg-icon { width: 18px; height: 18px; margin-right: 8px; fill: white; }
        
        #uiOverlay{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;align-items:center;font-size:1.2em;color:#fff;pointer-events:none;background-color:rgba(0,0,0,0.3);padding:8px 15px;border-radius:5px;z-index:5}
        #uiOverlay.replay-mode { background: none; }
        #uiOverlay .game-stats{display:flex;align-items:center}
        #uiOverlay .game-stats > div{margin-right:25px}
        #uiOverlay .game-stats > div:last-child{margin-right:0}
.screen-header-btn.home-icon-btn {
    padding: 1px !important; 
}
#gameScreen {
    justify-content: center; /* Center its content (gameScreenContainer) horizontally */
    align-items: center;    /* Center its content (gameScreenContainer) vertically */
    padding-top: 20px;      /* Add back top padding if desired, similar to homeScreen */
    padding-bottom: 20px;   /* Add back bottom padding if desired */
    /* It will still inherit height: 100vh and other properties from .screen */
}
        #gameScreenHomeBtnInOverlay {background-color:#007bff;color:white;border:2px solid #0056b3;border-radius:5px;cursor:pointer;padding:6px;width:42px;height:42px;display:flex;justify-content:center;align-items:center;transition:background-color 0.2s, border-color 0.2s;margin:0;pointer-events:auto;align-self:center;}
        #gameScreenHomeBtnInOverlay:hover {background-color:#0056b3; border-color: #004085;}
        .home-svg-icon {
    width: 8px;   
    height: 8px;  
    min-width: 30px; 
    min-height: 30px;
    fill: white;
    flex-shrink: 0; 
}  
        #powerupIconsContainer{position:absolute;top:80px;left:15px;display:flex;flex-direction:column;gap:10px;pointer-events:none;z-index:5}
        #powerupIconsContainer.replay-mode { top: 80px; bottom: auto;}
        .powerup-icon{width:40px;height:40px;border:2px solid #555;background-color:rgba(0,0,0,0.4);display:flex;justify-content:center;align-items:center;font-size:1.2em;font-weight:bold;color:#777;border-radius:5px;transition:color 0.2s,border-color 0.2s,box-shadow 0.2s;position:relative;overflow:hidden}
        .powerup-icon.active{color:#fff;border-color:#FFDC00;box-shadow:0 0 8px #FFDC00}
        #oneColorIcon.active{color:#fff}
        .powerup-icon.flashing{animation:flashPowerup 0.3s ease-in-out infinite alternate}
        @keyframes flashPowerup{from{border-color:#FFDC00;box-shadow:0 0 10px #FFDC00;opacity:1}to{border-color:#777;box-shadow:0 0 3px #777;opacity:0.7}}
        #magnetIcon .magnet-body{width:60%;height:40%;border:5px solid #777777;border-bottom:none;border-radius:15px 15px 0 0;position:absolute;top:20%;left:50%;transform:translateX(-50%);box-sizing:border-box}
        #magnetIcon .magnet-pole{width:13%;height:10%;background-color:#777777;position:absolute;bottom:20%;box-sizing:border-box}
        #magnetIcon .magnet-pole-left{left:20%}
        #magnetIcon .magnet-pole-right{right:20%}
        #magnetIcon.active .magnet-body{border-color:white}
        #magnetIcon.active .magnet-pole{background-color:white}
        #gameOverScreen{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(0,0,0,0.85);padding:25px 30px;border-radius:10px;border:1px solid #555;z-index:100;display:flex;flex-direction:column;align-items:center;min-width:350px}
        #newHighScoreText{color:#FFDC00;font-size:1.3em;margin-bottom:10px}
        #gameOverScreen h2{margin-top:0;margin-bottom:20px;color:#61dafb;font-weight:700}
        #gameOverScoreTime{display:flex;justify-content:space-around;width:100%;margin-bottom:25px;font-size:1.1em}
        #gameOverButtons{display:flex;justify-content:center;width:100%; flex-wrap: wrap;}
        #gameOverButtons button{margin:5px 10px}
#gameOverScreen{
    position:absolute;
    top:50%;left:50%;transform:translate(-50%,-50%);
    background-color:rgba(0,0,0,0.85);
    padding:25px 30px;border-radius:10px;border:1px solid #555;
    z-index:100;display:flex;flex-direction:column;align-items:center;
    min-width: 400px; 
}

#gameOverButtons {
    display: flex;
    flex-direction: column; 
    align-items: center;  
    width: 100%;
}

.game-over-button-row { 
    display: flex;
    justify-content: center; 
    width: 100%;
    margin-bottom: 10px; 
}
.game-over-button-row:last-child {
    margin-bottom: 0; 
}


#gameOverButtons button { 
    margin: 5px; 
    min-width: 160px; 
}


#gameOverQuitBtn {
    background-color:#dc3545; 
    border: 2px solid #c82333;
    padding: 10px 23px;
}
#gameOverQuitBtn:hover {
    background-color:#c82333;
    border-color: #9b1a26;
}
    
#gameScreenDeleteReplayBtnInOverlay:hover {
    background-color: #c82333 !important; 
    border-color: #9b1a26 !important;
}
    
#autosaveThresholdBtn {
            font-family: inherit;
            background-color: #007bff; 
            color: white;
            border: 2px solid #0056b3;
            padding: 0 13px; /* 15-2=13 */
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
            text-align: center;
            height: 44px; 
            box-sizing: border-box;
            transition: background-color 0.2s, border-color 0.2s;
        }
        #autosaveThresholdBtn:hover {
            background-color: #0056b3;
            border-color: #004085;
        }
        #autosaveThresholdBtn:disabled {
            background-color: #555 !important;
            border-color: #444 !important;
            cursor: not-allowed !important;
        }
        #autosaveThresholdContainer .setting-control-group span {
            display: inline-flex;
            align-items: center;
            margin-left: 5px; 
        }
#saveReplayBtn .menu-btn-icon,
#saveReplayBtn .btn-text {
    vertical-align: middle;
}


#saveReplayBtn.saved {
    background-color: #28a745;
    border-color: #1e7e34;
}

#saveReplayBtn.saved:not(.watch-mode) {
    cursor: default;
}
#saveReplayBtn.saved:not(.watch-mode):hover {
    background-color: #28a745; 
    border-color: #1e7e34;
}

#saveReplayBtn.saved.watch-mode {
    cursor: pointer; 
}

#saveReplayBtn.saved.watch-mode:hover {
    background-color: #218838 !important; 
    border-color: #155724 !important;
}
        
        #slowFallIcon .up-arrow-shaft{position:absolute;width:6px;height:18px;background-color:#777;left:50%;bottom:8px;transform:translateX(-50%);transition:background-color 0.2s}
        #slowFallIcon .up-arrow-head{position:absolute;width:0;height:0;border-left:9px solid transparent;border-right:9px solid transparent;border-bottom:12px solid #777;left:50%;top:8px;transform:translateX(-50%);transition:border-bottom-color 0.2s}
        #slowFallIcon.active .up-arrow-shaft{background-color:white}
        #slowFallIcon.active .up-arrow-head{border-bottom-color:white}
        #wideBucketIcon .wide-bucket-base-angled{position:absolute;width:60%;height:12%;background-color:#777;bottom:30%;left:50%;transform:translateX(-50%);transition:background-color 0.2s}
        #wideBucketIcon .wide-bucket-side-angled{position:absolute;width:12%;height:30%;background-color:#777;bottom:33%;transition:background-color 0.2s}
        #wideBucketIcon .wide-bucket-left-angled{left:20%;transform-origin:bottom center;transform:rotate(-22.5deg)}
        #wideBucketIcon .wide-bucket-right-angled{right:20%;transform-origin:bottom center;transform:rotate(22.5deg)}
        #wideBucketIcon.active .wide-bucket-base-angled,
        #wideBucketIcon.active .wide-bucket-side-angled{background-color:white}
        #oneColorIcon .one-color-circle-shape{width:55%;height:55%;background-color:#777;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transition:background-color 0.2s}
        #oneColorIcon.active .one-color-circle-shape{background-color:white}
        
        button{font-family:inherit;background-color:#007bff;color:white;border:2px solid #0056b3;padding:10px 23px;font-size:1em;border-radius:5px;cursor:pointer;margin:10px;transition:background-color 0.2s, border-color 0.2s; display: inline-flex; align-items: center; justify-content: center;}
        button:hover{background-color:#0056b3; border-color: #004085;}
        .keybindBtn{min-width:80px;text-align:center; justify-content: center;} 
        .keybindBtn:disabled{background-color:#555; border-color: #444; cursor:not-allowed}
        
        h1{color:#61dafb;font-weight:700;margin-bottom:25px}

        #settingsScreen, #highScoresScreen, #howToPlayScreen, #replaysScreen, #appearanceScreen {
    /*justify-content:flex-start; Already handled by body align-items:flex-start */
    /*align-items:stretch; Default for flex column */
    /*max-height:100vh; Not needed here, .screen has height: 100vh */
    /*height: 100%; Not needed here, .screen has height: 100vh */
    padding-top: 0; 
    padding-bottom: 0; 
    /* REMOVE display: flex; from here. It's handled by .screen.active */
    flex-direction: column; /* This is fine if the screen ITSELF needs to be a column for its direct children (header, scrollable-wrapper) */
}
        
        
        .screen-header{
    display:flex;align-items:center;justify-content:center;
    width:100%; margin-bottom:25px;position:sticky; 
    top:0; 
    background-color: #1a1a1a; 
    z-index: 10; 
    padding-top: 20px; 
    padding-bottom: 10px; 
    box-sizing: border-box;
    flex-shrink: 0; 
}  
        .screen-header h2{text-align:center;color:#61dafb;font-weight:700;margin:0; flex-grow: 1;}
        .screen-header-btn {background-color:#007bff;color:white;border:2px solid #0056b3;border-radius:5px;cursor:pointer;padding:8px;width:94px;height:94px;display:flex;justify-content:center;align-items:center;transition:background-color 0.2s, border-color 0.2s;margin:0;position:absolute;top:50%;transform:translateY(-50%);}
        
        .screen-header .screen-header-btn.home-icon-btn {
            width: 42px !important;
            height: 42px !important;
            padding: 6px !important; 
        }
        
        .home-icon-btn{right:0;}
        .import-icon-btn{right: 58px; background-color: #17a2b8; border-color: #117a8b;}  
        .import-icon-btn:hover{background-color: #138496; border-color: #0d6775;}
        .screen-header-btn:hover{background-color:#0056b3; border-color: #004085;}

        
        .scrollable-content-wrapper {
    flex-grow: 1; 
    overflow-y: auto;
    width: 100%;
    padding: 0 20px 20px 20px; 
    box-sizing: border-box;
    min-height: 0; 
    display: flex; 
    flex-direction: column; 
}

        .settings-content-wrapper{
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            width:100%;
            padding-bottom:10px
        }
                .settings-content-wrapper { 
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            width:100%;
            padding-bottom:10px;
            display: flex;
            flex-direction: column;
            gap: 25px; 
        }

                .setting-section {
            background-color: #282828; 
            padding: 15px;
            border-radius: 5px;
            width: 100%; 
            box-sizing: border-box; 
            display: flex;
            flex-direction: column;
            gap: 10px; 
        }

        .setting-section h3 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 15px; 
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            text-align: left; 
        }

        .setting-item {
            background-color: #333; 
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 1.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
        }
        
        .setting-item.keybind-setting-row {
            padding-top: 8px;
            padding-bottom: 8px;
        }

        .setting-item label {
            margin-right: 20px;
            width: 220px; 
            text-align: left;
            flex-shrink: 0;
            color: #e0e0e0;
        }

        .setting-item > div[style*="flex-direction: column"] > div[style*="justify-content: space-between"] {
        }
        .settings-content-wrapper label{
            margin-right: 20px;
            width: 220px;
            text-align: left;
            flex-shrink: 0;
            color: #e0e0e0;
        }
        .settings-content-wrapper input[type="range"]{vertical-align:middle;width:200px;cursor:pointer}
        .settings-content-wrapper .slider-value-display{min-width:30px;display:inline-block;text-align:left}

        .setting-control-group {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            flex-grow: 1;
        }
        .setting-control-group input[type="range"] {
            margin-right: 10px;
        }
        button.keybindBtn {
            font-family: inherit;
            background-color: #007bff; 
            color: white;
            border: 2px solid #0056b3;
            padding: 0 13px; /* 15-2=13 */
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
            text-align: center;
            height: 44px; 
            box-sizing: border-box;
            transition: background-color 0.2s, border-color 0.2s;
        }
        button.keybindBtn:hover {
            background-color: #0056b3;
            border-color: #004085;
        }
        button.keybindBtn:disabled{
            background-color:#555;
            border-color: #444;
            cursor:not-allowed;
        }

        select.styled-select {
            font-family: inherit;
            background-color: #007bff; 
            color: white;             
            border: 2px solid #0056b3;
            padding-left: 13px; /* 15-2=13 */       
            padding-right: 33px; /* 35-2=33 */     
            font-size: 1em;           
            border-radius: 5px;
            cursor: pointer;
            min-width: 150px;
            height: 44px;             
            box-sizing: border-box;
            margin: 0;                
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-13z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center; 
            background-size: 10px 10px;             
            transition: background-color 0.2s, border-color 0.2s;
        }

        select.styled-select:hover {
            background-color: #0056b3; 
            border-color: #004085;
        }

        select.styled-select:focus {
            outline: none; 
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5); 
        }

        select.styled-select option {
            background-color: #333; 
            color: #e0e0e0;      
        }

        .settings-content-wrapper > div.keybind-setting-row {
            padding-top: 8px;    
            padding-bottom: 8px; 
        }
        #howToPlayScreenContent, #appearanceScreenContent {flex-grow:1;overflow-y:auto;min-height:0;width:100%;padding-right:15px;text-align:left;padding-bottom:20px}
                
        #howToPlayScreenContent {
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            width:100%;
            padding-right:15px; 
            text-align:left;    
            padding-bottom:20px; 
            display: flex;
            flex-direction: column;
            gap: 25px; 
        }

        .help-section {
            background-color: #282828; 
            padding: 20px; 
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        .help-section h3 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            font-size: 1.4em; 
        }

        .help-section h4 {
            color: #e0e0e0; 
            margin-top: 20px; 
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .help-section p, .help-section ul {
            margin-bottom: 15px;
            font-size: 1.05em; 
            line-height: 1.6;  
            color: #d0d0d0;  
        }
        .help-section p:last-child, .help-section ul:last-child {
            margin-bottom: 0; 
        }

        .help-section ul {
            list-style-type: disc; 
            list-style-position: outside; 
            padding-left: 25px; 
        }

        .help-section ul li {
            margin-bottom: 8px; 
        }
        .help-section ul li:last-child {
            margin-bottom: 0;
        }

        .help-section strong { 
            color: #e0e0e0; 
            font-weight: 700; 
        }
        #pauseOverlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);color:white;display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:2em;z-index:99;text-align:center}
        #pauseOverlay small{font-size:0.6em;margin-top:10px}
        .powerup-text-display{position:absolute;left:50%;top:40%;transform:translateX(-50%);font-size:2.5em;font-weight:bold;color:#FFDC00;text-shadow:0 0 5px black;pointer-events:none;z-index:101;opacity:1;animation:powerupTextAnim 1s forwards}
        @keyframes powerupTextAnim{0%{transform:translateX(-50%) scale(1);opacity:1}50%{transform:translateX(-50%) scale(1.1);opacity:1}100%{transform:translateX(-50%) scale(1.3);opacity:0}}
        
        #quitConfirmationDialog, #deleteReplayConfirmationDialog, #deleteAllReplaysConfirmationDialog, #exportReplayDialog, #importReplayDialog {
            position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(20,20,25,0.95);
            padding:25px 30px;border-radius:10px;border:1px solid #555;z-index:200;text-align:center;color:#e0e0e0;
            box-shadow:0 0 15px rgba(0,0,0,0.5);display:flex;flex-direction:column;align-items:center; min-width: 300px; max-width: 90vw;
        }
        #quitConfirmationDialog p, #deleteReplayConfirmationDialog p, #deleteAllReplaysConfirmationDialog p, #exportReplayDialog p, #importReplayDialog p {
             font-size:1.25em;margin-top:0;margin-bottom:25px
        }
        #quitConfirmationButtons, #deleteReplayConfirmationButtons, #deleteAllReplaysConfirmationButtons, #exportReplayButtons, #importReplayButtons {
            display:flex;justify-content:center; width:100%;
        }
        #quitConfirmationButtons button, #deleteReplayConfirmationButtons button, #deleteAllReplaysConfirmationButtons button, #exportReplayButtons button, #importReplayButtons button {
            margin:0 10px
        }
        #confirmQuitBtn, #confirmDeleteReplayBtn, #confirmDeleteAllReplaysBtn {background-color:#dc3545; border-color: #c82333;}
        #confirmQuitBtn:hover, #confirmDeleteReplayBtn:hover, #confirmDeleteAllReplaysBtn:hover {background-color:#c82333; border-color: #9b1a26;}
        #closeExportReplayBtn {background-color:#007bff; border-color: #0056b3;}
        #closeExportReplayBtn:hover {background-color:#0056b3; border-color: #004085;}
        
        #exportReplayTextArea { width: 90%; min-height: 100px; max-height: 200px; margin-bottom: 15px; background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #444; font-family: monospace; resize: vertical;}
        #importReplayTextArea { width: 90%; min-height: 100px; max-height: 200px; margin-bottom: 15px; background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #444; font-family: monospace; resize: vertical;}
        #importReplayError {
            color: #dc3545;
            margin-top: 10px; 
            font-size: 0.9em;
            min-height: 1.2em; 
            position: relative; 
            top: -15px; 
        }
        #importReplayAndPlayBtn { background-color: #28a745 !important; border-color: #1e7e34 !important; display: flex; align-items: center; justify-content: center; padding: 8px 13px !important;} /* 10-2=8, 15-2=13 */
        #importReplayAndPlayBtn svg.play-svg-icon { margin-right: 8px; width:18px; height:18px;} 

        #modeSelectionDialog{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(20,20,25,0.95);padding:30px 40px;border-radius:10px;border:1px solid #555;z-index:250;text-align:center;color:#e0e0e0;box-shadow:0 0 20px rgba(0,0,0,0.6);flex-direction:column;align-items:center}
        #modeSelectionDialog h2{margin-top:0;margin-bottom:25px;color:#61dafb}
        #modeSelectionButtons{display:flex;justify-content:center;margin-bottom:10px}
        #modeSelectionButtons button{margin:0 15px;min-width:120px}
        
        #replayControlsContainer { 
            display: none; flex-direction: row; align-items: center; justify-content: center; 
            padding: 10px; background-color: rgba(0,0,0,0.5); width: 100%; 
            max-width: 800px; box-sizing: border-box; z-index: 6; height: 50px; 
        }
        #replayControlsContainer button { padding: 6px 13px; font-size: 0.9em; margin: 0 5px; border: 2px solid transparent;} /* 8-2=6, 15-2=13 */
#replayControlsContainer button#replayPlayPauseBtn {
    padding: 0;
    width: 36px; 
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 0;
    border: 2px solid #0056b3; 
}
#replayControlsContainer button#replayPlayPauseBtn:hover {
    border-color: #004085;
}


.replay-control-svg-icon {
    width: 18px; 
    height: 18px;
}
        #replaySeekBar { flex-grow: 1; margin: 0 10px; cursor: pointer; }
        #replayTimeDisplay { font-size: 0.9em; color: #fff; min-width: 100px; text-align: center; }

        #deleteAllReplaysContainer { margin-top: 20px; width: 100%; display: flex; justify-content: center; }
        #deleteAllReplaysBtn { background-color: #dc3545; border-color: #c82333; display:inline-flex; align-items:center; justify-content: center;}
        #deleteAllReplaysBtn:hover { background-color: #c82333; border-color: #9b1a26; }
        #deleteAllReplaysBtn svg { margin-right: 8px; }


        
    #howToPlayBtn {
        background-color: #28a745; 
        border-color: #1e7e34;
        margin-bottom: 40px; 
    }
    #howToPlayBtn:hover { background-color: #218838; border-color: #155724;}
    
    #howToPlayBtn, #howToPlayBtn .menu-btn-icon {
        color: #ffffff;
        fill: #ffffff;
        stroke: #ffffff;
    }


    #startGameBtn { background-color: #007bff; border-color: #0056b3;} 
    #startGameBtn:hover { background-color: #0056b3; border-color: #004085;}

    #appearanceBtn { background-color: #6f42c1; border-color: #5a32a3;} 
    #appearanceBtn:hover { background-color: #5a32a3; border-color: #472780;}

    #settingsBtn { background-color: #17a2b8; border-color: #117a8b;} 
    #settingsBtn:hover { background-color: #138496; border-color: #0d6775;}

    #highScoresBtn {
        background-color: #ffc107; border-color: #e0a800;    }
    #highScoresBtn:hover { background-color: #e0a800; border-color: #b38600;}
    #highScoresBtn .menu-btn-icon { 
        fill: #ffffff;
        stroke: #ffffff;
    }

    #replaysBtn { background-color: #fd7e14; border-color: #e66800;} 
    #replaysBtn:hover { background-color: #e66800; border-color: #c65800;}

    
    #startGameBtn .menu-btn-icon,
    #appearanceBtn .menu-btn-icon,
    #settingsBtn .menu-btn-icon,
    #replaysBtn .menu-btn-icon {
        fill: #ffffff;
        stroke: #ffffff;
    }

        
        #classicModeBtn { background-color: #28a745; border-color: #1e7e34;} 
        #classicModeBtn:hover { background-color: #218838; border-color: #155724;}
        #hardcoreModeBtn { background-color: #dc3545; border-color: #c82333;} 
        #hardcoreModeBtn:hover { background-color: #c82333; border-color: #9b1a26;}
#cancelModeSelectionBtn,
#cancelDeleteAllReplaysBtn,
#cancelDeleteReplayBtn,
#cancelQuitBtn,
#closeExportReplayBtn,
#cancelImportReplayBtn { background-color: #6c757d; border-color: #545b62;}
#cancelModeSelectionBtn:hover,
#cancelDeleteAllReplaysBtn:hover,
#cancelDeleteReplayBtn:hover,
#cancelQuitBtn:hover,
#closeExportReplayBtn:hover,
#cancelImportReplayBtn:hover { background-color: #5a6268; border-color: #454c52;}
#uiOverlay #gameScreenDeleteReplayBtnInOverlay {
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 42px !important;
    height: 42px !important;
    padding: 6px !important; /* 8-2 = 6px */
    border-radius: 5px !important;
    cursor: pointer !important;
    background-color: #dc3545;   
    border: 2px solid #c82333 !important; 
    margin-left: auto !important;
    margin-right: 16px !important;
    position: relative !important;
    z-index: 10 !important;
    opacity: 1 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    transition: background-color 0.2s, border-color 0.2s; 
}

#uiOverlay #gameScreenDeleteReplayBtnInOverlay:hover {
    background-color: #c82333 !important; 
    border-color: #9b1a26 !important; 
}
#uiOverlay #gameScreenDeleteReplayBtnInOverlay .menu-btn-icon {
    width: 24px !important; 
    height: 24px !important; 
    margin: 0 !important; 
}
#uiOverlay > .screen-header-btn {
    position: relative; 
    top: auto;          
    right: auto;        
    transform: none;    
    align-self: center; 
}

body #replaysScreen .screen-header .screen-header-btn { 
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    width: 42px !important; 
    height: 42px !important; 
    padding: 6px !important; /* 8-2=6px */
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-width: auto !important; 
}

body #replaysScreen .screen-header .import-icon-btn .import-svg-icon { 
    width: 28px !important;
    height: 28px !important;
    
}


body #replaysScreen .replays-mode-list .replay-item .item-actions button { 
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important; /* Padding already 0, border handled by direct border property */
    margin: 0 0 0 5px !important; 
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-width: auto !important; 
    border-radius: 4px !important; 
}

body #replaysScreen .replays-mode-list .replay-item .item-actions button svg { 
    width: 20px !important;
    height: 20px !important;
    
}


body #replaysScreen .replays-mode-list .replay-item .item-actions button.play-btn-geom,
body #replaysScreen .replays-mode-list .replay-item .item-actions button.delete-btn-geom,
body #replaysScreen .replays-mode-list .replay-item .item-actions button.export-btn-geom {
    padding: 0 !important; 
}
.threshold-editable-area {
     background-color: #007bff; 
     color: white;             
     border: 2px solid #0056b3;             
     padding: 0 13px; /* 15-2=13 */       
     font-size: 1em;           
     border-radius: 5px;       
     cursor: text;             
     min-width: 80px;          
     height: 44px;             
     box-sizing: border-box;
     text-align: center;       
     display: inline-flex;     
     align-items: center;      
     justify-content: center;  
     outline: none;            
 }
    </style>
</head>
<body>









    <div id="homeScreen" class="screen active">
        <h1>Orbila</h1>
        <button id="howToPlayBtn">
            <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.00024">
                <g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM10.3027 13.3942C10.2316 13.7147 10.5038 14 10.8479 14H13.0406C13.2979 14 13.5151 13.8351 13.6064 13.6061C13.697 13.3789 14.0117 12.9674 14.254 12.7518C14.4827 12.5112 14.7213 12.2848 14.9563 12.0618C15.8824 11.183 16.754 10.356 16.754 8.91047C16.754 6.40301 14.582 5 12.2707 5C10.5038 5 8.06416 5.80604 7.58396 8.50363C7.48716 9.04737 7.94773 9.5 8.50002 9.5H9.91229C10.4388 9.5 10.8312 9.07642 11.0121 8.582C11.1863 8.10604 11.5379 7.7551 12.2707 7.7551C13.6066 7.7551 13.6064 9.22371 12.8346 10.1843C12.5434 10.5467 12.2023 10.8677 11.8648 11.1853C11.1798 11.8298 10.5098 12.4602 10.3027 13.3942ZM13.9999 17C13.9999 18.1046 13.1045 19 11.9999 19C10.8954 19 9.99994 18.1046 9.99994 17C9.99994 15.8954 10.8954 15 11.9999 15C13.1045 15 13.9999 15.8954 13.9999 17Z" fill="currentColor"></path> </g>
            </svg>
            How to Play
        </button>
        <button id="startGameBtn"> 
            <svg viewBox="0 0 24 24" class="menu-btn-icon play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path>
            </svg>
            Play
        </button>
        <button id="appearanceBtn"> 
            <svg class="menu-btn-icon" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve">
                 <g> <path d="M410.842,207.265c97.767-8.626,117.891-54.628,89.098-97.749C448.234,32.075,334.016,1.59,218.762,36.607 C73.721,80.672-22.226,214.687,4.453,335.938C31.13,457.19,170.334,519.762,315.375,475.697 c62.951-19.13,116.653-55.201,155.091-99.821c15.516-18.01,20.891-73.726-50.998-70.844 C342.812,308.106,332.197,214.206,410.842,207.265z M385.949,102.144c7.068-7.059,16.84-11.111,26.839-11.111 c9.998,0,19.762,4.052,26.838,11.111c7.067,7.076,11.119,16.848,11.119,26.847s-4.052,19.762-11.119,26.838 c-7.076,7.067-16.84,11.12-26.838,11.12c-9.999,0-19.771-4.052-26.839-11.12c-7.067-7.076-11.119-16.839-11.119-26.838 S378.882,109.22,385.949,102.144z M65.256,226.724c5.711-17.185,24.26-26.485,41.436-20.782 c17.185,5.711,26.493,24.261,20.79,41.437c-5.711,17.184-24.269,26.484-41.438,20.789C68.861,262.449,59.553,243.9,65.256,226.724z M127.946,377.433c-11.794,12.451-31.455,12.998-43.905,1.214c-12.459-11.793-12.998-31.446-1.204-43.896 c11.785-12.459,31.437-13.006,43.896-1.213C139.182,345.323,139.73,364.975,127.946,377.433z M190.542,171.051 c-15.466,11.128-37.031,7.606-48.159-7.86c-11.128-15.474-7.606-37.03,7.859-48.159v-0.008 c15.475-11.119,37.032-7.598,48.159,7.868C209.53,138.358,206.009,159.923,190.542,171.051z M250.461,105.589 c-2.317-19.88,11.919-37.857,31.8-40.165c19.872-2.308,37.857,11.929,40.165,31.8c2.316,19.872-11.928,37.856-31.801,40.164 C270.746,139.706,252.769,125.461,250.461,105.589z M360.897,377.106c0,12.121-4.911,23.948-13.478,32.524 c-8.567,8.566-20.411,13.478-32.533,13.478c-12.113,0-23.965-4.912-32.524-13.478c-8.566-8.576-13.478-20.403-13.478-32.524 c0-12.122,4.912-23.974,13.478-32.542c8.559-8.559,20.411-13.47,32.524-13.47c12.122,0,23.966,4.911,32.533,13.47 C355.986,353.131,360.897,364.983,360.897,377.106z"></path> </g>
            </svg>
            Cosmetic
        </button>
        <button id="settingsBtn">
            <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.00024">
                <g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M14.2788 2.15224C13.9085 2 13.439 2 12.5 2C11.561 2 11.0915 2 10.7212 2.15224C10.2274 2.35523 9.83509 2.74458 9.63056 3.23463C9.53719 3.45834 9.50065 3.7185 9.48635 4.09799C9.46534 4.65568 9.17716 5.17189 8.69017 5.45093C8.20318 5.72996 7.60864 5.71954 7.11149 5.45876C6.77318 5.2813 6.52789 5.18262 6.28599 5.15102C5.75609 5.08178 5.22018 5.22429 4.79616 5.5472C4.47814 5.78938 4.24339 6.1929 3.7739 6.99993C3.30441 7.80697 3.06967 8.21048 3.01735 8.60491C2.94758 9.1308 3.09118 9.66266 3.41655 10.0835C3.56506 10.2756 3.77377 10.437 4.0977 10.639C4.57391 10.936 4.88032 11.4419 4.88029 12C4.88026 12.5581 4.57386 13.0639 4.0977 13.3608C3.77372 13.5629 3.56497 13.7244 3.41645 13.9165C3.09108 14.3373 2.94749 14.8691 3.01725 15.395C3.06957 15.7894 3.30432 16.193 3.7738 17C4.24329 17.807 4.47804 18.2106 4.79606 18.4527C5.22008 18.7756 5.75599 18.9181 6.28589 18.8489C6.52778 18.8173 6.77305 18.7186 7.11133 18.5412C7.60852 18.2804 8.2031 18.27 8.69012 18.549C9.17714 18.8281 9.46533 19.3443 9.48635 19.9021C9.50065 20.2815 9.53719 20.5417 9.63056 20.7654C9.83509 21.2554 10.2274 21.6448 10.7212 21.8478C11.0915 22 11.561 22 12.5 22C13.439 22 13.9085 22 14.2788 21.8478C14.7726 21.6448 15.1649 21.2554 15.3694 20.7654C15.4628 20.5417 15.4994 20.2815 15.5137 19.902C15.5347 19.3443 15.8228 18.8281 16.3098 18.549C16.7968 18.2699 17.3914 18.2804 17.8886 18.5412C18.2269 18.7186 18.4721 18.8172 18.714 18.8488C19.2439 18.9181 19.7798 18.7756 20.2038 18.4527C20.5219 18.2105 20.7566 17.807 21.2261 16.9999C21.6956 16.1929 21.9303 15.7894 21.9827 15.395C22.0524 14.8691 21.9088 14.3372 21.5835 13.9164C21.4349 13.7243 21.2262 13.5628 20.9022 13.3608C20.4261 13.0639 20.1197 12.558 20.1197 11.9999C20.1197 11.4418 20.4261 10.9361 20.9022 10.6392C21.2263 10.4371 21.435 10.2757 21.5836 10.0835C21.9089 9.66273 22.0525 9.13087 21.9828 8.60497C21.9304 8.21055 21.6957 7.80703 21.2262 7C20.7567 6.19297 20.522 5.78945 20.2039 5.54727C19.7799 5.22436 19.244 5.08185 18.7141 5.15109C18.4722 5.18269 18.2269 5.28136 17.8887 5.4588C17.3915 5.71959 16.7969 5.73002 16.3099 5.45096C15.8229 5.17191 15.5347 4.65566 15.5136 4.09794C15.4993 3.71848 15.4628 3.45833 15.3694 3.23463C15.1649 2.74458 14.7726 2.35523 14.2788 2.15224ZM12.5 15C14.1695 15 15.5228 13.6569 15.5228 12C15.5228 10.3431 14.1695 9 12.5 9C10.8305 9 9.47716 10.3431 9.47716 12C9.47716 13.6569 10.8305 15 12.5 15Z" fill="currentColor"></path> </g>
            </svg>
            Settings
        </button>
        <button id="highScoresBtn">
            <svg class="menu-btn-icon" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" stroke-width="0.00064">
                <g id="SVGRepo_iconCarrier"> <path d="M60,4H48c0-2.215-1.789-4-4-4H20c-2.211,0-4,1.785-4,4H4C1.789,4,0,5.785,0,8v8c0,8.836,7.164,16,16,16 c0.188,0,0.363-0.051,0.547-0.059C17.984,37.57,22.379,41.973,28,43.43V56h-8c-2.211,0-4,1.785-4,4v4h32v-4c0-2.215-1.789-4-4-4h-8 V43.43c5.621-1.457,10.016-5.859,11.453-11.488C47.637,31.949,47.812,32,48,32c8.836,0,16-7.164,16-16V8C64,5.785,62.211,4,60,4z M8,16v-4h8v12C11.582,24,8,20.414,8,16z M56,16c0,4.414-3.582,8-8,8V12h8V16z"></path> </g>
            </svg>
            Personal Bests
        </button>
        <button id="replaysBtn"> 
             <svg viewBox="0 0 24 24" class="menu-btn-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                <rect x="1.71" y="2" width="20.57" height="14" rx="2"></rect>
                <rect x="9.43" y="16" width="5.14" height="4" rx="1"></rect>
                <rect x="5.55" y="20" width="12.88" height="2" rx="1"></rect>
            </svg>
            Replays
        </button>
    </div>

    <div id="gameScreen" class="screen"> 
        <div id="gameScreenContainer">
            <div id="canvasArea">
                <canvas id="atmosphericCanvas"></canvas>
                <canvas id="gameCanvas"></canvas>
 <div id="uiOverlay">
    <div class="game-stats">
        <div>Score: <span id="scoreDisplay">0</span></div>
        <div>Time: <span id="timeDisplay">00:00.0</span></div>
        <div>Lives: <span id="livesDisplay">❤❤❤</span></div>
    </div>
    <!-- NEW DELETE BUTTON FOR REPLAY -->
    <!-- NEW DELETE BUTTON FOR REPLAY -->
      <button id="gameScreenDeleteReplayBtnInOverlay" class="screen-header-btn" title="Delete Current Replay" style="display: none; background-color: #dc3545;">
       <!-- SVG from step 1 -->
        <svg class="menu-btn-icon" viewBox="-1 -1.5 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
        </svg>
   </button>
    <button id="gameScreenHomeBtnInOverlay" class="screen-header-btn home-icon-btn" title="Back to Home">
        <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
    </button>
</div>
                <div id="powerupIconsContainer">
                    <div class="powerup-icon" id="slowFallIcon" title="Slow Fall (Vertical & Horizontal)"><div class="up-arrow-shaft"></div><div class="up-arrow-head"></div></div>
                    <div class="powerup-icon" id="wideBucketIcon" title="Wide Bucket"><div class="wide-bucket-base-angled"></div><div class="wide-bucket-side-angled wide-bucket-left-angled"></div><div class="wide-bucket-side-angled wide-bucket-right-angled"></div></div>
                    <div class="powerup-icon" id="oneColorIcon" title="One Color"><div class="one-color-circle-shape"></div></div>
                    <div class="powerup-icon" id="doublePointsIcon" title="Double Points">x2</div>
                    <div class="powerup-icon" id="magnetIcon" title="White Ball Magnet"><div class="magnet-body"></div><div class="magnet-pole magnet-pole-left"></div><div class="magnet-pole magnet-pole-right"></div></div>
                </div>
                <div id="gameOverScreen" style="display:none;">
                    <h2 id="gameOverTitle">Game Mode</h2> 
                    <div id="newHighScoreText" style="display:none;">New Personal Best!</div>
                    <div id="gameOverScoreTime">
                        <span>Score: <span id="finalScoreDisplay">0</span></span>
                        <span>Time: <span id="finalTimeDisplay">00:00.0</span></span>
                    </div>
                    <div id="gameOverButtons">
                        <div class="game-over-button-row">
                            <button id="playAgainBtn">
                                 <svg viewBox="-1.5 0 19 19" class="menu-btn-icon" version="1.1" xmlns="http://www.w3.org/2000/svg">
                                    <g stroke="none" stroke-width="1" fill-rule="evenodd">
                                        <g transform="translate(-1193.000000, -305.000000)">
                                            <g transform="translate(1189.000000, 302.000000)">
                                                <path d="M12,7 C15.8659932,7 19,10.1340068 19,14 C19,17.8659932 15.8659932,21 12,21 C8.13400675,21 5,17.8659932 5,14" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"> </path>
                                                <path d="M10.8260915,10.8857148 L5.69568021,7.30477744 C5.47956961,7.17854145 5.43577155,6.93976099 5.5978545,6.77144635 C5.62566353,6.74256812 5.65860149,6.71691486 5.69568021,6.69525619 L10.8260915,3.11431886 C11.1502574,2.92496489 11.610137,2.97613213 11.8532614,3.2286041 C11.948511,3.32751578 12,3.4478202 12,3.5714598 L12,10.4285738 C12,10.7441638 11.6715145,11 11.2663072,11 C11.1075579,11 10.9530909,10.9598985 10.8260915,10.8857148 Z" fill="#ffffff"> </path>
                                            </g>
                                        </g>
                                    </g>
                                </svg>
                                <span class="btn-text">Play Again</span>
                            </button>
                            <button id="saveReplayBtn" style="display: inline-block;"> 
                                <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 18 24" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="0.00024"><path d="M21,20V8.414a1,1,0,0,0-.293-.707L16.293,3.293A1,1,0,0,0,15.586,3H4A1,1,0,0,0,3,4V20a1,1,0,0,0,1,1H20A1,1,0,0,0,21,20ZM9,8h4a1,1,0,0,1,0,2H9A1,1,0,0,1,9,8Zm7,11H8V15a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1Z"></path></svg>
                                <span class="btn-text">Save Replay</span>
                            </button>
                        </div>
                        <button id="gameOverQuitBtn">
                            <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><g><path d="M510.371,226.513c-1.088-2.603-2.645-4.971-4.629-6.955l-63.979-63.979c-8.341-8.32-21.824-8.32-30.165,0 c-8.341,8.341-8.341,21.845,0,30.165l27.584,27.584H320.013c-11.797,0-21.333,9.557-21.333,21.333s9.536,21.333,21.333,21.333 h119.168l-27.584,27.584c-8.341,8.341-8.341,21.845,0,30.165c4.16,4.181,9.621,6.251,15.083,6.251s10.923-2.069,15.083-6.251 l63.979-63.979c1.984-1.963,3.541-4.331,4.629-6.955C512.525,237.606,512.525,231.718,510.371,226.513z"></path> <path d="M362.68,298.667c-11.797,0-21.333,9.557-21.333,21.333v106.667h-85.333V85.333c0-9.408-6.187-17.728-15.211-20.437 l-74.091-22.229h174.635v106.667c0,11.776,9.536,21.333,21.333,21.333s21.333-9.557,21.333-21.333v-128 C384.013,9.557,374.477,0,362.68,0H21.347c-0.768,0-1.451,0.32-2.197,0.405c-1.003,0.107-1.92,0.277-2.88,0.512 c-2.24,0.576-4.267,1.451-6.165,2.645c-0.469,0.299-1.045,0.32-1.493,0.661C8.44,4.352,8.376,4.587,8.205,4.715 C5.88,6.549,3.939,8.789,2.531,11.456c-0.299,0.576-0.363,1.195-0.597,1.792c-0.683,1.621-1.429,3.2-1.685,4.992 c-0.107,0.64,0.085,1.237,0.064,1.856c-0.021,0.427-0.299,0.811-0.299,1.237V448c0,10.176,7.189,18.923,17.152,20.907 l213.333,42.667c1.387,0.299,2.795,0.427,4.181,0.427c4.885,0,9.685-1.685,13.525-4.843c4.928-4.053,7.808-10.091,7.808-16.491 v-21.333H362.68c11.797,0,21.333-9.557,21.333-21.333V320C384.013,308.224,374.477,298.667,362.68,298.667z"></path></g></svg>
                            <span class="btn-text">Quit</span>
                        </button>
                    </div>
                </div>
                <div id="pauseOverlay" style="display:none;">Game Paused<small>(Press 'P' or Click to Resume)</small></div>
            </div>
            <div id="replayControlsContainer"> 
                <button id="replayPlayPauseBtn"></button>
                <input type="range" id="replaySeekBar" min="0" max="10000" value="0">
                <span id="replayTimeDisplay">00:00.0 / 00:00.0</span>
            </div>
        </div>
    </div>
    
    <div id="settingsScreen" class="screen">
        <div class="screen-header"><h2>Settings</h2><button id="settingsToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home">
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div class="settings-content-wrapper scrollable-content-wrapper">
            <!-- Audio Section -->
            <div class="setting-section">
                <h3>Audio</h3>
                <div class="setting-item">
                    <label for="volumeSlider">Master Volume:</label>
                    <span class="setting-control-group">
                        <input type="range" id="volumeSlider" min="0" max="100" value="70">
                        <span id="volumeValueDisplay" class="slider-value-display">70</span>
                    </span>
                </div>
            </div>

            <!-- Video Section -->
            <div class="setting-section">
                <h3>Video</h3>
                <div class="setting-item">
                    <label for="qualitySelect">Graphics Quality:</label>
                    <span class="setting-control-group">
                        <select id="qualitySelect" class="styled-select">
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                    </span>
                </div>
            </div>

            <!-- Gameplay Section -->
            <div class="setting-section">
                <h3>Gameplay</h3>
                <div class="setting-item"> <!-- Bucket Sensitivity -->
                    <label for="sensitivitySlider">Bucket Sensitivity:</label>
                    <span class="setting-control-group">
                        <input type="range" id="sensitivitySlider" min="1" max="10" value="5">
                        <span id="sensitivityValueDisplay" class="slider-value-display">5</span>
                    </span>
                </div>
                <div class="setting-item"> <!-- Autosave Replays & Threshold -->
                    <div style="display: flex; flex-direction: column; align-items: flex-start; width: 100%;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 8px;">
                            <label for="autosaveReplaysSelect" style="margin-right: 20px; width: 220px; text-align: left; flex-shrink: 0;">Autosave Replays:</label>
                            <span class="setting-control-group" style="justify-content: flex-end; flex-grow: 1;">
                                <select id="autosaveReplaysSelect" class="styled-select">
                                    <option value="no">No</option>
                                    <option value="yes">Yes</option>
                                </select>
                            </span>
                        </div>
                        <div id="autosaveThresholdElements" style="display: none; justify-content: space-between; align-items: center; width: 100%; padding-left: 0px;"> <!-- This div itself is a setting-item conceptually -->
                            <label for="autosaveThresholdBtn" style="margin-right: 20px; width: 220px; text-align: left; flex-shrink: 0;">Above score:</label>
                            <span class="setting-control-group" style="justify-content: flex-end; flex-grow: 1;">
                                <button class="keybindBtn" id="autosaveThresholdBtn" style="margin-right: 5px;">100</button>
                            </span>
                        </div>
                    </div>
                </div>
                <div class="setting-item keybind-setting-row"> <!-- Move Left -->
                    <label for="keybindLeftBtn">Move Bucket Left: </label>
                    <span class="setting-control-group">
                        <button class="keybindBtn" id="keybindLeftBtn">A</button>
                    </span>
                </div>
                <div class="setting-item keybind-setting-row"> <!-- Move Right -->
                    <label for="keybindRightBtn">Move Bucket Right: </label>
                    <span class="setting-control-group">
                        <button class="keybindBtn" id="keybindRightBtn">D</button>
                    </span>
                </div>
                <div class="setting-item keybind-setting-row"> <!-- Max Speed -->
                    <label for="keybindMaxSpeedBtn">Max Speed Toggle: </label>
                    <span class="setting-control-group">
                        <button class="keybindBtn" id="keybindMaxSpeedBtn">W</button>
                    </span>
                </div>
                <div class="setting-item keybind-setting-row"> <!-- Pause -->
                    <label for="keybindPauseBtn">Pause Game: </label>
                    <span class="setting-control-group">
                        <button class="keybindBtn" id="keybindPauseBtn">P</button>
                    </span>
                </div>
            </div>
        </div>
    </div>
        <div id="highScoresScreen" class="screen">
        <div class="screen-header"><h2>Personal Bests</h2><button id="highScoresToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        
        <div class="mode-tabs-container scrollable-content-wrapper"> <!-- Renamed and acts as scrollable wrapper -->
            <div class="mode-tab-buttons">
                <button class="mode-tab-btn active" data-tab-target="#hsClassicModeTab">Classic</button>
                <button class="mode-tab-btn" data-tab-target="#hsHardcoreModeTab">Hardcore</button>
            </div>

            <div id="hsClassicModeTab" class="mode-tab-panel active">
                <!-- Classic scores will be populated here by JS -->
                <ol id="classicHighScoresList" class="score-mode-list"></ol> 
            </div>
            <div id="hsHardcoreModeTab" class="mode-tab-panel">
                <!-- Hardcore scores will be populated here by JS -->
                <ol id="hardcoreHighScoresList" class="score-mode-list"></ol>
            </div>
        </div>
    </div>
    <div id="howToPlayScreen" class="screen">
        <div class="screen-header"><h2>How to Play</h2><button id="howToPlayToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
                        <div id="howToPlayScreenContent" class="scrollable-content-wrapper">
            <div class="help-section">
                <h3>Objective</h3>
                <p>Catch falling balls to score as many points as possible before you run out of lives!</p>
            </div>

            <div class="help-section">
                <h3>Controls</h3>
                <ul>
                    <li>Use your <strong>Mouse</strong> to move the <strong>Color Wheel</strong>.</li>
                    <li>Press <strong>'A' / 'D'</strong> (or your custom keys) to move the <strong>Bucket</strong>.</li>
                    <li>Hold <strong>'W'</strong> (or your custom key) to make the <strong>Bucket move faster</strong>.</li>
                    <li>Press <strong>'P'</strong> (or your custom key) to <strong>Pause or Resume</strong> the game.</li>
                    <li>Press <strong>'Escape'</strong> to go back or to open the quit menu during gameplay.</li>
                </ul>
            </div>

            <div class="help-section">
                <h3>Gameplay Modes</h3>
                <h4>Classic Mode:</h4>
                <ul>
                    <li>You start with 3 lives.</li>
                    <li>Balls drop from two droppers at the top of the screen.</li>
                    <li>One dropper releases <strong>Red, Green, Blue</strong>, and special <strong>Yellow (Power-up)</strong> balls.</li>
                    <li>The other dropper releases <strong>White</strong> and <strong>Yellow (Power-up)</strong> balls.</li>
                    <li>Align the Color Wheel's segments with the corresponding Red, Green, or Blue balls to catch them.</li>
                    <li>White balls can be caught by any segment of the Color Wheel or by the Bucket.</li>
                    <li>The Bucket below the Color Wheel serves as a safety net.</li>
                    <li>The game gets faster and more challenging over time!</li>
                    <li>Collect Yellow balls to activate helpful Power-ups (see below).</li>
                </ul>
                <h4>Hardcore Mode:</h4>
                <ul>
                    <li>You have only 1 life – make it count!</li>
                    <li>Both droppers release only <strong>Red, Green, or Blue</strong> balls.</li>
                    <li>There are no White balls or Power-ups in this mode.</li>
                    <li>Test your skills and survive for as long as you can!</li>
                </ul>
            </div>

            <div class="help-section">
                <h3>Scoring</h3>
                <ul>
                    <li><strong>Catching a colored ball (RGB) with the correct Color Wheel segment:</strong> +3 points</li>
                    <li><strong>Catching a White ball with any Color Wheel segment:</strong> +3 points</li>
                    <li><strong>Catching any ball with the Bucket:</strong> +1 point</li>
                    <li><em>Tip: The "Double Points" power-up in Classic Mode will double these scores!</em></li>
                </ul>
            </div>

            <div class="help-section">
                <h3>Power-ups (Classic Mode Only)</h3>
                <p>In Classic Mode, catch Yellow balls (with the Color Wheel or Bucket) to activate a random power-up. Most power-ups last for 10 seconds.</p>
                <ul>
                    <li><strong>Slow Fall:</strong> All balls fall much slower.</li>
                    <li><strong>Wide Bucket:</strong> Your Bucket becomes significantly wider.</li>
                    <li><strong>One Color:</strong> For a short time, one dropper will only release balls of a single color (Red, Green, or Blue).</li>
                    <li><strong>Double Points:</strong> All points you score are doubled.</li>
                    <li><strong>Magnet:</strong> White balls are gently attracted towards your Color Wheel.</li>
                    <li><strong>+3 Lives:</strong> Instantly gain 3 extra lives! (This is a one-time effect).</li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>Losing Lives</h3>
                <ul>
                    <li>A colored ball (Red, Green, or Blue) hits the wrong segment of your Color Wheel.</li>
                    <li>A colored ball is missed by both the Color Wheel and the Bucket and falls off the screen.</li>
                    <li>You <strong>do not</strong> lose a life for missing White balls or Yellow (Power-up) balls.</li>
                    <li>The game ends when you have no lives left.</li>
                </ul>
            </div>
        </div>
    </div>
    <div id="appearanceScreen" class="screen">
        <div class="screen-header"><h2>Cosmetic</h2><button id="appearanceToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div id="appearanceScreenContent" class="scrollable-content-wrapper">
            <div class="cosmetic-tabs-container">
                <button class="cosmetic-tab-btn active" data-tab-target="#cosmeticTabOwned">Owned</button>
                <button class="cosmetic-tab-btn" data-tab-target="#cosmeticTabCoin">Coin</button>
                <button class="cosmetic-tab-btn" data-tab-target="#cosmeticTabXp">XP</button>
                <button class="cosmetic-tab-btn" data-tab-target="#cosmeticTabMystery">Mystery</button>
            </div>

            <div id="cosmeticTabOwned" class="cosmetic-tab-panel active">
                <!-- Content will be dynamically generated by JavaScript -->
            </div>
            <div id="cosmeticTabCoin" class="cosmetic-tab-panel">
                <!-- Content will be dynamically generated by JavaScript -->
            </div>
            <div id="cosmeticTabXp" class="cosmetic-tab-panel">
                <!-- Content will be dynamically generated by JavaScript -->
            </div>
            <div id="cosmeticTabMystery" class="cosmetic-tab-panel">
                <!-- Content will be dynamically generated by JavaScript -->
            </div>
        </div>
    </div>
          <div id="replaysScreen" class="screen">
        <div class="screen-header">
            <button id="importReplaysBtn" class="screen-header-btn import-icon-btn" title="Import Replay">
                <svg viewBox="0 0 24 24" class="import-svg-icon" xmlns="http://www.w3.org/2000/svg">
                  <line x1="12" y1="5" x2="12" y2="15" stroke="white" stroke-width="3" stroke-linecap="round"/>
                  <polyline points="8 11 12 15 16 11" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                  <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <h2>Replays</h2>
            <button id="replaysToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
                 <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
            </button>
        </div>

        <div class="mode-tabs-container scrollable-content-wrapper"> <!-- Renamed and acts as scrollable wrapper -->
            <div class="mode-tab-buttons">
                <button class="mode-tab-btn active" data-tab-target="#replaysClassicModeTab">Classic</button>
                <button class="mode-tab-btn" data-tab-target="#replaysHardcoreModeTab">Hardcore</button>
            </div>

            <div id="replaysClassicModeTab" class="mode-tab-panel active">
                <!-- Classic replays will be populated here -->
                <ol id="classicReplaysList" class="replays-mode-list"></ol>
            </div>
            <div id="replaysHardcoreModeTab" class="mode-tab-panel">
                <!-- Hardcore replays will be populated here -->
                <ol id="hardcoreReplaysList" class="replays-mode-list"></ol>
            </div>
            
            <div id="deleteAllReplaysContainer"> <!-- This can remain outside the tab panels if it applies to all -->
                <button id="deleteAllReplaysBtn">
                    <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                    </svg>
                    Delete All Replays
                </button>
            </div>
        </div>
    </div>

    <div id="quitConfirmationDialog" style="display:none;">
        <p>Are you sure you want to quit?</p>
        <div id="quitConfirmationButtons">
            <button id="confirmQuitBtn">
                 <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><g><path d="M510.371,226.513c-1.088-2.603-2.645-4.971-4.629-6.955l-63.979-63.979c-8.341-8.32-21.824-8.32-30.165,0 c-8.341,8.341-8.341,21.845,0,30.165l27.584,27.584H320.013c-11.797,0-21.333,9.557-21.333,21.333s9.536,21.333,21.333,21.333 h119.168l-27.584,27.584c-8.341,8.341-8.341,21.845,0,30.165c4.16,4.181,9.621,6.251,15.083,6.251s10.923-2.069,15.083-6.251 l63.979-63.979c1.984-1.963,3.541-4.331,4.629-6.955C512.525,237.606,512.525,231.718,510.371,226.513z"></path> <path d="M362.68,298.667c-11.797,0-21.333,9.557-21.333,21.333v106.667h-85.333V85.333c0-9.408-6.187-17.728-15.211-20.437 l-74.091-22.229h174.635v106.667c0,11.776,9.536,21.333,21.333,21.333s21.333-9.557,21.333-21.333v-128 C384.013,9.557,374.477,0,362.68,0H21.347c-0.768,0-1.451,0.32-2.197,0.405c-1.003,0.107-1.92,0.277-2.88,0.512 c-2.24,0.576-4.267,1.451-6.165,2.645c-0.469,0.299-1.045,0.32-1.493,0.661C8.44,4.352,8.376,4.587,8.205,4.715 C5.88,6.549,3.939,8.789,2.531,11.456c-0.299,0.576-0.363,1.195-0.597,1.792c-0.683,1.621-1.429,3.2-1.685,4.992 c-0.107,0.64,0.085,1.237,0.064,1.856c-0.021,0.427-0.299,0.811-0.299,1.237V448c0,10.176,7.189,18.923,17.152,20.907 l213.333,42.667c1.387,0.299,2.795,0.427,4.181,0.427c4.885,0,9.685-1.685,13.525-4.843c4.928-4.053,7.808-10.091,7.808-16.491 v-21.333H362.68c11.797,0,21.333-9.557,21.333-21.333V320C384.013,308.224,374.477,298.667,362.68,298.667z"></path></g></svg>
                Quit
            </button>
            <button id="cancelQuitBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>
    <div id="deleteReplayConfirmationDialog" style="display:none;">
        <p>Are you sure you want to delete this replay?</p>
        <div id="deleteReplayConfirmationButtons">
            <button id="confirmDeleteReplayBtn">
                 <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                        <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                </svg>
                Delete
            </button>
            <button id="cancelDeleteReplayBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>
    <div id="deleteAllReplaysConfirmationDialog" style="display:none;">
        <p>Are you sure you want to delete ALL replays? This cannot be undone.</p>
        <div id="deleteAllReplaysConfirmationButtons">
            <button id="confirmDeleteAllReplaysBtn">
                <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                    <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                </svg>
                Delete All</button>
            <button id="cancelDeleteAllReplaysBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel</button>
        </div>
    </div>
    
    <div id="exportReplayDialog" style="display:none;">
        <p>Replay Code:</p>
        <textarea id="exportReplayTextArea" readonly></textarea>
        <div id="exportReplayButtons">
                                    <button id="copyExportReplayBtn">
                <svg class="menu-btn-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.144" fill="currentColor" style="margin-right: 8px;">
                    
                    <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
                    <g id="SVGRepo_iconCarrier">
                        <path d="M14 8H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V10c0-1.103-.897-2-2-2z"></path>
                        <path d="M20 2H10a2 2 0 0 0-2 2v2h8a2 2 0 0 1 2 2v8h2a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"></path>
                    </g>
                </svg>
                <span class="btn-text-dynamic">Copy</span>
            </button>
            <button id="closeExportReplayBtn">Close</button>
        </div>
    </div>

    <div id="importReplayDialog" style="display:none;">
        <p>Paste Replay Code:</p>
        <textarea id="importReplayTextArea"></textarea>
        <div id="importReplayError"></div>
        <div id="importReplayButtons">
            <button id="importReplayAndPlayBtn">
                <svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px; width:18px; height:18px;">
                    <path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path>
                </svg>
                Import & Play
            </button>
            <button id="cancelImportReplayBtn">
                 <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>

    <div id="modeSelectionDialog" style="display:none;">
        <h2>Select Game Mode</h2>
        <div id="modeSelectionButtons">
            <button id="classicModeBtn">
                <svg viewBox="0 0 24.00 24.00" class="menu-btn-icon" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="0.00024"><path d="M2 9.1371C2 14 6.01943 16.5914 8.96173 18.9109C10 19.7294 11 20.5 12 20.5C13 20.5 14 19.7294 15.0383 18.9109C17.9806 16.5914 22 14 22 9.1371C22 4.27416 16.4998 0.825464 12 5.50063C7.50016 0.825464 2 4.27416 2 9.1371Z" fill="#ffffff"></path></svg>
                Classic
            </button>
            <button id="hardcoreModeBtn">
                <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff"><path d="M256 0C114.6 0 0 100.3 0 224c0 70.1 36.9 132.6 94.5 173.7 9.6 6.9 15.2 18.1 13.5 29.9l-9.4 66.2c-1.4 9.6 6 18.2 15.7 18.2H192v-56c0-4.4 3.6-8 8-8h16c4.4 0 8 3.6 8 8v56h64v-56c0-4.4 3.6-8 8-8h16c4.4 0 8 3.6 8 8v56h77.7c9.7 0 17.1-8.6 15.7-18.2l-9.4-66.2c-1.7-11.7 3.8-23 13.5-29.9C475.1 356.6 512 294.1 512 224 512 100.3 397.4 0 256 0zm-96 320c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64 64zm192 0c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64 64z"></path></svg>
                Hardcore
            </button>
        </div>
        <button id="cancelModeSelectionBtn" style="margin-top: 15px;">
            <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
            Cancel
        </button>
<div id="replayLimitNotification" style="display:none; position:fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #1a1a1a; color: red; padding: 10px 20px; border-radius: 5px;  border: 3px solid #555; z-index: 300; font-size: 1.1em; text-align: center;">
        Replay Limit Reached!
    </div>
<script>

let isInitialLoad = true; const _RMRIM = 1000 / 30; 
const REPLAY_SIM_STEP_MS = 16; 
const REPLAY_FORMAT_VERSION = 4; 
let lastClickSoundTime = 0;
const CLICK_SOUND_COOLDOWN_MS = 20;
let lastCollectedPowerupType = null;
let currentQualitySetting = 'high';
const QUALITY_SETTINGS_MAP = {
    low: 0.75,
    medium: 1.0,
    high: window.devicePixelRatio || 1 
};
let qualitySelectElement;
const playIconSVG = `<svg viewBox="0 0 24 24" class="replay-control-svg-icon" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z"/></svg>`;
const pauseIconSVG = `<svg viewBox="170 3605 8 8" class="replay-control-svg-icon" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M172,3605 C171.448,3605 171,3605.448 171,3606 L171,3612 C171,3612.552 171.448,3613 172,3613 C172.552,3613 173,3612.552 173,3612 L173,3606 C173,3605.448 172.552,3605 172,3605 M177,3606 L177,3612 C177,3612.552 176.552,3613 176,3613 C175.448,3613 175,3612.552 175,3612 L175,3606 C175,3605.448 175.448,3605 176,3605 C176.552,3605 177,3605.448 177,3606"/></svg>`;
const R_GM_MAP = { classic: 0, hardcore: 1 };
const R_GM_REV_MAP = ["classic", "hardcore"];
const R_PU_TYPES = { slowFall: 0, wideBucket: 1, oneColor: 2, doublePoints: 3, extraLives: 4, whiteBallMagnet: 5 };
const R_PU_REV_TYPES = ["slowFall", "wideBucket", "oneColor", "doublePoints", "extraLives", "whiteBallMagnet"];
const R_COLOR_CODES = { red: 0, green: 1, blue: 2, white: 3, powerup: 4 };
const R_REV_COLOR_NAMES = ["red", "green", "blue", "white", "powerup"]; 
const R_EV_TYPES = {
    MOUSE: 0, KEYDOWN: 1, KEYUP: 2, SCORE_LIVES: 3,
    POWERUP_ACT: 4, POWERUP_DEACT: 5,
    BALL_SPAWN: 6, BALL_DESPAWN: 7, GAME_END: 8
};
const R_REV_EV_TYPES = [ 
    "mouse", "keydown", "keyup", "scoreLivesUpdate",
    "powerupActivate", "powerupDeactivate",
    "ballSpawn", "ballDespawn", "gameEnd"
];
const R_DESPAWN_REASONS = {
    collectedPowerupWheel: 0, collectedWheelWhite: 1, collectedWheelCorrect: 2, collectedWheelWrong: 3,
    collectedPowerupBucket: 4, collectedBucket: 5,
    missedOffScreen: 6, missedOffScreen_LifeLoss: 7 
};
const R_REV_DESPAWN_REASONS = [
    "collectedPowerupWheel", "collectedWheelWhite", "collectedWheelCorrect", "collectedWheelWrong",
    "collectedPowerupBucket", "collectedBucket",
    "missedOffScreen", "missedOffScreen_LifeLoss"
];
// Near the top of your script, where other constants are defined:

const R_COSMETIC_DEFAULTS = {
    colorWheel: 0,
    bucket: 0,
    balls: "default",
    background: "default",
    trailCW: "default",
    trailPU: "default"
};

const R_SFX_DEFAULTS = {
    collectWheel: "default", // New: SFX for collecting ball with color wheel
    collectBucket: "default",// New: SFX for collecting ball with bucket
    ballDrop: "default",     // New: SFX for dropper dropping a ball
    loseLife: "default",     // New: SFX for losing a life
    collectPowerup: "default"// New: SFX for collecting a power-up ball
}; 

const COSMETIC_DISPLAY_NAMES = {
    appearance: {
        colorWheel: "Color Wheel",
        bucket: "Bucket",
        balls: "Balls",
        background: "Game Background",
        trailCW: "Color Wheel Trail",
        trailPU: "Power-up Trail"
    },
    sfx: {
        collectWheel: "Wheel Collect SFX",
        collectBucket: "Bucket Collect SFX",
        ballDrop: "Ball Drop SFX",
        loseLife: "Lose Life SFX",
        collectPowerup: "Power-up Collect SFX"
    }
};

let screenStack = [];
const MAX_HISTORY_LENGTH = 10;
const NAVIGABLE_MENU_SCREENS = ['home', 'settings', 'highScores', 'howToPlay', 'replays', 'appearance'];
let gSeed = 0; let pState = { x: 123456789, y: 362436069, z: 521288629, w: 88675123 };
let cRepData = null; let mRecIntId = null; 
let sReps = []; let rDelId = null; 
// Example rVState definition
let rVState = {
    activeReplay: null,
    isPlaying: false,
    isSeeking: false,
    currentTimeMs: 0,
    totalDurationMs: 0,
    nextEventIndex: 0,
    lastProcessedMouseTime: -1,
    prevReplayMouse: { x: 0, y: 0, t: 0 },
    nextReplayMouse: { x: 0, y: 0, t: 0 },
    keysPressedReplay: {},
    score: 0,
    lives: 0,
    isReplayDoublePointsActive: false,
    wasPlayingBeforeSeek: false,
    justSeeked: false // <<< ADD THIS NEW FLAG
};
let isResizingDuringReplay = false;
let rAnimId = null; 
let _MST=2*60*1000; let gameCanvas,gameCtx, canvasArea; let aCvs,aCtx;
let gameWidth,gameHeight; let score=0,lives=3,elapsedGameTimeMs=0;
let gameRunning=false,gamePaused=false, gameModeActive = false; 
let animationFrameId,lastTime=0,timePausedStarted=0;
let dropper1,dropper2; const balls=[]; let bucket,playerCursor;
let prevPlayerCursorPos = { x: 0, y: 0 }; // For tracking cursor movement
const MIN_CURSOR_MOVE_THRESHOLD_SQ = 2 * 2;
let nextBallId = 0; 
let autosaveReplays = 'no';
let autosaveThreshold = 100;
let autosaveReplaysSelect, autosaveThresholdElements, autosaveThresholdBtn;
let lastSavedReplayIdToWatch = null;

const colorWheelParticles=[]; const POWERUP_BALL_GLOW_COLOR='rgba(255, 229, 100, 0.2)'; const powerupGlowParticles=[];
const atmosphericParticles=[]; const _NAP=150; const _APAS=150; const _APMSC=5; const _NTP=400; const textureParticles=[];
const BALL_COLORS=['#FF0000','#00FF00','#0084ff']; const BALL_COLOR_NAMES=['red','green','blue'];
const POWERUP_BALL_COLOR_HEX='#FFD500'; const WHITE_BALL_COLOR_HEX='#E0E0E0';
let BALL_RADIUS_BASE; const _MBFTS=3.0; const _XBFTS=7.0; const _BSAR=0.03;
const DROPPER_COLOR='gray'; let DROPPER_WIDTH_BOTTOM; const DROPPER_HEIGHT=30; const DROPPER_TOP_WIDTH_RATIO=0.5;
let _IDTPS=7; const _FDTP=2; let _IBDIM=1000; let _FBDIM=250;
const BUCKET_COLOR='gray'; const BUCKET_HEIGHT=20; const BUCKET_LINE_WIDTH=4.5;
const _BBWRN=0.18; const _BBWRW=0.42; let cBktWR=_BBWRN; const BUCKET_SIDE_ANGLE=Math.PI/8;
let _BS=5; let _MBTTS=1.0; let _XBTTS=5; let cBktSPS; let _PCOR,_PCRT;
const PLAYER_CURSOR_OUTLINE_COLORS=['#FF0000','#00FF00','#0084ff'];
const _PCSA={red:{start:Math.PI/6,end:5*Math.PI/6},blue:{start:5*Math.PI/6,end:3*Math.PI/2},green:{start:3*Math.PI/2,end:Math.PI/6}};
const keysPressed={}; let keybindLeft='a',keybindRight='d',keybindMaxSpeed='w',keybindPause='p';
let lstnKey=null; const _PUDM=10000; const _PUFTM=2000; const _MINBSM=0.6; const _MAXBSM=1.4*1.1;
const _SFSM=0.45; const _OBSS=1.5; let cBllSS=_OBSS;
const activePowerups={slowFall:{active:false,endTime:0},wideBucket:{active:false,endTime:0},oneColor:{active:false,endTime:0,color:null},doublePoints:{active:false,endTime:0},whiteBallMagnet:{active:false,endTime:0}};
const _MBPP=40; const _MPI=15000; let currentGameMode='classic';
let screens={}; let scoreDisplay,timeDisplay,livesDisplay;
let finalScoreDisplay,finalTimeDisplay,gameOverQuitBtn,saveReplayBtnElem;
let sensitivitySlider,sensitivityValueDisplay; let volumeSlider,volumeValueDisplay;
let keybindLeftBtn,keybindRightBtn,keybindMaxSpeedBtn,keybindPauseBtn;
let newHighScoreTextElem; let powerupIconElems={};
let audioCtx; let masterVolume=0.7;
let quitConfirmationDialog,confirmQuitBtn,cancelQuitBtn,gameScreenHomeBtn;
let deleteReplayConfirmationDialog, confirmDeleteReplayBtn, cancelDeleteReplayBtn;
let deleteAllReplaysConfirmationDialog, confirmDeleteAllReplaysBtn, cancelDeleteAllReplaysBtn;
let exportReplayDialog, exportReplayTextArea, copyExportReplayBtn, closeExportReplayBtn;
let importReplayDialog, importReplayTextArea, importReplayError, importReplayAndPlayBtn, cancelImportReplayBtn;
let lastKnownMouseX = window.innerWidth / 2;
let lastKnownMouseY = window.innerHeight / 2;
let gPausedBefConf=false; let gPausedByConf=false; let modeSelectionDialogElem;
let replayPlayPauseBtn, replaySeekBar, replayTimeDisplayElem, replayControlsContainerElem;
let uiOverlayElem, powerupIconsContainerElem;
let lastSavedReplayId = null; 
let gameOverScreen; 
let pauseOverlay; 
let currentEquippedCosmetics = { ...R_COSMETIC_DEFAULTS };
let rateBasedTrailNextSpawnTime = {};



function fnIPRNG(seed) { pState.x = seed | 0; pState.y = (pState.x ^ 0xDEADBEEF) | 0; pState.z = (pState.y ^ 0xFACEFEED) | 0; pState.w = (pState.z ^ 0xC0FFEE) | 0; if (pState.x === 0 && pState.y === 0 && pState.z === 0 && pState.w === 0) { pState.w = 1;}}
function fnSRnd() { let t = pState.x; t ^= t << 11; t ^= t >>> 8; pState.x = pState.y; pState.y = pState.z; pState.z = pState.w; pState.w ^= pState.w >>> 19; pState.w ^= t; return (pState.w >>> 0) / 0x100000000;}

function fnSetReplayButtonIcon(isPlaying) {
    if (replayPlayPauseBtn) {
        replayPlayPauseBtn.innerHTML = isPlaying ? pauseIconSVG : playIconSVG;
    }
}

function fnUpdateStaticEntityGeometryOnResize(passedOldGameWidth, passedOldGameHeight, passedNewGameWidth, passedNewGameHeight) {
    const timeProgress = elapsedGameTimeMs / _MST; // Use global elapsedGameTimeMs for progression
    const currentDropperTimePerScreenS = _IDTPS - (_IDTPS - _FDTP) * Math.min(1, timeProgress);

    if (bucket) {
        bucket.baseWidth = passedNewGameWidth * cBktWR; // cBktWR is global
        if (passedOldGameWidth && passedOldGameWidth > 0) bucket.x = (bucket.x / passedOldGameWidth) * passedNewGameWidth;
        bucket.y = passedNewGameHeight - BUCKET_HEIGHT - (BUCKET_LINE_WIDTH / 2); // BUCKET_HEIGHT, BUCKET_LINE_WIDTH are global
    }
    if (dropper1) {
        if (passedOldGameWidth && passedOldGameWidth > 0) dropper1.x = (dropper1.x / passedOldGameWidth) * passedNewGameWidth;
        dropper1.width = DROPPER_WIDTH_BOTTOM; // Global
        dropper1.topWidth = DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO; // Globals
        dropper1.speed = (passedNewGameWidth - DROPPER_WIDTH_BOTTOM) / currentDropperTimePerScreenS;
    }
    if (dropper2) {
        if (passedOldGameWidth && passedOldGameWidth > 0) dropper2.x = (dropper2.x / passedOldGameWidth) * passedNewGameWidth;
        dropper2.width = DROPPER_WIDTH_BOTTOM; // Global
        dropper2.topWidth = DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO; // Globals
        dropper2.speed = (passedNewGameWidth - DROPPER_WIDTH_BOTTOM) / currentDropperTimePerScreenS;
    }
    balls.forEach(ball => { // balls is global
        if (passedOldGameWidth && passedOldGameWidth > 0 && passedOldGameHeight && passedOldGameHeight > 0) {
            ball.x = (ball.x / passedOldGameWidth) * passedNewGameWidth;
            ball.y = (ball.y / passedOldGameHeight) * passedNewGameHeight;
        }
        // BALL_RADIUS_BASE is global and updated early in handleResize
        const oldBallRadiusBaseVal = (passedOldGameWidth && passedOldGameWidth > 0) ? ((passedOldGameWidth * 0.05) - (passedOldGameWidth * 0.05 * 0.35)) / 3.5 : BALL_RADIUS_BASE;
        const sizeMultiplier = ball.radius / (oldBallRadiusBaseVal > 0 ? oldBallRadiusBaseVal : BALL_RADIUS_BASE);
        ball.radius = BALL_RADIUS_BASE * sizeMultiplier;

        if (ball.originalVy && ball.vy) {
            // activePowerups, currentGameMode, rVState are global
            const isSlowFallCurrentlyActive = activePowerups.slowFall.active && (currentGameMode === 'classic' && !rVState.activeReplay);
            const currentEffectiveOldHeight = (passedOldGameHeight && passedOldGameHeight > 0) ? passedOldGameHeight : passedNewGameHeight;
            const fallDuration = currentEffectiveOldHeight / (ball.originalVy / (isSlowFallCurrentlyActive ? _SFSM : 1)); // _SFSM is global
            if (fallDuration > 0) {
                ball.originalVy = passedNewGameHeight / fallDuration;
                ball.vy = isSlowFallCurrentlyActive ? ball.originalVy * _SFSM : ball.originalVy;
            } else {
                ball.originalVy = passedNewGameHeight / _MBFTS; // _MBFTS is global
                ball.vy = ball.originalVy;
            }
        }
    });
    if (playerCursor) { // playerCursor is global
        if (passedOldGameWidth && passedOldGameWidth > 0 && passedOldGameHeight && passedOldGameHeight > 0) {
            playerCursor.x = (playerCursor.x / passedOldGameWidth) * passedNewGameWidth;
            playerCursor.y = (playerCursor.y / passedOldGameHeight) * passedNewGameHeight;
        }
    }
}

function setupModeTabs(containerSelector) {
    const container = document.querySelector(containerSelector);
    if (!container) return;

    const tabButtons = container.querySelectorAll('.mode-tab-btn');
    const tabPanels = container.querySelectorAll('.mode-tab-panel');

    if (tabButtons.length === 0 || tabPanels.length === 0) return;

    let foundActive = false;
    tabButtons.forEach(btn => {
        if (btn.classList.contains('active') && !foundActive) {
            foundActive = true;
            const targetPanelId = btn.dataset.tabTarget;
            tabPanels.forEach(panel => panel.classList.remove('active'));
            const targetPanel = container.querySelector(targetPanelId);
            if (targetPanel) targetPanel.classList.add('active');
        } else if (btn.classList.contains('active') && foundActive) {
            btn.classList.remove('active');
             const targetPanelId = btn.dataset.tabTarget;
             const targetPanel = container.querySelector(targetPanelId);
             if (targetPanel) targetPanel.classList.remove('active');
        }
    });
    if (!foundActive && tabButtons.length > 0) {
        tabButtons[0].classList.add('active');
        const targetPanelId = tabButtons[0].dataset.tabTarget;
        const targetPanel = container.querySelector(targetPanelId);
        if (targetPanel) targetPanel.classList.add('active');
    }


    tabButtons.forEach(button => {
        if (!button.dataset.modeTabListener) {
            button.addEventListener('click', () => {
                fnPS('click'); 

                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));

                button.classList.add('active');
                const targetPanelId = button.dataset.tabTarget;
                const targetPanel = container.querySelector(targetPanelId);
                if (targetPanel) {
                    targetPanel.classList.add('active');
                }

                if (containerSelector === '#replaysScreen .mode-tabs-container') {
                    const deleteAllBtn = document.getElementById('deleteAllReplaysBtn');
                    if (deleteAllBtn) {
                        const svgIcon = deleteAllBtn.querySelector('svg');
                        let existingTextNode = null;
                        for (let i = 0; i < deleteAllBtn.childNodes.length; i++) {
                            if (deleteAllBtn.childNodes[i].nodeType === Node.TEXT_NODE && deleteAllBtn.childNodes[i].nodeValue.trim() !== '') {
                                existingTextNode = deleteAllBtn.childNodes[i];
                                break;
                            }
                        }
                        let newText = '';
                        if (targetPanelId === '#replaysClassicModeTab') {
                            newText = ' Delete Classic Replays';
                        } else if (targetPanelId === '#replaysHardcoreModeTab') {
                            newText = ' Delete Hardcore Replays';
                        }
                        if (existingTextNode) {
                            existingTextNode.nodeValue = newText;
                        } else if (svgIcon) {
                           deleteAllBtn.insertBefore(document.createTextNode(newText), svgIcon.nextSibling);
                        } else {
                           deleteAllBtn.appendChild(document.createTextNode(newText));
                        }
                    }
                }
            });
            button.dataset.modeTabListener = 'true';
        }
    });
}

function handleResize(){
    const oldGameWidth = gameWidth;
    const oldGameHeight = gameHeight;

    const dprMultiplier = QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1);

    const maxContainerWidth = window.innerWidth;
    const maxContainerHeight = window.innerHeight;

    let targetDisplayWidth = maxContainerWidth * 0.9;
    let targetDisplayHeight = maxContainerHeight * 0.8;

    let newCanvasWidthBasedOnHeight = targetDisplayHeight * (16 / 9);
    let newCanvasHeightBasedOnWidth = targetDisplayWidth * (9 / 16);

    let finalDisplayWidth;
    let finalDisplayHeight;

    if (newCanvasHeightBasedOnWidth <= targetDisplayHeight) {
        finalDisplayWidth = targetDisplayWidth;
        finalDisplayHeight = newCanvasHeightBasedOnWidth;
    } else {
        finalDisplayHeight = targetDisplayHeight;
        finalDisplayWidth = newCanvasWidthBasedOnHeight;
    }

    finalDisplayWidth = Math.min(finalDisplayWidth, window.innerWidth * 0.9);
    finalDisplayHeight = Math.min(finalDisplayHeight, window.innerHeight * 0.8);

    const aspectRatio = finalDisplayWidth / finalDisplayHeight;
    const targetAspectRatio = 16 / 9;
    const tolerance = 0.01;

    if (aspectRatio > targetAspectRatio + tolerance) {
        finalDisplayWidth = finalDisplayHeight * targetAspectRatio;
    } else if (aspectRatio < targetAspectRatio - tolerance) {
        finalDisplayHeight = finalDisplayWidth / targetAspectRatio;
    }

    if (canvasArea) {
        canvasArea.style.width = finalDisplayWidth + 'px';
        canvasArea.style.height = finalDisplayHeight + 'px';
    }

    if (gameCanvas && gameCtx) {
        gameCanvas.width = finalDisplayWidth * dprMultiplier;
        gameCanvas.height = finalDisplayHeight * dprMultiplier;
        gameCanvas.style.width = finalDisplayWidth + 'px';
        gameCanvas.style.height = finalDisplayHeight + 'px';
        gameCtx.setTransform(dprMultiplier, 0, 0, dprMultiplier, 0, 0);
    }

    if (aCvs && aCtx) {
        aCvs.width = finalDisplayWidth * dprMultiplier;
        aCvs.height = finalDisplayHeight * dprMultiplier;
        aCvs.style.width = finalDisplayWidth + 'px';
        aCvs.style.height = finalDisplayHeight + 'px';
        aCtx.setTransform(dprMultiplier, 0, 0, dprMultiplier, 0, 0);
    }

    gameWidth = finalDisplayWidth;
    gameHeight = finalDisplayHeight;

    _PCOR = gameWidth * 0.05;
    _PCRT = _PCOR * 0.35;
    BALL_RADIUS_BASE = (_PCOR - _PCRT) / 3.5;
    DROPPER_WIDTH_BOTTOM = BALL_RADIUS_BASE * _MAXBSM * 2;

    const wasActive = gameRunning || (rVState.activeReplay && (rVState.isPlaying || rVState.isSeeking));
    const wasReplayActive = rVState.activeReplay !== null;
    const wasReplayPlaying = rVState.isPlaying;
    const wasReplaySeeking = rVState.isSeeking;
    const currentReplayTimeBeforeStateReset = rVState.currentTimeMs;


    if (wasActive && !wasReplayActive) {
        fnUpdateStaticEntityGeometryOnResize(oldGameWidth, oldGameHeight, gameWidth, gameHeight);
    }

    fnITP();
    fnIAP();

    if (aCtx) aCtx.clearRect(0, 0, gameWidth, gameHeight);
    fnDTP(aCtx);

    if (wasReplayActive) {
        isResizingDuringReplay = true; 
        fnAREUTT(currentReplayTimeBeforeStateReset, true);
        isResizingDuringReplay = false; 

        if(replaySeekBar && rVState.totalDurationMs > 0) {
            replaySeekBar.value = (rVState.currentTimeMs / rVState.totalDurationMs) * parseFloat(replaySeekBar.max);
        }
        fnURUI();

        if (!wasReplayPlaying || wasReplaySeeking) {
            redrawStaticFrame();
        }
        if (wasReplayPlaying && !wasReplaySeeking) {
            lastTime = performance.now();
        }

    } else if (wasActive && gamePaused) {
        redrawStaticFrame();
    } else if (!wasActive && (gameCtx || aCtx)) {
        if (gameCtx) gameCtx.clearRect(0, 0, gameWidth, gameHeight);
        if (aCtx) {
            aCtx.clearRect(0, 0, gameWidth, gameHeight);
            fnDTP(aCtx);
        }
        if (gameOverScreen && gameOverScreen.style.display === 'flex') {
            fnUpdateStaticEntityGeometryOnResize(oldGameWidth, oldGameHeight, gameWidth, gameHeight);
            redrawStaticFrame();
        }
    }
}

function fnShowReplayLimitNotification(message) {
    const notificationElement = document.getElementById('replayLimitNotification');
    if (notificationElement) {
        notificationElement.textContent = message;
        notificationElement.style.display = 'block';
        fnPS('loseLife'); 
        setTimeout(() => {
            notificationElement.style.display = 'none';
        }, 3000); 
    }
}

function updateButtonText(buttonElement, newText) {
    const textSpan = buttonElement.querySelector('.btn-text');
    if (textSpan) {
        textSpan.textContent = newText;
    } else {
        
        
        let firstChild = buttonElement.firstChild;
        let textNode = null;
        if (firstChild && firstChild.nodeName.toLowerCase() === 'svg') {
            textNode = firstChild.nextSibling;
        } else {
            textNode = firstChild;
        }

        if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            textNode.nodeValue = " " + newText; 
        } else {
            
            const newTextNode = document.createTextNode(" " + newText);
            if (firstChild && firstChild.nodeName.toLowerCase() === 'svg') {
                buttonElement.insertBefore(newTextNode, firstChild.nextSibling);
            } else {
                buttonElement.appendChild(newTextNode);
            }
        }
    }
}

function redrawStaticFrame() {
    if (!gameCtx) return;

    // The fnAREUTT function (when fullReset=true for a seek) is now responsible
    // for simulating and populating colorWheelParticles up to the target time.
    // So, a separate burst here is no longer needed and might be incorrect.

    gameCtx.clearRect(0,0,gameWidth,gameHeight);
    fnDAP(gameCtx);

    if (bucket) fnDBkt(gameCtx,bucket);
    fnDCWP(gameCtx); // Draw Color Wheel Particles (these should be correctly populated by fnAREUTT)
    if (playerCursor) fnDPC(gameCtx);
    fnDB(gameCtx);
    if (dropper1) fnDSD(gameCtx,dropper1);
    if (dropper2) fnDSD(gameCtx,dropper2);

    const currentDisplayMode = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    if(currentDisplayMode === 'classic'){fnDPGP(gameCtx);}

    fnUUI(); // Update UI elements (score, time, lives)

    // The justSeeked flag is now primarily managed in fnRGL and the seekbar event handlers.
    // If a redrawStaticFrame is called directly after a seek (e.g., by seekbar 'input'),
    // and playback doesn't immediately resume, the justSeeked flag will be reset
    // by fnRGL when it determines it's not playing.
}


function fnHVC() {
    if (document.hidden) {
        if (gameModeActive && gameRunning && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) {
            fnPG();
        }
        if (rVState.activeReplay && rVState.isPlaying) {
            rVState.isPlaying = false;
            fnSetReplayButtonIcon(false);
            if (rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = null;
        }
    }
}
function fnHFC(event) {
    if (event.type === 'blur') {
        if (gameModeActive && gameRunning && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) {
            fnPG();
        }
        if (rVState.activeReplay && rVState.isPlaying) {
            rVState.isPlaying = false;
            fnSetReplayButtonIcon(false);
            if (rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = null;
        }
    }
}
function fnTP(){ if(!gameModeActive || !gameRunning)return; if(quitConfirmationDialog&&quitConfirmationDialog.style.display!=='none')return; if(gamePaused){fnRG();}else{fnPG();}}
function fnPG(){ if(!gameModeActive || !gameRunning||gamePaused)return; gamePaused=true;gPausedByConf=false; timePausedStarted=performance.now(); if(animationFrameId)cancelAnimationFrame(animationFrameId); if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null; if(pauseOverlay)pauseOverlay.style.display='flex'; if(gameCanvas)gameCanvas.style.cursor='default'; fnPS('click');}
function fnRG(){ if(!gameModeActive || !gameRunning||!gamePaused)return; if(quitConfirmationDialog&&quitConfirmationDialog.style.display!=='none'){return;} gamePaused=false;gPausedByConf=false; const tWP=performance.now()-timePausedStarted; lastTime+=tWP; if(pauseOverlay)pauseOverlay.style.display='none'; animationFrameId=requestAnimationFrame(fnGL); if(!mRecIntId && gameRunning && !rVState.activeReplay) mRecIntId = setInterval(fnRMP, _RMRIM); if(gameCanvas)gameCanvas.style.cursor='none'; fnPS('click');}
function fnSQC(){ 
    if (rVState.activeReplay) { 
        fnStopRP();
        fnSS('home');
        fnPS('click');
        return;
    }
    if(quitConfirmationDialog){ 
        if(gameModeActive && gameRunning){ 
            if(!gamePaused){ 
                gPausedBefConf=false; gPausedByConf=true; gamePaused=true; 
                timePausedStarted=performance.now(); 
                if(animationFrameId)cancelAnimationFrame(animationFrameId); 
                if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null; 
                if(gameCanvas)gameCanvas.style.cursor='default'; 
            } else {
                gPausedBefConf=true; gPausedByConf=false;
            } 
        } 
        quitConfirmationDialog.style.display='flex';
        fnPS('click');
    }
}
function fnHQC(){ if(quitConfirmationDialog){ quitConfirmationDialog.style.display='none'; if(gameModeActive && gameRunning && gPausedByConf){ gamePaused=false; const tWP=performance.now()-timePausedStarted; lastTime+=tWP; animationFrameId=requestAnimationFrame(fnGL); if(!mRecIntId && !rVState.activeReplay) mRecIntId = setInterval(fnRMP, _RMRIM); if(gameCanvas)gameCanvas.style.cursor='none'; } gPausedByConf=false;fnPS('click');}}
function initAudio(){if(!audioCtx){try{audioCtx=new (window.AudioContext||window.webkitAudioContext)();}catch(e){console.error("Web Audio API not supported",e);return false;}}return true;}





function fnPSI(soundType){
    if(!audioCtx||audioCtx.state!=='running'){return;}
    if(masterVolume===0)return;

    if (rVState.isSeeking && soundType !== 'click') {
        return;
    }

    let canPlaySound = (rVState.activeReplay && (rVState.isPlaying || rVState.isSeeking)) ||
                         (gameModeActive && (!gamePaused || gPausedByConf));

    if (rVState.activeReplay && !rVState.isPlaying && !rVState.isSeeking &&
        rVState.currentTimeMs >= rVState.totalDurationMs && soundType === 'loseLife') {
        canPlaySound = true;
    }

    if(!canPlaySound && soundType !== 'click' && soundType !=='powerupCollect' && soundType !== 'collectGoodDouble' && soundType !== 'loseLife') return;
    if(!canPlaySound && soundType === 'loseLife' && !(rVState.activeReplay && rVState.currentTimeMs >= rVState.totalDurationMs)) return;
    
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    
    
    
    o.connect(g);g.connect(audioCtx.destination);
    const n=audioCtx.currentTime;let d=0.1,b=0.1;
    switch(soundType){
        
         case 'click':o.type='triangle';o.frequency.setValueAtTime(1000,n);b=0.1;d=0.1;break; case 'drop':o.type='sine';o.frequency.setValueAtTime(200,n);b=0.15;d=0.2;break; case 'collectGood':o.type='sine';o.frequency.setValueAtTime(660,n);b=0.2;d=0.15;break; case 'collectGoodDouble':o.type='sine';o.frequency.setValueAtTime(880,n);o.frequency.exponentialRampToValueAtTime(990,n+0.05);b=0.22;d=0.18;break; case 'collectBucket':
    o.type = 'square';
    o.frequency.setValueAtTime(150, n);
    b = 0.14;
    d = 0.11;
    break; case 'loseLife':o.type='sawtooth';o.frequency.setValueAtTime(150,n);o.frequency.exponentialRampToValueAtTime(80,n+0.3);b=0.25;d=0.3;break; case 'powerupCollect':o.type='triangle';o.frequency.setValueAtTime(880,n);o.frequency.exponentialRampToValueAtTime(1320,n+0.1);b=0.25;d=0.3;break; default:o.disconnect();g.disconnect();return;} const a=b*masterVolume;g.gain.setValueAtTime(a,n); g.gain.exponentialRampToValueAtTime(0.0001,n+d);o.start(n);o.stop(n+d);
}
function fnPS(type){
    if (isResizingDuringReplay && type !== 'click') { // Allow UI clicks, but mute game sounds
        return;
    }

    if(!initAudio()){return;}

    if (type === 'click') {
        const now = performance.now();
        if (now - lastClickSoundTime < CLICK_SOUND_COOLDOWN_MS) {
            return;
        }
        lastClickSoundTime = now;
    }

    if(audioCtx.state==='suspended'){
        audioCtx.resume().then(()=>{fnPSI(type);});
    } else if(audioCtx.state==='running'){
        fnPSI(type);
    }
}

function fnSS(screenName){
    const dialogs = [pauseOverlay, quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem];
    dialogs.forEach(d => { if(d) d.style.display = 'none';});

    let isNavigatingAwayFromGameOrReplay = (screenName !== 'game' && screenName !== 'gameOver' && screenName !== 'replayViewer');

    if (rVState.activeReplay && isNavigatingAwayFromGameOrReplay) {
         if (screens.game.classList.contains('active')) { // Check if game screen is active (where replay viewer runs)
            fnStopRP();
         }
    }
    gameModeActive = (screenName === 'game' && !rVState.activeReplay && screenName !== 'replayViewer');

    // --- Screen Stack Management ---
    const isGameScreenRelated = ['game', 'gameOver', 'replayViewer'].includes(screenName);

    if (!isGameScreenRelated) { // Only manage stack for non-gameplay/viewer screens directly
        if (NAVIGABLE_MENU_SCREENS.includes(screenName)) {
            if (screenName === 'home') {
                screenStack = ['home'];
            } else {
                // If navigating to a menu screen, and it's not already at the top, push it.
                if (screenStack[screenStack.length - 1] !== screenName) {
                    screenStack.push(screenName);
                    if (screenStack.length > MAX_HISTORY_LENGTH) {
                        screenStack.shift();
                    }
                }
            }
        }
    } else if (screenName === 'replayViewer') {
        // When going TO replayViewer, ensure the screen WE CAME FROM (e.g., 'replays' or 'highScores')
        // is at the top of the stack if it's a navigable menu screen.
        // If the stack is empty or the top isn't a menu screen, don't push replayViewer itself.
        // The 'pop' logic in fnCDR will then reveal the previous menu screen.
        // This implicitly treats replayViewer as a temporary overlay on the last menu screen.
        // No direct push of 'replayViewer' onto the main navigable stack.
    }


    Object.values(screens).forEach(s=>{if(s?.classList.contains('screen'))s.classList.remove('active');});

    let isReplayViewing = (screenName === 'replayViewer');
    if(screenName==='gameOver'){
        screens.game.classList.add('active');
        replayControlsContainerElem.style.display = 'none';
        uiOverlayElem.classList.remove('replay-mode');
        powerupIconsContainerElem.classList.remove('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display='flex';
    } else if (isReplayViewing) {
        screens.game.classList.add('active'); // Replay viewer uses the 'game' screen's canvas
        replayControlsContainerElem.style.display = 'flex';
        uiOverlayElem.classList.add('replay-mode');
        powerupIconsContainerElem.classList.add('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display = 'none';
    } else if(screens[screenName]){
        screens[screenName].classList.add('active');
        replayControlsContainerElem.style.display = 'none';
        uiOverlayElem.classList.remove('replay-mode');
        powerupIconsContainerElem.classList.remove('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display = 'none';
    }

    let cursorStyle = 'default';
    if (screenName === 'game' && gameModeActive && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) { cursorStyle = 'none'; }
    else if (isReplayViewing) { cursorStyle = 'default'; } // Cursor should be default when viewing replays
    if(gameCanvas) gameCanvas.style.cursor = cursorStyle;
}

function fnSMSD(){fnPS('click');if(modeSelectionDialogElem){if(!screens.home.classList.contains('active')){fnSS('home');} modeSelectionDialogElem.style.display='flex';}}
function fnHMSD(){fnPS('click');if(modeSelectionDialogElem){modeSelectionDialogElem.style.display='none';}}

function fnSGM(mode, event){ 
    currentGameMode=mode;
    fnHMSD();
    fnSG(event); // Pass the event to fnSG
}

function fnSEL(){
     if(!document.getElementById('startGameBtn')){console.error("DOM not ready");return;}
     qualitySelectElement = document.getElementById('qualitySelect');

     document.getElementById('startGameBtn').addEventListener('click',fnSMSD);
     document.getElementById('settingsBtn').addEventListener('click',()=>{ fnPS('click'); fnSS('settings'); });
     document.getElementById('highScoresBtn').addEventListener('click',()=>{ fnPS('click'); fnDHS(); fnSS('highScores'); });
     document.getElementById('howToPlayBtn').addEventListener('click',()=>{ fnPS('click'); fnSS('howToPlay'); });
     document.getElementById('replaysBtn').addEventListener('click', () => { fnPS('click'); fnDRpsL(); fnSS('replays'); });
     document.getElementById('appearanceBtn').addEventListener('click', () => { fnPS('click'); fnSS('appearance'); });

     document.getElementById('classicModeBtn').addEventListener('click',(e)=>{ fnPS('click'); fnSGM('classic', e); });
     document.getElementById('hardcoreModeBtn').addEventListener('click',(e)=>{ fnPS('click'); fnSGM('hardcore', e); });
     document.getElementById('cancelModeSelectionBtn').addEventListener('click',fnHMSD);

     volumeSlider.addEventListener('input',(e)=>{masterVolume=parseInt(e.target.value)/100;volumeValueDisplay.textContent=e.target.value;});
     volumeSlider.addEventListener('mouseup',()=>{fnSVS();fnPS('click');});
     sensitivitySlider.addEventListener('input',(e)=>{
         let rawValue = parseInt(e.target.value);
         _BS = Math.max(1, Math.min(10, rawValue));
         e.target.value = _BS;
         sensitivityValueDisplay.textContent=_BS;
         fnUBS();
     });
     sensitivitySlider.addEventListener('mouseup',()=>{fnSVS();fnPS('click');});

     if (qualitySelectElement) {
         qualitySelectElement.addEventListener('mousedown', () => {
             fnPS('click');
         });
         qualitySelectElement.addEventListener('change', (e) => {
             currentQualitySetting = e.target.value;
             fnSVS();
             fnPS('click');
             handleResize();
             if (gamePaused || (rVState.activeReplay && !rVState.isPlaying)) {
                 redrawStaticFrame();
             }
         });
     }

     if (autosaveReplaysSelect) {
         const autosaveThresholdElements = document.getElementById('autosaveThresholdElements');
         autosaveReplaysSelect.addEventListener('mousedown', () => fnPS('click'));
         autosaveReplaysSelect.addEventListener('change', (e) => {
             autosaveReplays = e.target.value;
             if (autosaveThresholdElements) {
                 autosaveThresholdElements.style.display = (autosaveReplays === 'yes') ? 'flex' : 'none';
             }
             fnSVS();
             fnPS('click');
         });
     }

     if (autosaveThresholdBtn) {
         autosaveThresholdBtn.addEventListener('click', () => {
             fnPS('click');
             if (autosaveThresholdBtn.dataset.editing === "true") {
                 return;
             }

             autosaveThresholdBtn.dataset.editing = "true";
             const currentValue = autosaveThresholdBtn.textContent;
             autosaveThresholdBtn.style.display = 'none';

             const editableArea = document.createElement('div');
             editableArea.classList.add('threshold-editable-area');
             editableArea.contentEditable = "true";
             editableArea.textContent = currentValue;

             autosaveThresholdBtn.parentNode.insertBefore(editableArea, autosaveThresholdBtn);
             editableArea.focus();

             const range = document.createRange();
             range.selectNodeContents(editableArea);
             const sel = window.getSelection();
             sel.removeAllRanges();
             sel.addRange(range);

             function saveAndExitEditingThreshold() {
                 if (autosaveThresholdBtn.dataset.editing !== "true") return;

                 const newValueStr = editableArea.textContent.trim();
                 let newValueInt = parseInt(newValueStr);

                 if (!isNaN(newValueInt) && newValueInt >= 0 && newValueInt <= 99999) {
                     autosaveThreshold = newValueInt;
                     autosaveThresholdBtn.textContent = autosaveThreshold;
                     fnSVS();
                 } else {
                     autosaveThresholdBtn.textContent = autosaveThreshold;
                 }

                 editableArea.parentNode.removeChild(editableArea);
                 autosaveThresholdBtn.style.display = 'inline-flex';
                 autosaveThresholdBtn.dataset.editing = "false";
             }

             editableArea.addEventListener('blur', () => {
                 setTimeout(saveAndExitEditingThreshold, 50);
             });

             editableArea.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') {
                     e.preventDefault();
                     saveAndExitEditingThreshold();
                 } else if (e.key === 'Escape') {
                     e.preventDefault();
                     autosaveThresholdBtn.textContent = autosaveThreshold; // Reset to original on escape
                     saveAndExitEditingThreshold();
                 } else if (!/^[0-9]$/.test(e.key) && e.key.length === 1 &&
                            !['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'].includes(e.key) &&
                            !(e.ctrlKey || e.metaKey)) {
                     e.preventDefault();
                 }
             });
         });
     }

     keybindLeftBtn.addEventListener('click',()=>fnSLFK('left'));
     keybindRightBtn.addEventListener('click',()=>fnSLFK('right'));
     keybindMaxSpeedBtn.addEventListener('click',()=>fnSLFK('maxSpeed'));
     keybindPauseBtn.addEventListener('click',()=>fnSLFK('pause'));

     document.getElementById('settingsToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
     document.getElementById('highScoresToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
     document.getElementById('howToPlayToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); }); // <<< ADDED THIS LINE
     document.getElementById('appearanceToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
     document.getElementById('replaysToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
     document.getElementById('importReplaysBtn').addEventListener('click', fnShowImportDialog);

     document.getElementById('playAgainBtn').addEventListener('click',()=>{
         fnPS('click');
         if (saveReplayBtnElem) {
             updateButtonText(saveReplayBtnElem, "Save Replay");
             saveReplayBtnElem.classList.remove('saved');
             saveReplayBtnElem.classList.remove('limit-reached');
             saveReplayBtnElem.classList.remove('watch-mode');
         }
         lastSavedReplayIdToWatch = null;
         fnSG();
     });

     if(gameOverQuitBtn)gameOverQuitBtn.addEventListener('click',()=>{
         fnPS('click');
         if (saveReplayBtnElem) {
             updateButtonText(saveReplayBtnElem, "Save Replay");
             saveReplayBtnElem.classList.remove('saved');
             saveReplayBtnElem.classList.remove('limit-reached');
             saveReplayBtnElem.classList.remove('watch-mode');
         }
         lastSavedReplayIdToWatch = null;
         fnSS('home');
     });

     if(saveReplayBtnElem) {
         saveReplayBtnElem.addEventListener('click', ()=>{
             fnPS('click');

             const btnTextSpan = saveReplayBtnElem.querySelector('.btn-text');
             const currentButtonText = btnTextSpan ? btnTextSpan.textContent : saveReplayBtnElem.textContent;

             if (currentButtonText.includes("Watch Replay")) {
                 if (lastSavedReplayIdToWatch) {
                     const replayToWatch = sReps.find(r => r.i === lastSavedReplayIdToWatch);
                     if (replayToWatch) {
                         fnSRP(replayToWatch);
                     } else {
                         updateButtonText(saveReplayBtnElem, "Save Replay");
                         saveReplayBtnElem.classList.remove('saved');
                         saveReplayBtnElem.classList.remove('limit-reached');
                         saveReplayBtnElem.classList.remove('watch-mode');
                         lastSavedReplayIdToWatch = null;
                     }
                 }
             } else if (!saveReplayBtnElem.classList.contains('saved') && !currentButtonText.includes("Limit Reached")) {
                 fnSCR();
             }
         });
     }

     if(gameScreenHomeBtn){gameScreenHomeBtn.addEventListener('click',()=>{
         if(rVState.activeReplay) { fnPS('click'); fnSQC(); }
         else if(gameModeActive && gameRunning){ fnPS('click'); fnSQC(); }
         else{ fnPS('click'); fnSS('home');}
     });}

     if (gameScreenDeleteReplayBtnInOverlay) {
         gameScreenDeleteReplayBtnInOverlay.addEventListener('click', () => {
             fnPS('click');
             if (rVState.activeReplay) {
                 if (rVState.isPlaying) {
                     rVState.isPlaying = false;
                     fnSetReplayButtonIcon(false);
                     if (rAnimId) cancelAnimationFrame(rAnimId);
                     rAnimId = null;
                 }
                 fnSDRC(rVState.activeReplay.id, rVState.activeReplay.timestamp, rVState.activeReplay.gameMode);
             }
         });
     }

     if(confirmQuitBtn)confirmQuitBtn.addEventListener('click',()=>{
         fnPS('click');
         if(gameModeActive && gameRunning){gameRunning=false;gamePaused=false;if(animationFrameId)cancelAnimationFrame(animationFrameId); if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;}
         else if (rVState.activeReplay) { fnStopRP(); }
         lastSavedReplayIdToWatch = null;
         fnSS('home');gPausedByConf=false;
     });
     if(cancelQuitBtn)cancelQuitBtn.addEventListener('click',fnHQC);

     confirmDeleteReplayBtn.addEventListener('click', ()=>{
         fnPS('click');
         const replayIdToDelete = rDelData ? rDelData.id : null;
         fnCDR(); 
         if (rVState.activeReplay && rVState.activeReplay.id === replayIdToDelete) {
             fnStopRP(); 
             if (screenStack.length > 1) {
                 screenStack.pop(); 
                 const targetScreen = screenStack.length > 0 ? screenStack[screenStack.length - 1] : 'home';
                 fnSS(targetScreen);
             } else {
                 fnSS('home');
             }
         }
     });
     cancelDeleteReplayBtn.addEventListener('click', ()=>{
        fnHDRC();
        if (rVState.activeReplay && rVState.wasPlayingBeforeSeek && deleteReplayConfirmationDialog.style.display === 'none') {
            rVState.isPlaying = true;
            fnSetReplayButtonIcon(true);
            lastTime = performance.now();
            if(rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = requestAnimationFrame(fnRGL);
        }
     });


     document.getElementById('deleteAllReplaysBtn').addEventListener('click', ()=>{fnPS('click'); fnShowDeleteAllConf();});
     confirmDeleteAllReplaysBtn.addEventListener('click', ()=>{fnPS('click'); fnCDAR();});
     cancelDeleteAllReplaysBtn.addEventListener('click', fnHDARC);

     copyExportReplayBtn.addEventListener('click', fnCopyExportedReplay);
     closeExportReplayBtn.addEventListener('click', () => { fnPS('click'); exportReplayDialog.style.display = 'none'; });
     importReplayAndPlayBtn.addEventListener('click', fnImportAndPlayReplay);
     cancelImportReplayBtn.addEventListener('click', () => { fnPS('click'); importReplayDialog.style.display = 'none';});

     replayPlayPauseBtn.addEventListener('click', () => {
         if (!rVState.activeReplay) return;
         fnPS('click');
         if (!rVState.isPlaying && rVState.currentTimeMs >= rVState.totalDurationMs && rVState.totalDurationMs > 0) {
             rVState.currentTimeMs = 0;
             fnAREUTT(0, true);
             rVState.isPlaying = true;
             fnSetReplayButtonIcon(true);
             lastTime = performance.now();
             if(rAnimId) cancelAnimationFrame(rAnimId);
             rAnimId = requestAnimationFrame(fnRGL);
         } else {
             rVState.isPlaying = !rVState.isPlaying;
             fnSetReplayButtonIcon(rVState.isPlaying);
             if (rVState.isPlaying) {
                 if(!rAnimId) lastTime = performance.now();
                 if (rVState.isSeeking) {
                     const seekTimeMs = (parseFloat(replaySeekBar.value) / parseFloat(replaySeekBar.max)) * rVState.totalDurationMs;
                     rVState.currentTimeMs = seekTimeMs;
                 }
                 rVState.isSeeking = false;
                 if(rAnimId) cancelAnimationFrame(rAnimId);
                 rAnimId = requestAnimationFrame(fnRGL);
             } else {
                 if(rAnimId) cancelAnimationFrame(rAnimId);
                 rAnimId = null;
             }
         }
     });

     replaySeekBar.addEventListener('input', () => {
         if (!rVState.activeReplay || !replaySeekBar) return;

         if (!rVState.isSeeking) {
             rVState.wasPlayingBeforeSeek = rVState.isPlaying;
         }
         rVState.isSeeking = true;
         rVState.justSeeked = true;

         if (rVState.isPlaying) {
             rVState.isPlaying = false;
             fnSetReplayButtonIcon(false);
             if(rAnimId) cancelAnimationFrame(rAnimId);
             rAnimId = null;
         }

         let seekTimeMs = 0;
         if (rVState.totalDurationMs > 0 && replaySeekBar.max > 0) {
              seekTimeMs = (parseFloat(replaySeekBar.value) / parseFloat(replaySeekBar.max)) * rVState.totalDurationMs;
         }
         rVState.currentTimeMs = seekTimeMs;

         fnAREUTT(seekTimeMs, true);
         fnIMFR();
         redrawStaticFrame();
         fnURUI();
     });
      replaySeekBar.addEventListener('change', () => {
         if (!rVState.activeReplay) return;
         if (!rVState.isSeeking) return; // Only proceed if actively seeking

         fnPS('click');

         if (rVState.wasPlayingBeforeSeek) {
             rVState.isSeeking = false; // No longer seeking
             rVState.isPlaying = true;
             fnSetReplayButtonIcon(true);
             lastTime = performance.now();
             if(rAnimId) cancelAnimationFrame(rAnimId);
             rAnimId = requestAnimationFrame(fnRGL);
         } else {
             rVState.isSeeking = false; // No longer seeking
         }
     });

     if(pauseOverlay)pauseOverlay.addEventListener('click',fnRG);
     window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); if (lstnKey) { fnSK(key); return; } const isReplayActive = rVState.activeReplay !== null && screens.game.classList.contains('active') && replayControlsContainerElem.style.display === 'flex'; const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) { if (key === 'escape') { fnPS('click'); if(quitConfirmationDialog?.style.display !== 'none') fnHQC(); else if(deleteReplayConfirmationDialog?.style.display !== 'none') fnHDRC(); else if(deleteAllReplaysConfirmationDialog?.style.display !== 'none') fnHDARC(); else if(exportReplayDialog?.style.display !== 'none') exportReplayDialog.style.display = 'none'; else if(importReplayDialog?.style.display !== 'none') importReplayDialog.style.display = 'none'; else if(modeSelectionDialogElem?.style.display !== 'none') fnHMSD(); } return; } if (key === 'escape') { fnPS('click'); let currentActiveScreen = ''; for (const sn_iterator in screens) { if (screens[sn_iterator]?.classList.contains('active')) { currentActiveScreen = sn_iterator; break;}} if (isReplayActive) { fnStopRP(); const lastNavigableScreen = screenStack.length > 0 ? screenStack[screenStack.length - 1] : 'home'; fnSS(lastNavigableScreen); } else if (gameModeActive && gameRunning) { fnSQC(); } else if (currentActiveScreen === 'home') { return; } else { if (screenStack.length > 1) { screenStack.pop(); const targetScreen = screenStack[screenStack.length - 1]; fnSS(targetScreen); } else { fnSS('home'); }} return; } if (gameModeActive && gameRunning) { if (key === keybindPause) { fnTP(); } else if (!gamePaused) { if (!keysPressed[key] && cRepData) { cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'keydown', key: key });} keysPressed[key] = true; }} else if (isReplayActive) { if (key === ' ') { e.preventDefault(); replayPlayPauseBtn.click(); } } });
     window.addEventListener('keyup',(e)=>{ const key=e.key.toLowerCase(); if(lstnKey)return; const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return; if(gameModeActive && gameRunning && !gamePaused){ if(keysPressed[key] && cRepData){ cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'keyup', key: key });} keysPressed[key]=false; } });
     document.addEventListener('mousemove',(e)=>{
         if(gameModeActive && gameRunning && !gamePaused && playerCursor){
             const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return;
             const rect=gameCanvas.getBoundingClientRect();
             playerCursor.x=e.clientX-rect.left;
             playerCursor.y=e.clientY-rect.top;
         }
     });
 setupModeTabs('#highScoresScreen .mode-tabs-container');
     setupModeTabs('#replaysScreen .mode-tabs-container');
}

function fnRMP() { 
    if (gameModeActive && gameRunning && !gamePaused && playerCursor && cRepData) { 
        cRepData.events.push({ 
            t: parseFloat(elapsedGameTimeMs.toFixed(1)), 
            type: 'mouse', 
            x: parseFloat(playerCursor.x.toFixed(1)), 
            y: parseFloat(playerCursor.y.toFixed(1)) 
        }); 
    } 
}

function fnLS() {
    const sv = localStorage.getItem('masterVolume');
    if (sv !== null) masterVolume = parseFloat(sv);
    if (volumeSlider) volumeSlider.value = masterVolume * 100;
    if (volumeValueDisplay) volumeValueDisplay.textContent = Math.round(masterVolume * 100);

    const ss = localStorage.getItem('bucketSensitivity');
    let loadedSensitivity = 5;
    if (ss) {
        const parsedSs = parseInt(ss);
        if (!isNaN(parsedSs)) {
            loadedSensitivity = Math.max(1, Math.min(10, parsedSs));
        }
    }
    _BS = loadedSensitivity;
    if (sensitivitySlider) sensitivitySlider.value = _BS;
    if (sensitivityValueDisplay) sensitivityValueDisplay.textContent = _BS;

    const skl_val = localStorage.getItem('keybindLeft');
    if (skl_val) keybindLeft = skl_val;
    else keybindLeft = 'a';
    if (typeof keybindLeft !== 'string') keybindLeft = 'a';
    if (keybindLeftBtn) keybindLeftBtn.textContent = keybindLeft.toUpperCase();

    const skr_val = localStorage.getItem('keybindRight');
    if (skr_val) keybindRight = skr_val;
    else keybindRight = 'd';
    if (typeof keybindRight !== 'string') keybindRight = 'd';
    if (keybindRightBtn) keybindRightBtn.textContent = keybindRight.toUpperCase();

    const skms_val = localStorage.getItem('keybindMaxSpeed');
    if (skms_val) keybindMaxSpeed = skms_val;
    else keybindMaxSpeed = 'w';
    if (typeof keybindMaxSpeed !== 'string') keybindMaxSpeed = 'w';
    if (keybindMaxSpeedBtn) keybindMaxSpeedBtn.textContent = keybindMaxSpeed.toUpperCase();

    const skp_val = localStorage.getItem('keybindPause');
    if (skp_val) keybindPause = skp_val;
    else keybindPause = 'p';
    if (typeof keybindPause !== 'string') keybindPause = 'p';
    if (keybindPauseBtn) keybindPauseBtn.textContent = keybindPause.toUpperCase();

    const savedQuality = localStorage.getItem('graphicsQuality');
    if (savedQuality && QUALITY_SETTINGS_MAP[savedQuality]) {
        currentQualitySetting = savedQuality;
    } else {
        currentQualitySetting = 'high';
    }
    if (qualitySelectElement) {
        qualitySelectElement.value = currentQualitySetting;
    }

    const ar_val = localStorage.getItem('autosaveReplays');
    if (ar_val === 'yes' || ar_val === 'no') autosaveReplays = ar_val;
    else autosaveReplays = 'no';
    if (autosaveReplaysSelect) autosaveReplaysSelect.value = autosaveReplays;

    const at_val = localStorage.getItem('autosaveThreshold');
    if (at_val !== null && !isNaN(parseInt(at_val))) autosaveThreshold = parseInt(at_val);
    else autosaveThreshold = 100;
    if (autosaveThresholdBtn) autosaveThresholdBtn.textContent = autosaveThreshold;

    const autosaveThresholdElements = document.getElementById('autosaveThresholdElements');
    if (autosaveThresholdElements) {
        autosaveThresholdElements.style.display = (autosaveReplays === 'yes') ? 'flex' : 'none';
    }

    const savedCosmetics = localStorage.getItem('currentEquippedCosmetics');
    if (savedCosmetics) {
        try {
            const parsedCosmetics = JSON.parse(savedCosmetics);
            Object.keys(R_COSMETIC_DEFAULTS).forEach(key => {
                if (parsedCosmetics.hasOwnProperty(key)) {
                    currentEquippedCosmetics[key] = parsedCosmetics[key];
                } else {
                    currentEquippedCosmetics[key] = R_COSMETIC_DEFAULTS[key];
                }
            });
            Object.keys(R_SFX_DEFAULTS).forEach(key => {
                if (parsedCosmetics.hasOwnProperty(key)) {
                    currentEquippedCosmetics[key] = parsedCosmetics[key];
                } else {
                    currentEquippedCosmetics[key] = R_SFX_DEFAULTS[key];
                }
            });
        } catch (e) {
            console.error("Error parsing saved cosmetics from localStorage", e);
            currentEquippedCosmetics = { ...R_COSMETIC_DEFAULTS, ...R_SFX_DEFAULTS };
        }
    } else {
        currentEquippedCosmetics = { ...R_COSMETIC_DEFAULTS, ...R_SFX_DEFAULTS };
    }
}

function fnSCS() { // Save Current (Equipped) Cosmetics
    localStorage.setItem('currentEquippedCosmetics', JSON.stringify(currentEquippedCosmetics));
}

function fnSVS(){
    localStorage.setItem('masterVolume',masterVolume);
    localStorage.setItem('graphicsQuality', currentQualitySetting);
    localStorage.setItem('bucketSensitivity',_BS);
    localStorage.setItem('keybindLeft',keybindLeft);
    localStorage.setItem('keybindRight',keybindRight);
    localStorage.setItem('keybindMaxSpeed',keybindMaxSpeed);
    localStorage.setItem('keybindPause',keybindPause);
    localStorage.setItem('autosaveReplays', autosaveReplays);
    localStorage.setItem('autosaveThreshold', autosaveThreshold);
    fnSCS(); // Save cosmetic choices along with other settings
}

function createCosmeticItemElement(itemName, isEquipped, isOwnedTab, cosmeticTypeKey, cosmeticValue) {
    const itemDiv = document.createElement('div');
    itemDiv.classList.add('cosmetic-item');

    const nameSpan = document.createElement('span');
    nameSpan.textContent = itemName;
    itemDiv.appendChild(nameSpan);

    const equipButton = document.createElement('button');
    equipButton.classList.add('cosmetic-equip-btn');

    if (isEquipped) {
        equipButton.textContent = 'Equipped';
        equipButton.classList.add('equipped');
        equipButton.disabled = true; // Cannot unequip by clicking "Equipped"
    } else {
        equipButton.textContent = 'Equip';
        if (isOwnedTab) { // Only allow equipping owned items
                        // In createCosmeticItemElement's onclick:
            equipButton.onclick = () => {
                fnPS('click');
                currentEquippedCosmetics[cosmeticTypeKey] = cosmeticValue;
                fnSCS(); // Save cosmetic settings
                
                // Refresh only the content of the currently active tab's panel
                const activeTabButton = document.querySelector('.cosmetic-tab-btn.active');
                if (activeTabButton) {
                    const activePanelId = activeTabButton.dataset.tabTarget.substring(1); // cosmeticTabOwned, etc.
                    const isOwned = activePanelId === 'cosmeticTabOwned'; // Check if it's the "Owned" tab
                    populateCosmeticTab(activePanelId, isOwned);
                } else {
                    // Fallback or if no tab is active (shouldn't happen ideally)
                    // You could repopulate 'cosmeticTabOwned' by default or do nothing.
                    populateCosmeticTab('cosmeticTabOwned', true);
                }
            };
        } else {
            equipButton.disabled = true; // Cannot equip non-owned items (for now)
            equipButton.title = "Unlock this item first!";
        }
    }
    itemDiv.appendChild(equipButton);
    return itemDiv;
}

function populateCosmeticTab(tabId, isOwnedTab) {
    const tabPanel = document.getElementById(tabId);
    if (!tabPanel) return;
    tabPanel.innerHTML = '';

    if (tabId === 'cosmeticTabOwned') {
    }

    const appearanceSection = document.createElement('div');
    appearanceSection.classList.add('cosmetic-section');
    const appearanceHeader = document.createElement('h3');
    appearanceHeader.textContent = 'Appearance';
    appearanceSection.appendChild(appearanceHeader);

    Object.keys(R_COSMETIC_DEFAULTS).forEach(key => {
        const typeGroup = document.createElement('div');
        typeGroup.classList.add('cosmetic-type-group');
        const typeHeader = document.createElement('h4');
        typeHeader.textContent = COSMETIC_DISPLAY_NAMES.appearance[key] || key;
        typeGroup.appendChild(typeHeader);

        const itemList = document.createElement('div');
        itemList.classList.add('cosmetic-item-list');

        if (isOwnedTab) {
            if (key === 'trailCW') {
                const trailTypes = [
                    "default", "dust", "smoke", "fire", "sparkler",
                    "bubbles", "rainbow", "simpleLines", "magic", "sparkles",
                    "aurora", "confetti", "glitch", "laser", "shadow",
                    "plasma", "snow", "rgbDots", "wind", "lingeringGlow"
                ];
                trailTypes.forEach(trailType => {
                    let displayName = trailType.charAt(0).toUpperCase() + trailType.slice(1);
                    if (trailType === "simpleLines") displayName = "Simple Lines";
                    if (trailType === "rgbDots") displayName = "RGB Dots";
                    if (trailType === "lingeringGlow") displayName = "Lingering Glow";

                    itemList.appendChild(createCosmeticItemElement(
                        displayName,
                        currentEquippedCosmetics.trailCW === trailType,
                        true,
                        'trailCW',
                        trailType
                    ));
                });
            } else {
                itemList.appendChild(createCosmeticItemElement(
                    'Default',
                    currentEquippedCosmetics[key] === R_COSMETIC_DEFAULTS[key],
                    true,
                    key,
                    R_COSMETIC_DEFAULTS[key]
                ));
            }
        } else {
            const noItemsText = document.createElement('span');
            noItemsText.classList.add('no-items-text');
            noItemsText.textContent = 'No items.';
            itemList.appendChild(noItemsText);
        }
        typeGroup.appendChild(itemList);
        appearanceSection.appendChild(typeGroup);
    });
    tabPanel.appendChild(appearanceSection);

    const sfxSection = document.createElement('div');
    sfxSection.classList.add('cosmetic-section');
    const sfxHeader = document.createElement('h3');
    sfxHeader.textContent = 'SFX';
    sfxSection.appendChild(sfxHeader);

    Object.keys(R_SFX_DEFAULTS).forEach(key => {
        const typeGroup = document.createElement('div');
        typeGroup.classList.add('cosmetic-type-group');
        const typeHeader = document.createElement('h4');
        typeHeader.textContent = COSMETIC_DISPLAY_NAMES.sfx[key] || key;
        typeGroup.appendChild(typeHeader);

        const itemList = document.createElement('div');
        itemList.classList.add('cosmetic-item-list');

        if (isOwnedTab) {
            itemList.appendChild(createCosmeticItemElement(
                'Default',
                currentEquippedCosmetics[key] === R_SFX_DEFAULTS[key],
                true,
                key,
                R_SFX_DEFAULTS[key]
            ));
        } else {
            const noItemsText = document.createElement('span');
            noItemsText.classList.add('no-items-text');
            noItemsText.textContent = 'No items.';
            itemList.appendChild(noItemsText);
        }
        typeGroup.appendChild(itemList);
        sfxSection.appendChild(typeGroup);
    });
    tabPanel.appendChild(sfxSection);
}

function setupCosmeticTabs() {
    const tabButtons = document.querySelectorAll('.cosmetic-tab-btn');
    const tabPanels = document.querySelectorAll('.cosmetic-tab-panel');

    tabButtons.forEach(button => {
        if (!button.dataset.listenerSetup) {
            button.addEventListener('click', () => {
                fnPS('click');
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));

                button.classList.add('active');
                const targetPanelId = button.dataset.tabTarget;
                const targetPanel = document.querySelector(targetPanelId);
                if (targetPanel) {
                    targetPanel.classList.add('active');
                    const isOwned = targetPanelId.substring(1) === 'cosmeticTabOwned';
                    populateCosmeticTab(targetPanelId.substring(1), isOwned);
                }
            });
            button.dataset.listenerSetup = 'true';
        }
    });

    populateCosmeticTab('cosmeticTabOwned', true);
    populateCosmeticTab('cosmeticTabCoin', false);
    populateCosmeticTab('cosmeticTabXp', false);
    populateCosmeticTab('cosmeticTabMystery', false);

    const ownedTabButton = document.querySelector('.cosmetic-tab-btn[data-tab-target="#cosmeticTabOwned"]');
    const ownedTabPanel = document.getElementById('cosmeticTabOwned');
    if (ownedTabButton && ownedTabPanel && !ownedTabButton.classList.contains('active')) {
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabPanels.forEach(panel => panel.classList.remove('active'));
        ownedTabButton.classList.add('active');
        ownedTabPanel.classList.add('active');
    }
}

function fnSLFK(type) {
    fnPS('click');
    lstnKey = type;
    let btnToChange;
    if (type === 'left') btnToChange = keybindLeftBtn;
    else if (type === 'right') btnToChange = keybindRightBtn;
    else if (type === 'maxSpeed') btnToChange = keybindMaxSpeedBtn;
    else if (type === 'pause') btnToChange = keybindPauseBtn;

    if (btnToChange) btnToChange.textContent = 'Press key...';

    // Array of all elements to disable/enable
    const elementsToToggle = [
        keybindLeftBtn, keybindRightBtn, keybindMaxSpeedBtn, keybindPauseBtn,
        volumeSlider, sensitivitySlider,
        qualitySelectElement, // Graphics Quality select
        autosaveReplaysSelect, // Autosave Replays select
        autosaveThresholdBtn   // Above score button
    ];

    elementsToToggle.forEach(el => {
        if (el && el !== btnToChange) {
            el.disabled = true;
            if (el.style) {
                el.style.cursor = 'not-allowed';
                if (el === qualitySelectElement || el === autosaveReplaysSelect) {
                    el.style.backgroundColor = '#555';
                    el.style.opacity = '1';
                } else if (el.tagName === 'BUTTON' && el.classList.contains('keybindBtn')) {
                    el.style.opacity = '1'; // Rely on CSS :disabled for background
                } else if (el.tagName === 'INPUT' && el.type === 'range') {
                    el.style.opacity = '0.6';
                }
            }
        }
    });
}
function fnSK(key) {
    if (!lstnKey) return;

    if (key.toLowerCase() === 'escape') {
        fnPS('click'); // Play sound for escape/cancel
    } else {
        if (lstnKey === 'left') keybindLeft = key.toLowerCase();
        else if (lstnKey === 'right') keybindRight = key.toLowerCase();
        else if (lstnKey === 'maxSpeed') keybindMaxSpeed = key.toLowerCase();
        else if (lstnKey === 'pause') keybindPause = key.toLowerCase();
        fnSVS(); // Save all settings (including new keybind)
        fnPS('click'); // Play sound for successful keybind set
    }

    // Update button text content
    if (keybindLeftBtn) keybindLeftBtn.textContent = keybindLeft.toUpperCase();
    if (keybindRightBtn) keybindRightBtn.textContent = keybindRight.toUpperCase();
    if (keybindMaxSpeedBtn) keybindMaxSpeedBtn.textContent = keybindMaxSpeed.toUpperCase();
    if (keybindPauseBtn) keybindPauseBtn.textContent = keybindPause.toUpperCase();

    lstnKey = null; // Reset listening state

    // Array of all elements to re-enable
    const elementsToToggle = [
        keybindLeftBtn, keybindRightBtn, keybindMaxSpeedBtn, keybindPauseBtn,
        volumeSlider, sensitivitySlider,
        qualitySelectElement,    // Graphics Quality select
        autosaveReplaysSelect,   // Autosave Replays select
        autosaveThresholdBtn     // Above score button
    ];

    elementsToToggle.forEach(el => {
        if (el) {
            el.disabled = false;
            if (el.style) {
                el.style.cursor = 'pointer';
                el.style.removeProperty('opacity'); // Remove opacity override
                if (el === qualitySelectElement || el === autosaveReplaysSelect) {
                    el.style.removeProperty('background-color'); // Restore original background
                }
            }
        }
    });
}

function fnGHS(){const s=localStorage.getItem('highScores');return s?JSON.parse(s):[];}
function fnSHS(newScore, timeStr, gameEndTimeMs) {
    let allScoresStored = fnGHS();
    const newEntry = {
        score: newScore,
        time: timeStr,
        timestamp: gameEndTimeMs, 
        date: new Date(gameEndTimeMs).toLocaleDateString(), 
        mode: currentGameMode,
        replayId: null, // Initially, no replay is linked by fnSHS
        note: ""
    };

    allScoresStored.push(newEntry);

    let classicScoresAll = allScoresStored.filter(s => s.mode === 'classic');
    let hardcoreScoresAll = allScoresStored.filter(s => s.mode === 'hardcore');

    classicScoresAll.sort((a, b) => b.score - a.score);
    const top100Classic = classicScoresAll.slice(0, 100);

    hardcoreScoresAll.sort((a, b) => b.score - a.score);
    const top100Hardcore = hardcoreScoresAll.slice(0, 100);
    
    const finalScoresToStore = [...top100Classic, ...top100Hardcore];
    localStorage.setItem('highScores', JSON.stringify(finalScoresToStore));

    const modeScoresForChecking = (currentGameMode === 'classic' ? top100Classic : top100Hardcore);
    let isNewHighScoreForMode = false;

    if (modeScoresForChecking.length > 0) {
        const newEntryIndexInModeScores = modeScoresForChecking.findIndex(
            hs => hs.score === newEntry.score && 
                  hs.timestamp === newEntry.timestamp && 
                  hs.mode === newEntry.mode
        );

        if (newEntryIndexInModeScores !== -1) { 
            if (newEntry.score > ( (modeScoresForChecking[0]?.score === newEntry.score && modeScoresForChecking[0]?.timestamp === newEntry.timestamp) ? -1 : (modeScoresForChecking[0]?.score || 0) ) ) {
                 isNewHighScoreForMode = true; 
            } else if (newEntryIndexInModeScores === 0 && modeScoresForChecking.length === 1) {
                 isNewHighScoreForMode = true; 
            } else if (newEntryIndexInModeScores === 0 && newEntry.score >= (modeScoresForChecking[1]?.score || 0) ) {
                 isNewHighScoreForMode = true; 
            }
        }
    } else { 
        if ( (currentGameMode === 'classic' && top100Classic.some(hs => hs.timestamp === newEntry.timestamp)) ||
             (currentGameMode === 'hardcore' && top100Hardcore.some(hs => hs.timestamp === newEntry.timestamp)) ) {
            isNewHighScoreForMode = true;
        }
    }
    return isNewHighScoreForMode;
}

function createItemListItem(itemData, isReplayScreen, rank = null) {
    const li = document.createElement('li');
    // ... (initial li and itemContentBox setup as before) ...

    let scoreToDisplay, timeStringToDisplay, itemTimestamp, itemMode, replayIdForLookup, initialNote; // itemTimestamp and itemMode are key for shared notes
    const willHaveExternalRank = (rank !== null && !isReplayScreen);

    const itemContentBox = document.createElement('div');
    itemContentBox.classList.add('item-content-box');

    const noteContainer = document.createElement('div');
    noteContainer.classList.add('item-note-container');


    if (isReplayScreen) {
        li.classList.add('replay-list-entry');
        scoreToDisplay = itemData.fs;    // Final Score from replay
        timeStringToDisplay = fnFT(itemData.ft); // Final Time from replay
        itemTimestamp = itemData.ts;     // Timestamp from replay data (game end time)
        replayIdForLookup = itemData.i;  // Replay's own unique ID
        itemMode = R_GM_REV_MAP[itemData.gm] || 'classic'; // Game mode from replay

        initialNote = getSharedNote(itemTimestamp, itemMode); // <<< USE SHARED FUNCTION

        // ... (rest of itemContentBox population for Replay as before) ...
        const itemInfoDiv = document.createElement('div');
        itemInfoDiv.classList.add('item-info');
        const line1 = document.createElement('div');
        line1.innerHTML = `<strong>${scoreToDisplay} pts</strong> (${timeStringToDisplay})`;
        const line2 = document.createElement('div');
        const itemDate = new Date(itemTimestamp);
        const dateStr = itemDate.toLocaleDateString();
        const timeStrVal = itemDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        line2.textContent = `${dateStr} - ${timeStrVal}`;
        itemInfoDiv.appendChild(line1);
        itemInfoDiv.appendChild(line2);
        itemContentBox.appendChild(itemInfoDiv);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('item-actions');
        let replayForThisItemCompact = null;
         if (replayIdForLookup) { // This is itemData.i from replay
             replayForThisItemCompact = sReps.find(r => r.i === replayIdForLookup);
         }
         if (replayForThisItemCompact) {
             // ... (Play, Export, Delete buttons for replay - logic remains same) ...
             const playBtn = document.createElement('button');
             playBtn.title = 'Play Replay';
             playBtn.classList.add('play-btn-geom');
             playBtn.innerHTML = `<svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path></svg>`;
             playBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnSRP(replayForThisItemCompact); };
             actionsDiv.appendChild(playBtn);

             const exportBtn = document.createElement('button');
             exportBtn.title = 'Export Replay';
             exportBtn.classList.add('export-btn-geom');
             exportBtn.innerHTML = `<svg viewBox="0 0 24 24" class="export-svg-icon" xmlns="http://www.w3.org/2000/svg">
                 <line x1="12" y1="15" x2="12" y2="5" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
                 <polyline points="8 9 12 5 16 9" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 </svg>`;
             exportBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnShowExportDialog(replayForThisItemCompact); };
             actionsDiv.appendChild(exportBtn);

             const deleteBtn = document.createElement('button');
             deleteBtn.title = 'Delete Replay';
             deleteBtn.classList.add('delete-btn-geom');
             deleteBtn.innerHTML = `<svg viewBox="0 0 10 10" class="delete-svg-icon" xmlns="http://www.w3.org/2000/svg"><line x1="1.5" y1="1.5" x2="8.5" y2="8.5" stroke-linecap="round"/><line x1="8.5" y1="1.5" x2="1.5" y2="8.5" stroke-linecap="round"/></svg>`;
             // For deleting a replay, we also need to delete its shared note
             deleteBtn.onclick = (e) => {
                 e.stopPropagation();
                 fnPS('click');
                 // Pass timestamp and mode to fnSDRC if it's going to handle shared note deletion
                 // Otherwise, delete shared note here before calling fnSDRC or after in fnCDR
                 fnSDRC(replayForThisItemCompact.i, itemTimestamp, itemMode); // Pass more info
             };
             actionsDiv.appendChild(deleteBtn);
         }
        itemContentBox.appendChild(actionsDiv);
        li.appendChild(itemContentBox);
        li.appendChild(noteContainer);

    } else { // Personal Best Screen
        li.classList.add('score-list-entry');
        li.classList.add('score-list-entry-ranked');

        scoreToDisplay = itemData.score;
        timeStringToDisplay = itemData.time;
        itemTimestamp = itemData.timestamp; // Timestamp from personal best data (game end time)
        replayIdForLookup = itemData.replayId; // Might be null if no replay linked
        itemMode = itemData.mode;          // Game mode from personal best

        initialNote = getSharedNote(itemTimestamp, itemMode); // <<< USE SHARED FUNCTION

        // ... (rest of itemContentBox and wrapper setup for Personal Best as before) ...
         if (willHaveExternalRank) {
             const rankSpan = document.createElement('span');
             rankSpan.classList.add('score-rank');
             rankSpan.textContent = `${rank}.`;
             li.appendChild(rankSpan);
         }

         const contentAndNoteWrapper = document.createElement('div');
         contentAndNoteWrapper.style.display = 'flex';
         contentAndNoteWrapper.style.flexDirection = 'column';
         contentAndNoteWrapper.style.flexGrow = '1';      // Allow it to grow into available space
         contentAndNoteWrapper.style.flexShrink = '1';    // Explicitly allow it to shrink
         contentAndNoteWrapper.style.flexBasis = '0%';    // Essential: its initial size is 0, growth is determined by flex-grow
         contentAndNoteWrapper.style.minWidth = '0';      // Allow it to shrink smaller than its content's intrinsic width
         contentAndNoteWrapper.style.overflow = 'hidden';

         const itemInfoDiv = document.createElement('div');
         itemInfoDiv.classList.add('item-info');
         const line1 = document.createElement('div');
         line1.innerHTML = `<strong>${scoreToDisplay} pts</strong> (${timeStringToDisplay})`;
         const line2 = document.createElement('div');
         const itemDate = new Date(itemTimestamp);
         const dateStr = itemDate.toLocaleDateString();
         const timeStrVal = itemDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
         line2.textContent = `${dateStr} - ${timeStrVal}`;
         itemInfoDiv.appendChild(line1);
         itemInfoDiv.appendChild(line2);
         itemContentBox.appendChild(itemInfoDiv);

         const actionsDiv = document.createElement('div');
         actionsDiv.classList.add('item-actions');
         let replayForThisItemCompactHS = null;
         if (replayIdForLookup) {
             replayForThisItemCompactHS = sReps.find(r => r.i === replayIdForLookup);
         }
         if (replayForThisItemCompactHS) {
             // ... (Play, Export, Delete buttons for high score's replay link - logic remains same) ...
             // Note: Deleting a replay via high score should also delete its shared note
             const playBtn = document.createElement('button');
             playBtn.title = 'Play Replay';
             playBtn.classList.add('play-btn-geom');
             playBtn.innerHTML = `<svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path></svg>`;
             playBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnSRP(replayForThisItemCompactHS); };
             actionsDiv.appendChild(playBtn);

             const exportBtn = document.createElement('button');
             exportBtn.title = 'Export Replay';
             exportBtn.classList.add('export-btn-geom');
             exportBtn.innerHTML = `<svg viewBox="0 0 24 24" class="export-svg-icon" xmlns="http://www.w3.org/2000/svg">
                 <line x1="12" y1="15" x2="12" y2="5" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
                 <polyline points="8 9 12 5 16 9" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 </svg>`;
             exportBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnShowExportDialog(replayForThisItemCompactHS); };
             actionsDiv.appendChild(exportBtn);

             const deleteBtn = document.createElement('button');
             deleteBtn.title = 'Delete Replay';
             deleteBtn.classList.add('delete-btn-geom');
             deleteBtn.innerHTML = `<svg viewBox="0 0 10 10" class="delete-svg-icon" xmlns="http://www.w3.org/2000/svg"><line x1="1.5" y1="1.5" x2="8.5" y2="8.5" stroke-linecap="round"/><line x1="8.5" y1="1.5" x2="1.5" y2="8.5" stroke-linecap="round"/></svg>`;
             deleteBtn.onclick = (e) => {
                 e.stopPropagation();
                 fnPS('click');
                 // If deleting replay from HS list, we need its original timestamp & mode to delete the shared note
                 const replayToDelete = sReps.find(r => r.i === replayIdForLookup);
                 if (replayToDelete) {
                     fnSDRC(replayIdForLookup, replayToDelete.ts, R_GM_REV_MAP[replayToDelete.gm]);
                 } else {
                     fnSDRC(replayIdForLookup); // Fallback if replay somehow not found
                 }
             };
             actionsDiv.appendChild(deleteBtn);
         }
         itemContentBox.appendChild(actionsDiv);
         contentAndNoteWrapper.appendChild(itemContentBox);
         contentAndNoteWrapper.appendChild(noteContainer);
         li.appendChild(contentAndNoteWrapper);
    }

    // --- Note Handling Logic (functionality remains the same, but uses saveSharedNote) ---
    const placeholderText = "Click to add note...";

    function showNoteDisplay(text) { /* ... same as before ... */
         noteContainer.innerHTML = '';
         if (text) {
             const noteTextSpan = document.createElement('span');
             noteTextSpan.textContent = text;
             noteContainer.appendChild(noteTextSpan);
         } else {
             const placeholderSpan = document.createElement('span');
             placeholderSpan.classList.add('note-placeholder-text');
             placeholderSpan.textContent = placeholderText;
             noteContainer.appendChild(placeholderSpan);
         }
         noteContainer.classList.add('visible');
    }

    function showEditableNote(currentText) { /* ... same as before ... */
         noteContainer.innerHTML = '';
         const editableArea = document.createElement('div');
         editableArea.classList.add('note-editable-area');
         editableArea.contentEditable = "true";
         editableArea.textContent = (currentText === placeholderText || currentText === "") ? "" : currentText;
         noteContainer.appendChild(editableArea);
         editableArea.focus();

         if (currentText !== placeholderText && currentText !== "") {
             const range = document.createRange();
             range.selectNodeContents(editableArea);
             const sel = window.getSelection();
             sel.removeAllRanges();
             sel.addRange(range);
         }
         editableArea.dataset.editing = "true";

         function saveAndExitEditing() {
             if (editableArea.dataset.editing !== "true") return;
             editableArea.dataset.editing = "false";

             const newNoteText = editableArea.textContent.trim();
             // itemTimestamp and itemMode are already correctly set for both HS and Replay contexts
             saveSharedNote(itemTimestamp, itemMode, newNoteText); // <<< USE SHARED FUNCTION
             initialNote = newNoteText;

             if (newNoteText) {
                 showNoteDisplay(newNoteText);
             } else {
                 showNoteDisplay("");
                 if (!li.matches(':hover')) {
                     noteContainer.classList.remove('visible');
                 }
             }
         }
         // ... (blur and keydown listeners for editableArea remain the same) ...
         editableArea.addEventListener('blur', () => {
             setTimeout(saveAndExitEditing, 50);
         });

         editableArea.addEventListener('keydown', (e) => {
             if (e.key === 'Enter' && !e.shiftKey) {
                 e.preventDefault();
                 saveAndExitEditing();
             } else if (e.key === 'Escape') {
                 e.preventDefault();
                 editableArea.dataset.editing = "false";
                 showNoteDisplay(initialNote || "");
                  if (!initialNote && !li.matches(':hover')) {
                      noteContainer.classList.remove('visible');
                  }
             }
         });
    }
     // ... (initial display and li mouseenter/mouseleave for notes remain the same) ...
     if (initialNote) {
         showNoteDisplay(initialNote);
     }

     li.addEventListener('mouseenter', () => {
         if (!noteContainer.querySelector('.note-editable-area')) {
             if (initialNote) {
                 showNoteDisplay(initialNote);
             } else {
                 showNoteDisplay("");
             }
         }
     });

     li.addEventListener('mouseleave', () => {
         if (!noteContainer.querySelector('.note-editable-area')) {
             if (!initialNote) {
                 noteContainer.classList.remove('visible');
                 noteContainer.innerHTML = '';
             }
         }
     });

    noteContainer.addEventListener('click', (e) => { /* ... same as before ... */
         e.stopPropagation();
         fnPS('click');
         if (!noteContainer.querySelector('.note-editable-area')) {
             const currentDisplayedText = noteContainer.textContent;
             showEditableNote(currentDisplayedText);
         }
    });
    // noteContainer is appended within the if/else blocks now

    return li;
}

function fnDHS() { 
    const scores = fnGHS(); 
    const cl = document.getElementById('classicHighScoresList');
    const hl = document.getElementById('hardcoreHighScoresList');
    
    if (!cl) { console.error("Classic high scores list element (classicHighScoresList) not found!"); return; }
    if (!hl) { console.error("Hardcore high scores list element (hardcoreHighScoresList) not found!"); return; }

    cl.innerHTML = ''; 
    hl.innerHTML = '';

    const classicScores = scores.filter(s => s.mode === 'classic').sort((a, b) => b.score - a.score);
    const hardcoreScores = scores.filter(s => s.mode === 'hardcore').sort((a, b) => b.score - a.score);

    if (classicScores.length === 0) {
        const li = document.createElement('li');
        li.classList.add('score-list-entry'); 
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box'); 
        contentBox.classList.add('placeholder-message'); // ADDED CLASS
        contentBox.textContent = 'No classic scores yet!';
        li.appendChild(contentBox);
        cl.appendChild(li);
    } else {
        classicScores.forEach((score, index) => cl.appendChild(createItemListItem(score, false, index + 1)));
    }

    if (hardcoreScores.length === 0) {
        const li = document.createElement('li');
        li.classList.add('score-list-entry'); 
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box'); 
        contentBox.classList.add('placeholder-message'); // ADDED CLASS
        contentBox.textContent = 'No hardcore scores yet!';
        li.appendChild(contentBox);
        hl.appendChild(li);
    } else {
        hardcoreScores.forEach((score, index) => hl.appendChild(createItemListItem(score, false, index + 1)));
    }
}


function fnDRpsL() {
    const classicListEl = document.getElementById('classicReplaysList');
    const hardcoreListEl = document.getElementById('hardcoreReplaysList');

    if (!classicListEl || !hardcoreListEl) {
        console.error("Replay list elements not found!");
        return;
    }

    classicListEl.innerHTML = '';
    hardcoreListEl.innerHTML = '';

    const MAX_REPLAYS_PER_MODE = 50;

    const classicReplays = sReps.filter(r => r.gm === R_GM_MAP.classic);
    const hardcoreReplays = sReps.filter(r => r.gm === R_GM_MAP.hardcore);

    classicReplays.sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());
    hardcoreReplays.sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());

    const classicTabBtn = document.querySelector('#replaysScreen .mode-tab-btn[data-tab-target="#replaysClassicModeTab"]');
    const hardcoreTabBtn = document.querySelector('#replaysScreen .mode-tab-btn[data-tab-target="#replaysHardcoreModeTab"]');
    if (classicTabBtn) classicTabBtn.textContent = `Classic (${classicReplays.length}/${MAX_REPLAYS_PER_MODE})`;
    if (hardcoreTabBtn) hardcoreTabBtn.textContent = `Hardcore (${hardcoreReplays.length}/${MAX_REPLAYS_PER_MODE})`;

    const deleteAllBtn = document.getElementById('deleteAllReplaysBtn');
    if (deleteAllBtn) {
        const svgIcon = deleteAllBtn.querySelector('svg'); // Get the SVG icon
        let existingTextNode = null;
        for (let i = 0; i < deleteAllBtn.childNodes.length; i++) {
            if (deleteAllBtn.childNodes[i].nodeType === Node.TEXT_NODE && deleteAllBtn.childNodes[i].nodeValue.trim() !== '') {
                existingTextNode = deleteAllBtn.childNodes[i];
                break;
            }
        }

        let newText = '';
        const activeReplayTab = document.querySelector('#replaysScreen .mode-tab-btn.active');
        if (activeReplayTab) {
            if (activeReplayTab.dataset.tabTarget === '#replaysClassicModeTab') {
                newText = ' Delete Classic Replays';
            } else if (activeReplayTab.dataset.tabTarget === '#replaysHardcoreModeTab') {
                newText = ' Delete Hardcore Replays';
            }
        } else {
            newText = ' Delete Classic Replays'; // Default
        }

        if (existingTextNode) {
            existingTextNode.nodeValue = newText;
        } else if (svgIcon) {
            deleteAllBtn.insertBefore(document.createTextNode(newText), svgIcon.nextSibling);
        } else {
            deleteAllBtn.appendChild(document.createTextNode(newText));
        }
    }


    if (classicReplays.length === 0) {
        const li = document.createElement('li');
        li.classList.add('replay-list-entry');
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box');
        contentBox.classList.add('placeholder-message');
        contentBox.textContent = 'No classic replays!';
        li.appendChild(contentBox);
        classicListEl.appendChild(li);
    } else {
        const classicFragment = document.createDocumentFragment();
        classicReplays.forEach(r => {
            const listItem = createItemListItem(r, true);
            classicFragment.appendChild(listItem);
        });
        classicListEl.appendChild(classicFragment);
    }

    if (hardcoreReplays.length === 0) {
        const li = document.createElement('li');
        li.classList.add('replay-list-entry');
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box');
        contentBox.classList.add('placeholder-message');
        contentBox.textContent = 'No hardcore replays!';
        li.appendChild(contentBox);
        hardcoreListEl.appendChild(li);
    } else {
        const hardcoreFragment = document.createDocumentFragment();
        hardcoreReplays.forEach(r => {
            const listItem = createItemListItem(r, true);
            hardcoreFragment.appendChild(listItem);
        });
        hardcoreListEl.appendChild(hardcoreFragment);
    }
}

function fnShowDeleteAllConf() {
    fnPS('click');
    const activeReplayTab = document.querySelector('#replaysScreen .mode-tab-btn.active');
    const confirmationDialogTextEl = document.querySelector('#deleteAllReplaysConfirmationDialog p');
    const confirmButton = document.getElementById('confirmDeleteAllReplaysBtn');

    // Reset confirm button text to default ("Delete All" or similar)
    const confirmButtonSvg = confirmButton.querySelector('svg');
    let confirmButtonTextNode = null;
    for (let i = 0; i < confirmButton.childNodes.length; i++) {
        if (confirmButton.childNodes[i].nodeType === Node.TEXT_NODE && confirmButton.childNodes[i].nodeValue.trim() !== '') {
            confirmButtonTextNode = confirmButton.childNodes[i];
            break;
        }
    }
    const defaultConfirmText = ' Delete All'; // Or "Confirm Delete"
    if (confirmButtonTextNode) {
        confirmButtonTextNode.nodeValue = defaultConfirmText;
    } else if (confirmButtonSvg) {
        confirmButton.insertBefore(document.createTextNode(defaultConfirmText), confirmButtonSvg.nextSibling);
    } else {
        confirmButton.appendChild(document.createTextNode(defaultConfirmText));
    }


    if (activeReplayTab && confirmationDialogTextEl) {
        if (activeReplayTab.dataset.tabTarget === '#replaysClassicModeTab') {
            modeToDeleteFromReplays = 'classic';
            confirmationDialogTextEl.textContent = 'Are you sure you want to delete ALL Classic replays? This cannot be undone.';
        } else if (activeReplayTab.dataset.tabTarget === '#replaysHardcoreModeTab') {
            modeToDeleteFromReplays = 'hardcore';
            confirmationDialogTextEl.textContent = 'Are you sure you want to delete ALL Hardcore replays? This cannot be undone.';
        } else {
            // This case should not be reached if a tab is always active on the replays screen
            modeToDeleteFromReplays = null; 
            confirmationDialogTextEl.textContent = 'Error: Could not determine replay mode. Please try again.';
            console.error("Could not determine active replay tab for deletion.");
        }
    } else {
        // Fallback if elements are not found (should not happen)
        modeToDeleteFromReplays = null;
        if(confirmationDialogTextEl) confirmationDialogTextEl.textContent = 'Are you sure you want to delete these replays? This cannot be undone.';
    }
    deleteAllReplaysConfirmationDialog.style.display = 'flex';
}

function fnCDAR() {
    if (!modeToDeleteFromReplays) {
        console.warn("fnCDAR called but modeToDeleteFromReplays was not set. No replays deleted.");
        fnHDARC(); // Hide dialog
        return;
    }

    const gameModeCodeToFilter = R_GM_MAP[modeToDeleteFromReplays];
    if (gameModeCodeToFilter === undefined) {
        console.error("Invalid mode to delete in fnCDAR:", modeToDeleteFromReplays);
        fnHDARC();
        modeToDeleteFromReplays = null;
        return;
    }

    let currentReplays = sReps;
    let notes = JSON.parse(localStorage.getItem('orbilaSharedNotes') || '{}');
    let highScores = fnGHS();
    let notesModified = false;
    let hsModified = false;
    let replaysActuallyDeletedCount = 0;

    // Identify replays to be deleted and their associated data
    const replaysToDeleteIds = [];
    currentReplays.forEach(replay => {
        if (replay.gm === gameModeCodeToFilter) {
            replaysToDeleteIds.push(replay.i);

            // Remove associated note
            const noteCompositeKey = `${modeToDeleteFromReplays}_${replay.ts}`;
            if (notes[noteCompositeKey]) {
                delete notes[noteCompositeKey];
                notesModified = true;
            }
        }
    });

    // Filter out the replays marked for deletion
    sReps = currentReplays.filter(replay => !replaysToDeleteIds.includes(replay.i));
    replaysActuallyDeletedCount = currentReplays.length - sReps.length;

    // Unlink deleted replays from high scores
    if (replaysActuallyDeletedCount > 0) {
        highScores = highScores.map(hs => {
            if (hs.replayId && replaysToDeleteIds.includes(hs.replayId) && hs.mode === modeToDeleteFromReplays) {
                hsModified = true;
                return { ...hs, replayId: null, note: "" }; // Unlink and clear associated note
            }
            return hs;
        });
    }

    // Save updated data to localStorage
    if (replaysActuallyDeletedCount > 0) {
        try {
            localStorage.setItem('orbilaReplays', JSON.stringify(sReps));
        } catch (e) {
            console.error("Error saving filtered replays to localStorage:", e);
        }
    }

    if (notesModified) {
        try {
            localStorage.setItem('orbilaSharedNotes', JSON.stringify(notes));
        } catch (e) {
            console.error("Error saving updated shared notes to localStorage:", e);
        }
    }

    if (hsModified) {
        try {
            localStorage.setItem('highScores', JSON.stringify(highScores));
        } catch (e) {
            console.error("Error saving updated high scores to localStorage:", e);
        }
    }

    fnDRpsL();
    fnHDARC();
    fnPS('click');
    modeToDeleteFromReplays = null;
}

function fnHDARC() { deleteAllReplaysConfirmationDialog.style.display = 'none'; fnPS('click'); }

function fnShowExportDialog(compactReplayData) { 
    exportReplayTextArea.value = JSON.stringify(compactReplayData);
    exportReplayDialog.style.display = 'flex';
}
function fnCopyExportedReplay() {
    exportReplayTextArea.select();
    exportReplayTextArea.setSelectionRange(0, exportReplayTextArea.value.length);

    const buttonTextSpan = copyExportReplayBtn.querySelector('.btn-text-dynamic');

    try {
        document.execCommand('copy');

        if (buttonTextSpan) {
            buttonTextSpan.textContent = 'Copied!';
        }
        copyExportReplayBtn.classList.add('copied-success');


        setTimeout(() => {
            if (buttonTextSpan) {
                buttonTextSpan.textContent = 'Copy';
            }
            copyExportReplayBtn.classList.remove('copied-success');

            if (exportReplayDialog) {
                exportReplayDialog.style.display = 'none';
            }
        }, 800); 
    } catch (err) {
        console.error('Failed to copy replay code: ', err);
        if (buttonTextSpan) {
            buttonTextSpan.textContent = 'Copy Failed';
        }
        setTimeout(() => {
            if (buttonTextSpan) {
                buttonTextSpan.textContent = 'Copy';
            }
        }, 2000);
    }
    fnPS('click'); // Play click sound on initial button press
}

function fnShowImportDialog() {
    importReplayTextArea.value = '';
    importReplayError.textContent = '';
    importReplayDialog.style.display = 'flex';
    fnPS('click');
}
function fnImportAndPlayReplay() {
    fnPS('click');
    const code = importReplayTextArea.value;
    if (!code.trim()) {
        importReplayError.textContent = "Paste code first!";
        return;
    }
    try {
        let importedReplay = JSON.parse(code);
        
        if (importedReplay && typeof importedReplay.v === 'number' && (importedReplay.i || importedReplay.id) && (importedReplay.gs !== undefined || importedReplay.gameSeed !== undefined)) {
            
            
            
            
            
            const verboseReplayForPlayback = fnDecodeReplayData(importedReplay); 
            if (!verboseReplayForPlayback) {
                 importReplayError.textContent = "Invalid or unsupported replay format!";
                 return;
            }

            importReplayDialog.style.display = 'none';
            
            
            
            
            
            

            fnSRP(verboseReplayForPlayback, true); 
        } else {
            importReplayError.textContent = "Invalid Replay Code Structure!";
        }
    } catch (e) {
        console.error("Error parsing imported replay:", e);
        importReplayError.textContent = "Invalid Replay Code Format!";
    }
}

function fnEncodeReplayData(verboseData) {
    if (!verboseData || !verboseData.events || verboseData.v === REPLAY_FORMAT_VERSION) {
        // If it's already the current version (or invalid), return as is.
        // This check `verboseData.v === REPLAY_FORMAT_VERSION` assumes you might pass already compact data.
        // If verboseData always comes from cRepData which has v:-1, this part of condition might not be hit.
        return verboseData;
    }

    const compact = {
        v: REPLAY_FORMAT_VERSION, // Ensure this is your target version
        i: verboseData.id,
        gs: verboseData.gameSeed,
        gm: R_GM_MAP[verboseData.gameMode],
        ts: verboseData.timestamp,
        fs: verboseData.finalScore,
        ft: parseFloat(verboseData.finalTimeMs.toFixed(1)),
        ogw: verboseData.originalGameWidth,
        ogh: verboseData.originalGameHeight,
        c: { // Cosmetics
            cw: verboseData.cosmetics?.colorWheel !== undefined ? verboseData.cosmetics.colorWheel : R_COSMETIC_DEFAULTS.colorWheel,
            b: verboseData.cosmetics?.bucket !== undefined ? verboseData.cosmetics.bucket : R_COSMETIC_DEFAULTS.bucket,
            bls: verboseData.cosmetics?.balls !== undefined ? verboseData.cosmetics.balls : R_COSMETIC_DEFAULTS.balls,
            bg: verboseData.cosmetics?.background !== undefined ? verboseData.cosmetics.background : R_COSMETIC_DEFAULTS.background,
            tcw: verboseData.cosmetics?.trailCW !== undefined ? verboseData.cosmetics.trailCW : R_COSMETIC_DEFAULTS.trailCW,
            tpu: verboseData.cosmetics?.trailPU !== undefined ? verboseData.cosmetics.trailPU : R_COSMETIC_DEFAULTS.trailPU
            // drp: verboseData.cosmetics?.dropper !== undefined ? verboseData.cosmetics.dropper : R_COSMETIC_DEFAULTS.dropper // If added
        },
        sfx: { // Sound Effects
            scw: verboseData.sfx?.collectWheel !== undefined ? verboseData.sfx.collectWheel : R_SFX_DEFAULTS.collectWheel,
            scb: verboseData.sfx?.collectBucket !== undefined ? verboseData.sfx.collectBucket : R_SFX_DEFAULTS.collectBucket,
            sbd: verboseData.sfx?.ballDrop !== undefined ? verboseData.sfx.ballDrop : R_SFX_DEFAULTS.ballDrop,
            sll: verboseData.sfx?.loseLife !== undefined ? verboseData.sfx.loseLife : R_SFX_DEFAULTS.loseLife,
            scp: verboseData.sfx?.collectPowerup !== undefined ? verboseData.sfx.collectPowerup : R_SFX_DEFAULTS.collectPowerup
        },
        e: [] // Events
    };

    if (typeof compact.gm !== 'number') { // Fallback for gameMode
        compact.gm = R_GM_MAP.classic;
    }

    verboseData.events.forEach(event => {
        const t = parseFloat(event.t.toFixed(1));
        let compactEvent = [t];
        switch (event.type) {
            case 'mouse':
                compactEvent.push(R_EV_TYPES.MOUSE, parseFloat(event.x.toFixed(1)), parseFloat(event.y.toFixed(1)));
                break;
            case 'keydown':
                compactEvent.push(R_EV_TYPES.KEYDOWN, event.key);
                break;
            case 'keyup':
                compactEvent.push(R_EV_TYPES.KEYUP, event.key);
                break;
            case 'scoreLivesUpdate':
                compactEvent.push(R_EV_TYPES.SCORE_LIVES, event.score, event.lives);
                break;
            case 'powerupActivate':
                const puTypeAct = R_PU_TYPES[event.powerupType];
                const endTime = parseFloat(event.endTime.toFixed(1));
                let oneColorCode = null;
                if (event.powerupType === 'oneColor' && event.color) {
                    oneColorCode = R_COLOR_CODES[event.color];
                }
                compactEvent.push(R_EV_TYPES.POWERUP_ACT, puTypeAct, endTime, oneColorCode, event.collectedBallId !== undefined ? event.collectedBallId : null);
                break;
            case 'powerupDeactivate':
                const puTypeDeact = R_PU_TYPES[event.powerupType];
                compactEvent.push(R_EV_TYPES.POWERUP_DEACT, puTypeDeact);
                break;
            case 'ballSpawn':
                const colorCode = event.isPowerup ? R_COLOR_CODES.powerup : R_COLOR_CODES[event.colorName];
                compactEvent.push(R_EV_TYPES.BALL_SPAWN,
                    event.id, event.dropperId, event.isPowerup ? 1 : 0, colorCode,
                    parseFloat(event.fallSpeedFactor.toFixed(5)), parseFloat(event.sizeMultiplier.toFixed(5)),
                    parseFloat(event.swayTime.toFixed(5)), event.vx_sway_direction === 1 ? 1 : 0
                );
                break;
            case 'ballDespawn':
                compactEvent.push(R_EV_TYPES.BALL_DESPAWN, event.ballId, R_DESPAWN_REASONS[event.reason]);
                break;
            case 'gameEnd':
                compactEvent.push(R_EV_TYPES.GAME_END);
                break;
            default: return;
        }
        compact.e.push(compactEvent);
    });
    return compact;
}

function fnDecodeReplayData(dataToDecode) {
    if (!dataToDecode || typeof dataToDecode.v !== 'number') {
        console.error("Invalid data for decoding: 'v' (version) property is missing or not a number.", dataToDecode);
        return null;
    }

    // --- Current Version (REPLAY_FORMAT_VERSION) Decoding ---
    if (dataToDecode.v === REPLAY_FORMAT_VERSION) {
        if (dataToDecode.e && Array.isArray(dataToDecode.e)) { // Expect compact events array 'e'
            const verbose = {
                v: dataToDecode.v,
                id: dataToDecode.i,
                gameSeed: dataToDecode.gs,
                gameMode: R_GM_REV_MAP[dataToDecode.gm] || 'classic', // Default to classic if gm is invalid
                timestamp: dataToDecode.ts,
                finalScore: dataToDecode.fs,
                finalTimeMs: dataToDecode.ft,
                finalTimeStr: fnFT(dataToDecode.ft), // Helper to format time string
                originalGameWidth: dataToDecode.ogw,
                originalGameHeight: dataToDecode.ogh,
                cosmetics: {
                    colorWheel: dataToDecode.c?.cw !== undefined ? dataToDecode.c.cw : R_COSMETIC_DEFAULTS.colorWheel,
                    bucket: dataToDecode.c?.b !== undefined ? dataToDecode.c.b : R_COSMETIC_DEFAULTS.bucket,
                    balls: dataToDecode.c?.bls !== undefined ? dataToDecode.c.bls : R_COSMETIC_DEFAULTS.balls,
                    background: dataToDecode.c?.bg !== undefined ? dataToDecode.c.bg : R_COSMETIC_DEFAULTS.background,
                    trailCW: dataToDecode.c?.tcw !== undefined ? dataToDecode.c.tcw : R_COSMETIC_DEFAULTS.trailCW,
                    trailPU: dataToDecode.c?.tpu !== undefined ? dataToDecode.c.tpu : R_COSMETIC_DEFAULTS.trailPU
                    // dropper: dataToDecode.c?.drp !== undefined ? dataToDecode.c.drp : R_COSMETIC_DEFAULTS.dropper // If added
                },
                sfx: {
                    collectWheel: dataToDecode.sfx?.scw !== undefined ? dataToDecode.sfx.scw : R_SFX_DEFAULTS.collectWheel,
                    collectBucket: dataToDecode.sfx?.scb !== undefined ? dataToDecode.sfx.scb : R_SFX_DEFAULTS.collectBucket,
                    ballDrop: dataToDecode.sfx?.sbd !== undefined ? dataToDecode.sfx.sbd : R_SFX_DEFAULTS.ballDrop,
                    loseLife: dataToDecode.sfx?.sll !== undefined ? dataToDecode.sfx.sll : R_SFX_DEFAULTS.loseLife,
                    collectPowerup: dataToDecode.sfx?.scp !== undefined ? dataToDecode.sfx.scp : R_SFX_DEFAULTS.collectPowerup
                },
                events: []
            };

            dataToDecode.e.forEach(eventArr => {
                const t = eventArr[0];
                const typeCode = eventArr[1];
                const typeStr = R_REV_EV_TYPES[typeCode];
                let verboseEvent = { t: t, type: typeStr };

                switch (typeCode) {
                    case R_EV_TYPES.MOUSE:
                        verboseEvent.x = eventArr[2];
                        verboseEvent.y = eventArr[3];
                        break;
                    case R_EV_TYPES.KEYDOWN:
                    case R_EV_TYPES.KEYUP:
                        verboseEvent.key = eventArr[2];
                        break;
                    case R_EV_TYPES.SCORE_LIVES:
                        verboseEvent.score = eventArr[2];
                        verboseEvent.lives = eventArr[3];
                        break;
                    case R_EV_TYPES.POWERUP_ACT:
                        verboseEvent.powerupType = R_PU_REV_TYPES[eventArr[2]];
                        verboseEvent.endTime = eventArr[3];
                        if (eventArr[4] !== null && eventArr[4] !== undefined) {
                            verboseEvent.color = R_REV_COLOR_NAMES[eventArr[4]];
                        }
                        if (eventArr[5] !== null && eventArr[5] !== undefined) {
                            verboseEvent.collectedBallId = eventArr[5];
                        }
                        break;
                    case R_EV_TYPES.POWERUP_DEACT:
                        verboseEvent.powerupType = R_PU_REV_TYPES[eventArr[2]];
                        break;
                    case R_EV_TYPES.BALL_SPAWN:
                        verboseEvent.id = eventArr[2];
                        verboseEvent.dropperId = eventArr[3];
                        verboseEvent.isPowerup = eventArr[4] === 1;
                        const colorNameSpawn = R_REV_COLOR_NAMES[eventArr[5]];
                        verboseEvent.colorName = colorNameSpawn;
                        if (verboseEvent.isPowerup) verboseEvent.colorHex = POWERUP_BALL_COLOR_HEX;
                        else if (colorNameSpawn === 'white') verboseEvent.colorHex = WHITE_BALL_COLOR_HEX;
                        else verboseEvent.colorHex = BALL_COLORS[R_COLOR_CODES[colorNameSpawn]];
                        verboseEvent.fallSpeedFactor = eventArr[6];
                        verboseEvent.sizeMultiplier = eventArr[7];
                        verboseEvent.swayTime = eventArr[8];
                        verboseEvent.vx_sway_direction = eventArr[9] === 1 ? 1 : -1;
                        break;
                    case R_EV_TYPES.BALL_DESPAWN:
                        verboseEvent.ballId = eventArr[2];
                        verboseEvent.reason = R_REV_DESPAWN_REASONS[eventArr[3]];
                        break;
                    case R_EV_TYPES.GAME_END:
                        break;
                    default: return; // Skip unknown event types
                }
                verbose.events.push(verboseEvent);
            });
            return verbose;
        } else if (dataToDecode.events && Array.isArray(dataToDecode.events)) {
            // Fallback: if 'e' is missing but 'events' (verbose) exists for current version (should not happen with proper encoding)
            console.warn("Replay tagged as current version but using verbose 'events' array instead of compact 'e'. Attempting to parse as verbose.");
            const parsedData = { ...dataToDecode };
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
            if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                 parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800);
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);

            if (typeof parsedData.gameMode === 'number') {
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gameMode] || 'classic';
            } else if (typeof parsedData.gm === 'number') { // Check for old compact key 'gm'
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
                 delete parsedData.gm;
            } else if (!parsedData.gameMode) {
                parsedData.gameMode = 'classic';
            }

            // Ensure cosmetics and sfx objects exist and are defaulted
            parsedData.cosmetics = { ...R_COSMETIC_DEFAULTS, ...(parsedData.cosmetics || {}) };
            parsedData.sfx = { ...R_SFX_DEFAULTS, ...(parsedData.sfx || {}) };

            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error("Invalid current version replay data: 'e' (compact events) or 'events' (verbose events) properties are missing or not valid arrays.", dataToDecode);
            return null;
        }
    // --- Older Version (V2) Specific Handling (Example) ---
    } else if (dataToDecode.v === 2) {
        if (dataToDecode.events && Array.isArray(dataToDecode.events)) { // V2 was verbose
            const parsedData = { ...dataToDecode }; // Shallow copy
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
            if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800);
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);

            if (!parsedData.gameMode && typeof parsedData.gm === 'number') { // V2 might have used 'gm'
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
            } else if (!parsedData.gameMode) {
                parsedData.gameMode = 'classic'; // Default if not present
            }

            // Add default cosmetics/sfx for older replays
            parsedData.cosmetics = { ...R_COSMETIC_DEFAULTS, ...(parsedData.cosmetics || {}) };
            parsedData.sfx = { ...R_SFX_DEFAULTS, ...(parsedData.sfx || {}) };


            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error("Invalid V2 replay data: 'events' property is missing or not an array.", dataToDecode);
            return null;
        }
    // --- Fallback for other unknown or very old versions (treat as verbose if 'events' exists) ---
    } else {
        console.warn(`Replay version ${dataToDecode.v} is not ${REPLAY_FORMAT_VERSION} or V2. Attempting to treat as pass-through verbose if 'events' array exists.`);
        if (dataToDecode.events && Array.isArray(dataToDecode.events)) {
            const parsedData = { ...dataToDecode };
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
             if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800);
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);

            if (!parsedData.gameMode && typeof parsedData.gm === 'number') {
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
            } else if (!parsedData.gameMode) {
                parsedData.gameMode = 'classic';
            }

            // Add default cosmetics/sfx
            parsedData.cosmetics = { ...R_COSMETIC_DEFAULTS, ...(parsedData.cosmetics || {}) };
            parsedData.sfx = { ...R_SFX_DEFAULTS, ...(parsedData.sfx || {}) };


            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error(`Unsupported replay version ${dataToDecode.v} or 'events' array missing for pass-through.`, dataToDecode);
            return null;
        }
    }
}

function fnStopRP() {
    console.log("[fnStopRP] Called.");
    if(rAnimId)cancelAnimationFrame(rAnimId); rAnimId=null;
    rVState.activeReplay=null; rVState.isPlaying=false;
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    uiOverlayElem.classList.remove('replay-mode');
    powerupIconsContainerElem.classList.remove('replay-mode');
    replayControlsContainerElem.style.display='none';
    fnSetReplayButtonIcon(false);
    gameModeActive=false;
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;
    balls.length = 0;
    for (const type in activePowerups) {
        activePowerups[type].active = false;
        activePowerups[type].endTime = 0;
        if (type === 'oneColor') activePowerups.oneColor.color = null;
    }
    cBktWR = _BBWRN;
    cBllSS = _OBSS;
    rVState.isReplayDoublePointsActive = false;

    if (gameScreenDeleteReplayBtnInOverlay) {
        console.log("[fnStopRP] Setting delete button display to 'none'. Current display:", gameScreenDeleteReplayBtnInOverlay.style.display);
        gameScreenDeleteReplayBtnInOverlay.style.display = 'none';
        console.log("[fnStopRP] Delete button display after setting:", gameScreenDeleteReplayBtnInOverlay.style.display);
    } else {
         console.error("[fnStopRP] gameScreenDeleteReplayBtnInOverlay element is NOT found!");
    }


    fnUPI();
    if (rVState.originalEquippedCosmetics) {
        currentEquippedCosmetics = { ...rVState.originalEquippedCosmetics };
        delete rVState.originalEquippedCosmetics;
    } else {
        currentEquippedCosmetics = { ...R_COSMETIC_DEFAULTS, ...R_SFX_DEFAULTS };
    }
    fnSCS();
    console.log("[fnStopRP] Finished.");
}


function fnRecordBallSpawnEvent(ballData) {
    if (cRepData && !rVState.activeReplay) {
        
        const roundedBallData = { ...ballData };
        roundedBallData.fallSpeedFactor = parseFloat(ballData.fallSpeedFactor.toFixed(5));
        roundedBallData.sizeMultiplier = parseFloat(ballData.sizeMultiplier.toFixed(5));
        roundedBallData.swayTime = parseFloat(ballData.swayTime.toFixed(5));
        
        cRepData.events.push({
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: 'ballSpawn',
            ...roundedBallData 
        });
    }
}

function fnRecordBallDespawnEvent(ballId, despawnTime, reason) {
    if (cRepData && !rVState.activeReplay) {
        cRepData.events.push({
            t: parseFloat(despawnTime.toFixed(1)),
            type: 'ballDespawn',
            ballId: ballId,
            reason: reason 
        });
    }
}


function fnSCR() {
    const btnTextSpan = saveReplayBtnElem.querySelector('.btn-text');
    let currentButtonText = btnTextSpan ? btnTextSpan.textContent : saveReplayBtnElem.textContent;

    const MAX_REPLAYS_PER_MODE = 50;

    if (saveReplayBtnElem.classList.contains('saved') && !currentButtonText.includes("Watch Replay")) {
        return;
    }
    if (currentButtonText.includes("Watch Replay")) {
         return;
    }

    if (!cRepData || !cRepData.events || cRepData.events.length === 0) {
        if (!currentButtonText.includes("Limit Reached")) {
            updateButtonText(saveReplayBtnElem, "No Data to Save");
            saveReplayBtnElem.classList.remove('limit-reached');
            saveReplayBtnElem.classList.remove('watch-mode'); // Clear watch-mode
            setTimeout(() => {
                const updatedBtnTextAfterNoData = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (updatedBtnTextAfterNoData.includes("No Data to Save") && !updatedBtnTextAfterNoData.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                    updateButtonText(saveReplayBtnElem, "Save Replay");
                }
            }, 2000);
        }
        return;
    }

    const modeForSaveAttempt = cRepData.gameMode;
    const gameModeCompactCode = R_GM_MAP[modeForSaveAttempt];
    const existingReplaysInMode = sReps.filter(r => r.gm === gameModeCompactCode).length;

    if (existingReplaysInMode >= MAX_REPLAYS_PER_MODE) {
        const modeNameReadable = modeForSaveAttempt.charAt(0).toUpperCase() + modeForSaveAttempt.slice(1);
        fnShowReplayLimitNotification(`${modeNameReadable} Replays Full! (${MAX_REPLAYS_PER_MODE}/${MAX_REPLAYS_PER_MODE})`);
        currentButtonText = btnTextSpan ? btnTextSpan.textContent : saveReplayBtnElem.textContent;
        if (!currentButtonText.includes("Limit Reached")) {
            updateButtonText(saveReplayBtnElem, "Limit Reached");
            saveReplayBtnElem.classList.add('limit-reached');
            saveReplayBtnElem.classList.remove('saved');
            saveReplayBtnElem.classList.remove('watch-mode'); // Clear watch-mode
        }
        return;
    } else {
        saveReplayBtnElem.classList.remove('limit-reached');
    }

    const replayIdForThisSave = Date.now() + '_S_FN_' + Math.floor(fnSRnd() * 100000);
    lastSavedReplayId = replayIdForThisSave;

    const verboseReplay = {
        v: -1,
        id: replayIdForThisSave,
        gameSeed: cRepData.seed,
        gameMode: cRepData.gameMode,
        timestamp: cRepData.gameEndTimestampForHS,
        finalScore: cRepData.finalGameScore,
        finalTimeMs: cRepData.finalTimeMs,
        finalTimeStr: fnFT(cRepData.finalTimeMs),
        originalGameWidth: gameWidth,
        originalGameHeight: gameHeight,
        cosmetics: cRepData.cosmetics,
        sfx: cRepData.sfx,
        events: cRepData.events
    };

    const compactReplay = fnEncodeReplayData(verboseReplay);
    sReps.push(compactReplay);
    let replaySaveError = false;
    try {
        localStorage.setItem('orbilaReplays', JSON.stringify(sReps));
    } catch (e) {
        console.error("fnSCR: Error writing replays to localStorage:", e);
        replaySaveError = true;
        sReps.pop();
        lastSavedReplayId = null;
    }

    if (!replaySaveError) {
        let highScores = fnGHS();
        const scoreToMatch = cRepData.finalGameScore;
        const modeToMatch = cRepData.gameMode;
        const timestampToMatch = cRepData.gameEndTimestampForHS;

        let foundHsIndex = -1;
        for (let i = 0; i < highScores.length; i++) {
            const hsEntry = highScores[i];
            if (hsEntry.mode === modeToMatch &&
                hsEntry.score === scoreToMatch &&
                hsEntry.timestamp === timestampToMatch &&
                hsEntry.replayId === null
            ) {
                foundHsIndex = i;
                break;
            }
        }

        if (foundHsIndex !== -1) {
            highScores[foundHsIndex].replayId = lastSavedReplayId;
            try {
                localStorage.setItem('highScores', JSON.stringify(highScores));
            } catch (e) {
                console.error("fnSCR: Error updating HS with replayId in localStorage:", e);
            }
        }

        updateButtonText(saveReplayBtnElem, "Replay Saved!");
        saveReplayBtnElem.classList.add('saved');
        saveReplayBtnElem.classList.remove('limit-reached');
        saveReplayBtnElem.classList.remove('watch-mode'); // Ensure watch-mode is off for "Replay Saved!"

        lastSavedReplayIdToWatch = lastSavedReplayId;

        setTimeout(() => {
            const stillThisSavedContext = saveReplayBtnElem.classList.contains('saved') &&
                                      lastSavedReplayIdToWatch === lastSavedReplayId &&
                                      (saveReplayBtnElem.querySelector('.btn-text')?.textContent.includes("Replay Saved!") || saveReplayBtnElem.textContent.includes("Replay Saved!"));

            if (stillThisSavedContext) {
                updateButtonText(saveReplayBtnElem, "Watch Replay");
                saveReplayBtnElem.classList.add('watch-mode'); // <<< ADD watch-mode CLASS HERE
                // The 'saved' class keeps it green. 'watch-mode' enables hover.
            }
        }, 850);

        cRepData = null;
    } else {
        updateButtonText(saveReplayBtnElem, "Save Failed");
        saveReplayBtnElem.classList.remove('saved');
        saveReplayBtnElem.classList.remove('limit-reached');
        saveReplayBtnElem.classList.remove('watch-mode'); // Clear watch-mode
        lastSavedReplayIdToWatch = null;
        setTimeout(() => {
            const updatedBtnTextAfterFail = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
            if (updatedBtnTextAfterFail.includes("Save Failed") && !updatedBtnTextAfterFail.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                updateButtonText(saveReplayBtnElem, "Save Replay");
            }
        }, 2000);
    }
}

function fnLRS() {
    const sr = localStorage.getItem('orbilaReplays');
    sReps = []; 

    if (sr) {
        try {
            let parsedReplays = JSON.parse(sr);
            if (Array.isArray(parsedReplays)) {
                parsedReplays.forEach(r_compact => {
                    if (r_compact && 
                        typeof r_compact.v === 'number' &&
                        (r_compact.i || r_compact.id) &&   
                        typeof r_compact.gs === 'number' && 
                        typeof r_compact.gm === 'number' && 
                        typeof r_compact.ts === 'number' && 
                        typeof r_compact.fs === 'number' && 
                        typeof r_compact.ft === 'number' && 
                        Array.isArray(r_compact.e)          
                        ) {
                        sReps.push(r_compact); 
                    } else {
                        // console.warn("fnLRS: Filtering out invalid or incomplete replay object from localStorage:", r_compact); // Optional: Keep if you want to see these warnings
                    }
                });
            } else {
                console.error("fnLRS: Parsed data from localStorage is not an array:", parsedReplays); // Keep for critical errors
            }
        } catch (e) {
            console.error("fnLRS: Error parsing replays from localStorage:", e); // Keep for critical errors
            sReps = []; 
        }
    }
}

let rDelData = null; // Store more than just ID
let modeToDeleteFromReplays = null;

function fnSDRC(replayId, replayTimestamp, replayMode) { // <<< MODIFIED SIGNATURE
    rDelData = { id: replayId, timestamp: replayTimestamp, mode: replayMode }; // <<< STORE MORE INFO
    deleteReplayConfirmationDialog.style.display = 'flex';
    fnPS('click');
}
 
function fnHDRC() {
    deleteReplayConfirmationDialog.style.display = 'none';
    rDelData = null; // NEW
    fnPS('click');
}

function fnCDR() {
    if (rDelData !== null && rDelData.id !== null) {
        const replayIdBeingDeleted = rDelData.id;

        sReps = sReps.filter(r => r.i !== rDelData.id);
        try {
            localStorage.setItem('orbilaReplays', JSON.stringify(sReps));

            if (rDelData.timestamp !== undefined && rDelData.mode !== undefined) {
                saveSharedNote(rDelData.timestamp, rDelData.mode, "");
            } else {
                console.warn("Attempting to delete shared note for replay but timestamp/mode missing from rDelData. Note might persist if not directly cleared via fnSDRC params.");
            }

            let highScores = fnGHS();
            highScores = highScores.map(hs => {
                if (hs.replayId === rDelData.id) {
                    return { ...hs, replayId: null };
                }
                return hs;
            });
            localStorage.setItem('highScores', JSON.stringify(highScores));

        } catch (e) {
            console.error("Error saving after delete:", e);
        }

        fnHDRC(); // Hide dialog first, also clears rDelData

        if (rVState.activeReplay && rVState.activeReplay.id === replayIdBeingDeleted) {
            fnStopRP(); // Stop the current replay if it was the one deleted

            // Navigation logic: Go back to the screen at the top of the stack
            const targetScreen = screenStack.length > 0 ? screenStack[screenStack.length - 1] : 'home';
            // We don't pop here if replayViewer wasn't pushed. fnSS will handle showing the correct screen.
            // If the previous screen was 'replays' or 'highScores', it should still be at the top of screenStack.
            fnSS(targetScreen);

            // If the target screen is now active and is 'replays' or 'highScores', refresh its list.
            if (screens[targetScreen]?.classList.contains('active')) {
                if (targetScreen === 'replays') {
                    fnDRpsL();
                } else if (targetScreen === 'highScores') {
                    fnDHS();
                }
            }

        } else {
            // If the deleted replay wasn't the one being viewed (e.g., deleted from Replays list)
            if (screens.replays.classList.contains('active')) {
                fnDRpsL();
            } else if (screens.highScores.classList.contains('active')) {
                fnDHS();
            }
        }
    } else {
      fnHDRC();
    }
}

function fnRecordScoreLivesUpdate() {
    if (cRepData && !rVState.activeReplay) { 
        cRepData.events.push({
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: 'scoreLivesUpdate',
            score: score,
            lives: lives
        });
    }
}

function fnRecordPowerupEvent(type, powerupData) {
    if (cRepData && !rVState.activeReplay) {
        const eventData = {
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: type, 
            ...powerupData
        };
        if (powerupData.endTime) {
            eventData.endTime = parseFloat(powerupData.endTime.toFixed(1));
        }
        cRepData.events.push(eventData);
    }
}

function fnACWP(x, y, currentTimeForLogic) { // Added currentTimeForLogic
    const currentTrailType = currentEquippedCosmetics.trailCW;
    const dx = x - prevPlayerCursorPos.x;
    const dy = y - prevPlayerCursorPos.y;
    const distSq = dx * dx + dy * dy;
    const cursorSpeed = Math.sqrt(distSq) / (_PCOR * 0.1);

    let shouldAttemptSpawn = true;

    const defaultVelocityMagnitude = _PCOR * 0.9;
    let defaultInitialVx = (fnSRnd() - 0.5) * 2 * defaultVelocityMagnitude;
    let defaultInitialVy = (fnSRnd() - 0.5) * 2 * defaultVelocityMagnitude;
    let defaultInitialRadius = (fnSRnd() * 0.07 + 0.03) * _PCOR;
    let defaultInitialAlphaValue = 0.25 + fnSRnd() * 0.4;
    let defaultInitialLifespan = 0.4 + fnSRnd() * 0.4;

    let particle = {
        x: x + (fnSRnd() - 0.5) * _PCOR * 0.2,
        y: y + (fnSRnd() - 0.5) * _PCOR * 0.2,
        radius: defaultInitialRadius,
        alpha: defaultInitialAlphaValue,
        color: 'rgba(220,220,255,1)',
        vx: defaultInitialVx,
        vy: defaultInitialVy,
        lifespan: defaultInitialLifespan,
        rotation: 0,
        angularVelocity: 0,
        shape: 'circle',
        customData: { initialAlpha: defaultInitialAlphaValue }
    };
    let particlesToSpawnThisCall = 0;

    // Use currentTimeForLogic if provided, otherwise fallback to existing logic for time
    const effectiveCurrentTime = (currentTimeForLogic !== undefined)
        ? currentTimeForLogic
        : (rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs);

    switch (currentTrailType) {
        case "default":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.6) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) particlesToSpawnThisCall = 1;
            break;

        case "dust":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.25) {
                 shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                const largeDustSpawnChance_dust = 0.2;
                const isLargeDustParticle_dust = fnSRnd() < largeDustSpawnChance_dust;
                let actualDustRadius_dust, actualDustAlpha_dust, actualDustLifespan_dust, actualDustVx_dust, actualDustVy_dust;
                const dustBaseVelocity_dust = defaultVelocityMagnitude * 0.4;
                if (isLargeDustParticle_dust) {
                    actualDustRadius_dust = _PCOR * (.20 + fnSRnd() * 0.12);
                    actualDustAlpha_dust = 0.025 + fnSRnd() * 0.035;
                    actualDustLifespan_dust = 25.0 + fnSRnd() * 1.0;
                    actualDustVx_dust = (fnSRnd() - 0.5) * 2 * dustBaseVelocity_dust * 0.6;
                    actualDustVy_dust = (fnSRnd() - 0.5) * 2 * dustBaseVelocity_dust * 0.6;
                } else {
                    actualDustRadius_dust = _PCOR * (0.010 + fnSRnd() * 0.095);
                    actualDustAlpha_dust = 0.25 + fnSRnd() * 0.40;
                    actualDustLifespan_dust = 1.4 + fnSRnd() * 0.8;
                    actualDustVx_dust = (fnSRnd() - 0.5) * 2 * dustBaseVelocity_dust;
                    actualDustVy_dust = (fnSRnd() - 0.5) * 2 * dustBaseVelocity_dust;
                }
                const dustColorPalettes_dust = [
                    { r: 160, g: 130, b: 100 }, { r: 140, g: 120, b: 100 }, { r: 175, g: 155, b: 135 },
                    { r: 135, g: 135, b: 125 }, { r: 145, g: 140, b: 135 }, { r: 110, g: 100, b: 90 }
                ];
                const selectedPalette_dust = dustColorPalettes_dust[Math.floor(fnSRnd() * dustColorPalettes_dust.length)];
                const colorVariation_dust = 15;
                let pr_dust = Math.max(0, Math.min(255, selectedPalette_dust.r + Math.floor((fnSRnd() - 0.5) * colorVariation_dust * 2)));
                let pg_dust = Math.max(0, Math.min(255, selectedPalette_dust.g + Math.floor((fnSRnd() - 0.5) * colorVariation_dust * 2)));
                let pb_dust = Math.max(0, Math.min(255, selectedPalette_dust.b + Math.floor((fnSRnd() - 0.5) * colorVariation_dust * 2)));
                const dustParticleColorString_dust = `rgba(${pr_dust},${pg_dust},${pb_dust},1)`;
                particle.x = x + (fnSRnd() - 0.5) * _PCOR * 0.15;
                particle.y = y + (fnSRnd() - 0.5) * _PCOR * 0.15;
                particle.radius = actualDustRadius_dust;
                particle.alpha = actualDustAlpha_dust;
                particle.color = dustParticleColorString_dust;
                particle.vx = actualDustVx_dust;
                particle.vy = actualDustVy_dust;
                particle.lifespan = actualDustLifespan_dust;
                particle.rotation = 0;
                particle.angularVelocity = 0;
                particle.shape = 'circle';
                particle.customData = { initialAlpha: actualDustAlpha_dust };
            }
            break;

        case "smoke":
            const smokeParticlesPerSecond = 35;
            const smokeIntervalMs = 1000 / smokeParticlesPerSecond;
            if (effectiveCurrentTime >= (rateBasedTrailNextSpawnTime["smoke"] || 0) ) { // Use effectiveCurrentTime
                particlesToSpawnThisCall = 1;
                rateBasedTrailNextSpawnTime["smoke"] = effectiveCurrentTime + smokeIntervalMs; // Use effectiveCurrentTime
                const largeSmokeSpawnChance_smoke = 0.35;
                const isLargeSmokeParticle_smoke = fnSRnd() < largeSmokeSpawnChance_smoke;
                let actualSmokeRadius_smoke, actualSmokeAlpha_smoke, actualSmokeLifespan_smoke, actualSmokeVx_smoke, actualSmokeVy_smoke;
                let growthRate_smoke, maxGrowthRadius_smoke;
                const darkGrayVal_smoke = 0x26;
                const lightGrayVal_smoke = 0x78;
                const grayRange_smoke = lightGrayVal_smoke - darkGrayVal_smoke;
                const smokeBaseVelocityY_smoke = -_PCOR * 0.18;
                const smokeSideDrift_smoke = _PCOR * 0.04;

                if (isLargeSmokeParticle_smoke) {
                    actualSmokeRadius_smoke = _PCOR * (0.25 + fnSRnd() * 0.3);
                    actualSmokeAlpha_smoke = 0.15 + fnSRnd() * 0.12;
                    actualSmokeLifespan_smoke = 3.5 + fnSRnd() * 2.0;
                    growthRate_smoke = _PCOR * (0.035 + fnSRnd() * 0.035);
                    maxGrowthRadius_smoke = actualSmokeRadius_smoke + _PCOR * (0.30 + fnSRnd() * 0.25);
                    actualSmokeVx_smoke = (fnSRnd() - 0.5) * 2 * smokeSideDrift_smoke * 0.8;
                    actualSmokeVy_smoke = smokeBaseVelocityY_smoke * (1.7 + fnSRnd() * 0.4);
                } else {
                    actualSmokeRadius_smoke = _PCOR * (0.0 + fnSRnd() * 0.20);
                    actualSmokeAlpha_smoke = 0.75 + fnSRnd() * 0.20;
                    actualSmokeLifespan_smoke = 2.0 + fnSRnd() * 1.5;
                    growthRate_smoke = _PCOR * (0.025 + fnSRnd() * 0.025);
                    maxGrowthRadius_smoke = actualSmokeRadius_smoke + _PCOR * (0.15 + fnSRnd() * 0.20);
                    actualSmokeVx_smoke = (fnSRnd() - 0.5) * 2 * smokeSideDrift_smoke;
                    actualSmokeVy_smoke = smokeBaseVelocityY_smoke * (1.9 + fnSRnd() * 0.3);
                }
                const smokeShadeDecimal_smoke = Math.floor(darkGrayVal_smoke + fnSRnd() * grayRange_smoke);
                const smokeParticleColorString_smoke = `rgba(${smokeShadeDecimal_smoke},${smokeShadeDecimal_smoke},${smokeShadeDecimal_smoke},1)`;
                particle.x = x + (fnSRnd() - 0.5) * _PCOR * 0.1;
                particle.y = y + (fnSRnd() - 0.5) * _PCOR * 0.1;
                particle.radius = actualSmokeRadius_smoke;
                particle.alpha = actualSmokeAlpha_smoke;
                particle.color = smokeParticleColorString_smoke;
                particle.vx = actualSmokeVx_smoke;
                particle.vy = actualSmokeVy_smoke;
                particle.lifespan = actualSmokeLifespan_smoke;
                particle.rotation = 0;
                particle.angularVelocity = 0;
                particle.shape = 'circle';
                particle.customData = {
                    initialAlpha: actualSmokeAlpha_smoke,
                    growthRate: growthRate_smoke,
                    maxRadius: maxGrowthRadius_smoke,
                    initialRadius: actualSmokeRadius_smoke
                };
            }
            break;

        case "bubbles":
            const bubblesParticlesPerSecond = 8;
            const bubblesIntervalMs = 1000 / bubblesParticlesPerSecond;
            if (effectiveCurrentTime >= (rateBasedTrailNextSpawnTime["bubbles"] || 0) ) { // Use effectiveCurrentTime
                particlesToSpawnThisCall = 1;
                rateBasedTrailNextSpawnTime["bubbles"] = effectiveCurrentTime + bubblesIntervalMs; // Use effectiveCurrentTime
                particle.radius = (fnSRnd() * 0.1 + 0.07) * _PCOR;
                const blueShades_bubbles = [
                    {r:150, g:200, b:255}, {r:120, g:180, b:250}, {r:100, g:160, b:240},
                    {r:170, g:220, b:255}, {r:90, g:150, b:230}
                ];
                const baseBubbleColor_bubbles = blueShades_bubbles[Math.floor(fnSRnd() * blueShades_bubbles.length)];
                const baseBubbleInitialAlpha_bubbles = 0.1 + fnSRnd() * 0.15;
                particle.color = `rgba(${baseBubbleColor_bubbles.r},${baseBubbleColor_bubbles.g},${baseBubbleColor_bubbles.b},${baseBubbleInitialAlpha_bubbles})`;
                particle.alpha = 1.0;
                particle.customData.initialAlpha = 1.0;
                particle.customData.highlightColor = `rgba(${Math.min(255,baseBubbleColor_bubbles.r+30)},${Math.min(255,baseBubbleColor_bubbles.g+30)},255,${baseBubbleInitialAlpha_bubbles + 0.1})`;
                particle.vx = (fnSRnd() - 0.5) * 0.003 * _PCOR;
                particle.vy = (-0.004 - fnSRnd() * 0.005) * _PCOR;
                particle.lifespan = 1.5 + fnSRnd() * 1.2;
                particle.customData.swayTime = fnSRnd() * Math.PI * 2; // Renamed from wobbleTime for bubbles
                particle.customData.swayAmount = (0.015 + fnSRnd() * 0.01) * _PCOR;
                particle.customData.swaySpeed = (1.5 + fnSRnd() * 1.0);
            }
            break;

        case "lingeringGlow":
            const lingeringGlowParticlesPerSecond = 10;
            const lingeringGlowIntervalMs = 1000 / lingeringGlowParticlesPerSecond;
            if (effectiveCurrentTime >= (rateBasedTrailNextSpawnTime["lingeringGlow"] || 0) ) { // Use effectiveCurrentTime
                particlesToSpawnThisCall = 1;
                rateBasedTrailNextSpawnTime["lingeringGlow"] = effectiveCurrentTime + lingeringGlowIntervalMs; // Use effectiveCurrentTime
                particle.shape = 'glow';
                particle.customData.hue = fnSRnd() * 360;
                particle.color = `hsla(${particle.customData.hue}, 90%, 70%, 1)`;
                particle.alpha = 0.025 + fnSRnd() * 0.025;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.coreColor = `hsla(${particle.customData.hue}, 100%, 85%, 1)`;
                particle.radius = (fnSRnd() * 0.3 + 0.1) * _PCOR;
                particle.vx = (fnSRnd() - 0.5) * 0.001 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.001 * _PCOR;
                particle.lifespan = 1.8 + fnSRnd() * 1.5;
                particle.customData.growthRate = (0.001 + fnSRnd() * 0.001) * _PCOR;
            }
            break;
        case "fire":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.15) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                const distFromCenter_fire = Math.sqrt((particle.x - x)*(particle.x - x) + (particle.y - y)*(particle.y - y)) / (_PCOR * 0.2);
                const yellowBias_fire = Math.max(0, 1 - distFromCenter_fire * 1.5);
                let fireAlphaValue_fire;

                if (fnSRnd() < 0.2) {
                    particle.color = `rgba(200,0,0,1)`;
                    fireAlphaValue_fire = 0.6 + fnSRnd()*0.2;
                    particle.radius = (fnSRnd() * 0.015 + 0.01) * _PCOR;
                    particle.vx = (fnSRnd() - 0.5) * 0.015 * _PCOR;
                    particle.vy = (fnSRnd() - 0.5) * 0.015 * _PCOR;
                    particle.lifespan = 0.8 + fnSRnd() * 0.6;
                } else {
                    const r_fire = 255;
                    const g_fire = Math.floor(100 + 100 * yellowBias_fire + fnSRnd() * 50 * (1-yellowBias_fire));
                    const b_fire = Math.floor(0 + 50 * yellowBias_fire * fnSRnd());
                    particle.color = `rgba(${r_fire},${g_fire},${b_fire},1)`;
                    fireAlphaValue_fire = 0.45 + fnSRnd()*0.25;
                    particle.radius = (fnSRnd() * 0.055 + 0.035) * _PCOR;
                    particle.vx = (fnSRnd() - 0.5) * 0.008 * _PCOR;
                    particle.vy = (-0.009 - fnSRnd() * 0.014) * _PCOR;
                    particle.lifespan = 0.25 + fnSRnd() * 0.35;
                }
                particle.alpha = fireAlphaValue_fire;
                particle.customData.initialAlpha = fireAlphaValue_fire;
            }
            break;
        case "sparkler":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.08) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'customSparkler';
                const sparklerBaseColors_sparkler = ['rgba(255,100,0,', 'rgba(255,170,0,', 'rgba(255,230,80,'];
                particle.color = sparklerBaseColors_sparkler[Math.floor(fnSRnd()*sparklerBaseColors_sparkler.length)] + `1)`;
                particle.alpha = 0.9 + fnSRnd()*0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.numLines = Math.floor(fnSRnd() * 3) + 2;
                particle.customData.initialLength = (0.15 + fnSRnd() * 0.3) * _PCOR;
                particle.customData.currentLength = particle.customData.initialLength;
                particle.customData.initialWidth = (0.03 + fnSRnd() * 0.025) * _PCOR;
                particle.customData.currentWidth = particle.customData.initialWidth;
                particle.radius = particle.customData.initialWidth;
                particle.vx = (fnSRnd() - 0.5) * 0.1 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.1 * _PCOR;
                particle.lifespan = 0.2 + fnSRnd() * 0.25;
                particle.rotation = fnSRnd() * Math.PI * 2;
                particle.customData.lineAngles = [];
                for(let k=0; k < particle.customData.numLines; k++){
                    particle.customData.lineAngles.push(k * (Math.PI / particle.customData.numLines) + (fnSRnd()-0.5)*0.2);
                }
            }
            break;
        case "rainbow":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.6) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.customData.hue = fnSRnd() * 360;
                particle.color = `hsla(${particle.customData.hue}, 100%, 70%, 1)`;
                particle.alpha = defaultInitialAlphaValue;
                particle.customData.initialAlpha = defaultInitialAlphaValue;
            }
            break;
        case "simpleLines":
            if (distSq > MIN_CURSOR_MOVE_THRESHOLD_SQ * 0.5) {
                 particlesToSpawnThisCall = 1;
                 particle.shape = 'fruitNinjaSegment';
                 particle.startX = prevPlayerCursorPos.x;
                 particle.startY = prevPlayerCursorPos.y;
                 particle.endX = x;
                 particle.endY = y;
                 particle.alpha = 0.7;
                 particle.customData.initialAlpha = 0.7;
                 particle.color = `rgba(220,230,255,1)`;
                 particle.lineWidth = (_PCOR * 0.08 + fnSRnd() * _PCOR * 0.05) * Math.min(1, 0.2 + cursorSpeed * 0.5);
                 particle.lifespan = 0.4 + fnSRnd() * 0.2;
                 particle.creationTime = performance.now();
                 particle.vx = 0;
                 particle.vy = 0;
            }
            break;
        case "magic":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.3) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                const starChance_magic = 0.15;
                const yellowStarBias_magic = 0.2;
                let magicAlpha_magic;
                if (fnSRnd() < starChance_magic) {
                    particle.shape = 'star';
                    const isYellowStar = fnSRnd() < yellowStarBias_magic;
                    particle.color = isYellowStar ? `rgba(255,230,100,1)` : `rgba(220,150,255,1)`;
                    magicAlpha_magic = isYellowStar ? (0.8 + fnSRnd() * 0.2) : (0.7 + fnSRnd() * 0.3);
                    particle.radius = (fnSRnd() * 0.12 + 0.10) * _PCOR;
                    particle.customData.spikes = 5;
                    particle.customData.innerRadius = particle.radius * 0.4;
                    particle.rotation = fnSRnd() * Math.PI * 2;
                    particle.angularVelocity = (fnSRnd() - 0.5) * 0.1;
                } else {
                    particle.color = `rgba(150,100,255,1)`;
                    magicAlpha_magic = 0.3 + fnSRnd() * 0.2;
                    particle.radius = (fnSRnd() * 0.07 + 0.05) * _PCOR;
                }
                particle.alpha = magicAlpha_magic;
                particle.customData.initialAlpha = magicAlpha_magic;
                particle.vx = (fnSRnd() - 0.5) * 0.006 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.006 * _PCOR;
                particle.lifespan = 0.5 + fnSRnd() * 0.5;
            }
            break;
        case "sparkles":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.25) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'star';
                particle.color = `rgba(255,255,255,1)`;
                particle.alpha = 0.9 + fnSRnd() * 0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.glowColor = `rgba(255,255,230,0.35)`;
                particle.radius = (fnSRnd() * 0.07 + 0.06) * _PCOR;
                particle.customData.spikes = 4 + Math.floor(fnSRnd() * 2);
                particle.customData.innerRadius = particle.radius * (0.3 + fnSRnd() * 0.2);
                particle.vx = (fnSRnd() - 0.5) * 0.02 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.02 * _PCOR;
                particle.lifespan = 0.4 + fnSRnd() * 0.3;
                particle.rotation = fnSRnd() * Math.PI * 2;
            }
            break;
        case "aurora":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.15) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'auroraGlow';
                const auroraColors_aurora = [
                    {r:80, g:200, b:120}, {r:120, g:80, b:200}, {r:180, g:80, b:160},
                    {r:70, g:180, b:220}, {r:200, g:100, b:80}
                ];
                const baseAuroraColor_aurora = auroraColors_aurora[Math.floor(fnSRnd() * auroraColors_aurora.length)];
                particle.color = `rgba(${baseAuroraColor_aurora.r},${baseAuroraColor_aurora.g},${baseAuroraColor_aurora.b},1)`;
                particle.alpha = 0.1 + fnSRnd() * 0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.lineColor = `rgba(230,240,255,${0.03 + fnSRnd()*0.02})`;
                const movementAngle_aurora = Math.atan2(dy, dx);
                particle.rotation = movementAngle_aurora + Math.PI / 2;
                const speedFactor_aurora = Math.min(2.0, 0.5 + cursorSpeed * 0.5);
                particle.customData.ellipseRx = (0.4 + fnSRnd() * 0.3) * _PCOR * (dy === 0 ? speedFactor_aurora : 1/speedFactor_aurora);
                particle.customData.ellipseRy = (0.4 + fnSRnd() * 0.3) * _PCOR * (dx === 0 ? speedFactor_aurora : 1/speedFactor_aurora);
                particle.radius = Math.max(particle.customData.ellipseRx, particle.customData.ellipseRy);
                particle.vx = (fnSRnd() - 0.5) * 0.001 * _PCOR * (1 + cursorSpeed * 0.1);
                particle.vy = ((fnSRnd() - 0.5) * 0.001 - 0.0004) * _PCOR * (1 + cursorSpeed * 0.1);
                particle.lifespan = 1.5 + fnSRnd() * 1.0;
                particle.customData.waveTime = fnSRnd() * Math.PI * 2;
                particle.customData.waveAmp = (0.1 + fnSRnd() * 0.2) * _PCOR;
                particle.customData.initialRadius = particle.radius;
            }
            break;
        case "confetti":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.08) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'rect';
                const confettiColors_confetti = [
                    {r:255,g:100,b:100},{r:100,g:255,b:100},{r:100,g:100,b:255},
                    {r:255,g:255,b:100},{r:255,g:100,b:255},{r:100,g:255,b:255},
                    {r:255,g:180,b:100},{r:180,g:100,b:255},{r:100,g:255,b:180}
                ];
                const chosenConfetti_confetti = confettiColors_confetti[Math.floor(fnSRnd() * confettiColors_confetti.length)];
                particle.color = `rgba(${chosenConfetti_confetti.r},${chosenConfetti_confetti.g},${chosenConfetti_confetti.b},1)`;
                particle.alpha = 0.9 + fnSRnd() * 0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.width = (0.06 + fnSRnd() * 0.08) * _PCOR;
                particle.customData.height = (0.1 + fnSRnd() * 0.1) * _PCOR;
                particle.radius = particle.customData.height;
                particle.vx = (fnSRnd() - 0.5) * 0.015 * _PCOR;
                particle.vy = (0.005 + fnSRnd() * 0.01) * _PCOR;
                particle.rotation = fnSRnd() * Math.PI * 2;
                particle.angularVelocity = (fnSRnd() - 0.5) * 0.3;
                particle.lifespan = 1.2 + fnSRnd() * 1.0;
                particle.customData.flutterTime = fnSRnd() * Math.PI * 2;
                particle.customData.flutterAmount = (fnSRnd() - 0.5) * 0.01 * _PCOR;
            }
            break;
        case "glitch":
            if (distSq > MIN_CURSOR_MOVE_THRESHOLD_SQ * 0.5 || fnSRnd() < 0.12) {
                 particlesToSpawnThisCall = 1;
                 particle.shape = 'glitchPixel';
                 const glitchPixelColors_glitch = ['#FF0000', '#00FF00', '#0000FF', '#FFFFFF'];
                 particle.color = glitchPixelColors_glitch[Math.floor(fnSRnd() * glitchPixelColors_glitch.length)];
                 particle.alpha = 1.0;
                 particle.customData.initialAlpha = 1.0;
                 const shapeType_glitch = fnSRnd();
                 let baseGlitchSize_glitch = (0.08 + fnSRnd() * 0.08) * _PCOR;
                 if (shapeType_glitch < 0.5) {
                     particle.customData.w = particle.customData.h = baseGlitchSize_glitch;
                 } else if (shapeType_glitch < 0.8) {
                     if (fnSRnd() < 0.5) { particle.customData.w = baseGlitchSize_glitch * 2; particle.customData.h = baseGlitchSize_glitch; }
                     else { particle.customData.w = baseGlitchSize_glitch; particle.customData.h = baseGlitchSize_glitch * 2; }
                 } else {
                     if (fnSRnd() < 0.5) { particle.customData.w = baseGlitchSize_glitch * 3; particle.customData.h = baseGlitchSize_glitch; }
                     else { particle.customData.w = baseGlitchSize_glitch; particle.customData.h = baseGlitchSize_glitch * 3; }
                 }
                 particle.radius = Math.max(particle.customData.w, particle.customData.h);
                 particle.x = x + (fnSRnd() - 0.5) * _PCOR * 0.3;
                 particle.y = y + (fnSRnd() - 0.5) * _PCOR * 0.3;
                 particle.vx = 0;
                 particle.vy = 0;
                 particle.lifespan = 0.1 + fnSRnd() * 0.1;
                 particle.customData.isGlitch = true;
            }
            break;
        case "laser":
            if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.03) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'line';
                const laserColors_laser = ['rgba(255,70,70,', 'rgba(70,255,70,', 'rgba(70,170,255,'];
                particle.color = laserColors_laser[Math.floor(fnSRnd()*laserColors_laser.length)] + `1)`;
                particle.alpha = 0.85 + fnSRnd()*0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.length = (0.45 + fnSRnd() * 0.35) * _PCOR;
                particle.radius = (0.025 + fnSRnd() * 0.02) * _PCOR;
                let angle_laser_laser = Math.atan2(-dy, -dx) + Math.PI / 2;
                if (dx === 0 && dy === 0) angle_laser_laser = fnSRnd() * Math.PI * 2;
                const speed_laser_laser = (0.12 + fnSRnd() * 0.09) * _PCOR;
                particle.vx = Math.cos(angle_laser_laser) * speed_laser_laser;
                particle.vy = Math.sin(angle_laser_laser) * speed_laser_laser;
                particle.rotation = angle_laser_laser;
                particle.lifespan = 0.12 + fnSRnd() * 0.08;
                particle.x = x; particle.y = y;
            }
            break;
        case "shadow":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.08) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.color = `rgba(10,10,15,1)`;
                particle.alpha = 0.3 + fnSRnd() * 0.25;
                particle.customData.initialAlpha = particle.alpha;
                particle.radius = (fnSRnd() * 0.09 + 0.07) * _PCOR;
                particle.vx = (fnSRnd() - 0.5) * 0.004 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.004 * _PCOR;
                particle.lifespan = 0.6 + fnSRnd() * 0.45;
                particle.customData.growthRate = (0.007 + fnSRnd() * 0.007) * _PCOR;
            }
            break;
        case "plasma":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.35) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'plasmaGlow';
                const plasmaHues_plasma = [240, 300, 200];
                particle.customData.hue = plasmaHues_plasma[Math.floor(fnSRnd() * plasmaHues_plasma.length)];
                particle.color = `hsla(${particle.customData.hue}, 90%, 60%, 1)`;
                particle.alpha = 0.15 + fnSRnd() * 0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.coreColor = `hsla(${particle.customData.hue}, 100%, 80%, 1)`;
                particle.radius = (fnSRnd() * 0.2 + 0.2) * _PCOR;
                particle.vx = (fnSRnd() - 0.5) * 0.0015 * _PCOR;
                particle.vy = (fnSRnd() - 0.5) * 0.0015 * _PCOR;
                particle.lifespan = 1.0 + fnSRnd() * 0.8;
                particle.customData.pulseTime = fnSRnd() * Math.PI * 2;
                particle.customData.currentRadius = particle.radius; // Initialize currentRadius
            }
            break;
        case "snow":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.65) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                if (fnSRnd() < 0.35) {
                    particle.shape = 'snowflake';
                    particle.customData.arms = 6;
                    particle.customData.armLength = (0.05 + fnSRnd() * 0.05) * _PCOR;
                    particle.customData.armWidth = (0.012 + fnSRnd() * 0.007) * _PCOR;
                    particle.radius = particle.customData.armLength;
                    particle.angularVelocity = (fnSRnd() - 0.5) * 0.05;
                } else {
                    particle.radius = (fnSRnd() * 0.04 + 0.03) * _PCOR;
                }
                particle.color = `rgba(225,235,255,1)`;
                particle.alpha = 0.55 + fnSRnd() * 0.3;
                particle.customData.initialAlpha = particle.alpha;
                particle.vx = (fnSRnd() - 0.5) * 0.003 * _PCOR;
                particle.vy = (0.008 + fnSRnd() * 0.009) * _PCOR;
                particle.lifespan = 1.8 + fnSRnd() * 1.2;
                particle.customData.swayTime = fnSRnd() * Math.PI * 2;
                particle.customData.swayAmount = (fnSRnd() * 0.01 + 0.005) * _PCOR;
                particle.customData.swaySpeed = (1.0 + fnSRnd() * 0.5);
            }
            break;
        case "rgbDots":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.55) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'rgbDot';
                const rgbDotColors_trail_rgb = [BALL_COLORS[0], BALL_COLORS[1], BALL_COLORS[2]];
                particle.color = rgbDotColors_trail_rgb[Math.floor(fnSRnd() * rgbDotColors_trail_rgb.length)];
                particle.alpha = 1.0;
                particle.customData.initialAlpha = 1.0;
                particle.radius = (fnSRnd() * 0.025 + 0.020) * _PCOR * (BALL_RADIUS_BASE / (_PCOR * 0.05));
                particle.lifespan = 0.35 + fnSRnd() * 0.25;
                particle.vx = defaultInitialVx;
                particle.vy = defaultInitialVy;
            }
            break;
        case "wind":
             if (distSq < MIN_CURSOR_MOVE_THRESHOLD_SQ && fnSRnd() > 0.02) {
                shouldAttemptSpawn = false;
            }
            if (shouldAttemptSpawn) {
                particlesToSpawnThisCall = 1;
                particle.shape = 'line';
                particle.color = `rgba(180,220,255,1)`;
                particle.alpha = 0.1 + fnSRnd() * 0.1;
                particle.customData.initialAlpha = particle.alpha;
                particle.customData.length = (0.25 + fnSRnd() * 0.35) * _PCOR;
                particle.radius = (0.009 + fnSRnd() * 0.009) * _PCOR;
                let windAngleBase_wind = Math.atan2(dy, dx) + Math.PI / 2;
                 if (dx === 0 && dy === 0) windAngleBase_wind = fnSRnd() * Math.PI * 2;
                particle.rotation = windAngleBase_wind + (fnSRnd() - 0.5) * 0.3;
                const windSpeed_wind = (0.09 + fnSRnd() * 0.07 + cursorSpeed * 0.004) * _PCOR;
                particle.vx = Math.cos(particle.rotation) * windSpeed_wind;
                particle.vy = Math.sin(particle.rotation) * windSpeed_wind;
                particle.lifespan = 0.2 + fnSRnd() * 0.2;
            }
            break;
    }

    if (particlesToSpawnThisCall > 0) {
        if (particle.customData.initialAlpha === undefined) {
            particle.customData.initialAlpha = particle.alpha;
        }
        colorWheelParticles.push(particle);
    }

    prevPlayerCursorPos.x = x;
    prevPlayerCursorPos.y = y;
}


function fnUCWP(d) {
    for (let i = colorWheelParticles.length - 1; i >= 0; i--) {
        const p = colorWheelParticles[i];
        p.x += p.vx * d; // MOVEMENT IS SCALED BY d
        p.y += p.vy * d; // MOVEMENT IS SCALED BY d
        p.rotation += p.angularVelocity * d;

        // Alpha update logic
        if (p.customData.isGlitch) {
            p.lifespan -= d;
            if (p.lifespan <= 0) {
                colorWheelParticles.splice(i, 1);
                continue;
            }
        } else if (p.shape === 'fruitNinjaSegment') {
            const initialAlphaFN = 0.7; // FruitNinja starts at 0.7 alpha
            if (p.lifespan > 0) {
                p.alpha -= (initialAlphaFN / p.lifespan) * d;
            } else {
                p.alpha = 0;
            }
        } else {
            // For all other particles, p.alpha is their current visual opacity.
            // p.customData.initialAlpha should have been set in fnACWP.
            const initialAlpha = p.customData.initialAlpha || 1.0; // Fallback if not set
            if (p.lifespan > 0) {
                p.alpha -= (initialAlpha / p.lifespan) * d;
            } else {
                p.alpha = 0; // Instantly fade if lifespan is zero or less
            }
        }
        if (p.alpha < 0) p.alpha = 0;


        switch (currentEquippedCosmetics.trailCW) {
            case "smoke":
                if (p.radius < p.customData.maxRadius) {
                    p.radius += p.customData.growthRate * d;
                }
                p.vx += (fnSRnd() - 0.5) * 0.001 * _PCOR * d;
                break;
            case "fire":
                 if (!p.color.startsWith('rgba(200,0,0')) {
                    p.radius -= 0.004 * _PCOR * d;
                    if (p.radius < 0) p.radius = 0;
                }
                break;
            case "sparkler":
                p.customData.currentLength -= (p.customData.initialLength / p.lifespan) * d;
                p.customData.currentWidth -= (p.customData.initialWidth / p.lifespan) * d;
                if (p.customData.currentLength < 0) p.customData.currentLength = 0;
                if (p.customData.currentWidth < 0) p.customData.currentWidth = 0;
                p.radius = p.customData.currentWidth;
                break;
            case "bubbles":
                p.customData.swayTime += p.customData.swaySpeed * d;
                p.x += Math.sin(p.customData.swayTime) * p.customData.swayAmount * d;
                p.vy -= 0.0005 * _PCOR * d;
                break;
            case "rainbow":
                p.customData.hue = (p.customData.hue + 120 * d) % 360;
                break;
            case "aurora":
                p.customData.waveTime += 3 * d;
                const yOffset = Math.sin(p.customData.waveTime + p.x * (0.006 / (_PCOR*0.01)) ) * p.customData.waveAmp * 0.1;
                p.y += yOffset * d;
                const effectiveAuroraRadius = p.customData.initialRadius * (p.alpha + 0.1);
                if (effectiveAuroraRadius < (_PCOR * 0.002)) p.alpha = 0; // Mark for removal by setting alpha to 0
                break;
            case "confetti":
                p.vy += 0.02 * _PCOR * d;
                p.customData.flutterTime += 5 * d;
                p.vx += Math.sin(p.customData.flutterTime) * p.customData.flutterAmount * d;
                p.rotation += p.angularVelocity * d * (Math.cos(p.customData.flutterTime * 0.5) * 0.5 + 0.5);
                break;
            case "glitch": // Alpha handled by lifespan countdown
                if (fnSRnd() < 25 * d) {
                    p.x = playerCursor.x + (fnSRnd() - 0.5) * _PCOR * (0.3 + fnSRnd() * 0.4);
                    p.y = playerCursor.y + (fnSRnd() - 0.5) * _PCOR * (0.3 + fnSRnd() * 0.4);
                     if (fnSRnd() < 0.1) {
                        const glitchPixelColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFFFF'];
                        p.color = glitchPixelColors[Math.floor(fnSRnd() * glitchPixelColors.length)];
                    }
                }
                break;
            case "shadow":
                p.radius += p.customData.growthRate * d;
                break;
            case "plasma":
                p.customData.pulseTime += 6 * d;
                const pulse = (Math.sin(p.customData.pulseTime) + 1) / 2;
                p.customData.currentRadius = p.radius * (0.7 + pulse * 0.6);
                break;
            case "snow":
                p.customData.swayTime += p.customData.swaySpeed * d;
                p.x += Math.sin(p.customData.swayTime) * p.customData.swayAmount * d;
                p.vy += 0.0005 * _PCOR * d;
                break;
            case "lingeringGlow":
                p.radius += p.customData.growthRate * d;
                p.customData.hue = (p.customData.hue + 60 * d) % 360;
                break;
        }

        let removeParticle = false;
        if (p.customData.isGlitch) { // Glitch removed by lifespan
            if (p.lifespan <=0) removeParticle = true;
        } else { // Others removed by alpha
            if (p.alpha <= 0) removeParticle = true;
        }

        if (removeParticle || (p.radius <= (_PCOR * 0.002) && (p.shape === 'circle' || p.shape === 'star' || p.shape === 'auroraGlow' || p.shape === 'glow' || p.shape === 'customSparkler' || p.shape === 'snowflake' || p.shape === 'plasmaGlow'))) {
            colorWheelParticles.splice(i, 1);
        }
    }
}


function fnDCWP(ctx) {
    if (!playerCursor) return;

    colorWheelParticles.forEach(p => {
        const dx = p.x - playerCursor.x;
        const dy = p.y - playerCursor.y;
        const distSq = dx * dx + dy * dy;
        const isOutsideWheel = distSq > _PCOR * _PCOR;

        const drawThisParticle = isOutsideWheel ||
                                 currentEquippedCosmetics.trailCW === "simpleLines" ||
                                 (currentEquippedCosmetics.trailCW === 'glitch' && isOutsideWheel);


        if (drawThisParticle || p.shape === 'fruitNinjaSegment') {
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.alpha); // <<<< THIS IS THE KEY ALPHA FOR DRAWING

            if (p.shape === 'fruitNinjaSegment') {
                ctx.beginPath();
                ctx.moveTo(p.startX, p.startY);
                ctx.lineTo(p.endX, p.endY);
                ctx.strokeStyle = p.color; // p.color is 'rgba(220,230,255,1)'
                                          // ctx.globalAlpha handles the fade
                ctx.lineWidth = p.lineWidth * (p.alpha / 0.7); // Taper width
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.restore();
                return;
            }

            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);

            switch (p.shape) {
                case 'circle':
                    ctx.beginPath();
                    let displayRadius = p.radius;
                     if ((currentEquippedCosmetics.trailCW === 'plasmaGlow' || currentEquippedCosmetics.trailCW === 'auroraGlow') && p.customData.currentRadius) {
                        displayRadius = p.customData.currentRadius;
                    }
                    ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);

                    if (currentEquippedCosmetics.trailCW === 'default') {
                        ctx.fillStyle = p.color; // p.color is 'rgba(220,220,255,1)'
                                                 // ctx.globalAlpha handles the fade
                    } else if (currentEquippedCosmetics.trailCW === 'rainbow') {
                         ctx.fillStyle = `hsla(${p.customData.hue}, 100%, 70%, 1)`; // Base HSL, ctx.globalAlpha handles fade
                    } else if (currentEquippedCosmetics.trailCW === 'bubbles' && p.customData.highlightColor) {
                        // Bubbles have their own alpha baked into their color strings, but overall fade controlled by globalAlpha
                        ctx.fillStyle = p.color; // e.g., rgba(r,g,b,0.15)
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(displayRadius * 0.3, -displayRadius * 0.3, displayRadius * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = p.customData.highlightColor; // e.g., rgba(r,g,b,0.25)
                    } else {
                        // For other simple circle trails, assume p.color is their base color string
                        // and ctx.globalAlpha will handle their fading.
                        ctx.fillStyle = p.color;
                    }
                    ctx.fill();
                    break;
                case 'auroraGlow':
                    const auroraGrad = ctx.createRadialGradient(0,0, Math.min(p.customData.ellipseRx, p.customData.ellipseRy) * 0.1, 0,0, Math.max(p.customData.ellipseRx, p.customData.ellipseRy));
                    // p.color is base 'rgba(r,g,b,1)'. We need to extract RGB for the gradient stops.
                    const auroraBaseRGB = p.color.match(/\d+/g).slice(0,3).join(','); // "r,g,b"
                    auroraGrad.addColorStop(0, `rgba(${auroraBaseRGB},${(p.alpha * 0.6).toFixed(2)})`); // Gradient alpha still relative to particle alpha
                    auroraGrad.addColorStop(0.5, `rgba(${auroraBaseRGB},${(p.alpha * 0.3).toFixed(2)})`);
                    auroraGrad.addColorStop(1, `rgba(${auroraBaseRGB},0)`);
                    ctx.fillStyle = auroraGrad;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.customData.ellipseRx, p.customData.ellipseRy, 0, 0, Math.PI * 2);
                    ctx.fill();

                    const currentGlobalAlphaForLines = ctx.globalAlpha;
                    ctx.globalAlpha = Math.max(0, p.alpha * 0.7); // Lines slightly less opaque than main glow
                    // p.customData.lineColor is 'rgba(r,g,b, initial_tiny_alpha)'
                    // We need to use its RGB and apply current p.alpha * tiny_initial_factor
                    const lineBaseRGB = p.customData.lineColor.match(/\d+/g).slice(0,3).join(',');
                    const lineInitialAlpha = parseFloat(p.customData.lineColor.match(/[\d\.]+(?=\))/));
                    ctx.strokeStyle = `rgba(${lineBaseRGB}, ${(p.alpha * lineInitialAlpha * 20).toFixed(2)})`; // Amplify initial for visibility
                    ctx.lineWidth = Math.max(1, _PCOR * 0.005);
                    const numLines = 3 + Math.floor(fnSRnd() * 3);
                    for (let k=0; k<numLines; k++) {
                        ctx.beginPath();
                        const lineAngle = fnSRnd() * Math.PI * 2;
                        const lineLength = Math.min(p.customData.ellipseRx, p.customData.ellipseRy) * (0.4 + fnSRnd() * 0.5);
                        ctx.moveTo(Math.cos(lineAngle) * lineLength * -0.5, Math.sin(lineAngle) * lineLength * -0.5);
                        ctx.lineTo(Math.cos(lineAngle) * lineLength * 0.5, Math.sin(lineAngle) * lineLength * 0.5);
                        ctx.stroke();
                    }
                     ctx.globalAlpha = currentGlobalAlphaForLines;
                    break;
                case 'plasmaGlow':
                case 'glow':
                     const glowCoreBase = p.customData.coreColor; // hsla(H,S,L,1) or rgba(R,G,B,1)
                     const glowOuterBase = p.color;           // hsla(H,S,L,1) or rgba(R,G,B,1)
                     const glowRadiusToDraw = p.customData.currentRadius || p.radius;

                     const gradGlow = ctx.createRadialGradient(0,0, glowRadiusToDraw * 0.3, 0,0, glowRadiusToDraw);
                     gradGlow.addColorStop(0, glowCoreBase.replace(/,1\)/, `,${(p.alpha * 0.8).toFixed(3)})`) );
                     gradGlow.addColorStop(0.6, glowOuterBase.replace(/,1\)/, `,${(p.alpha * 0.5).toFixed(3)})`) );
                     gradGlow.addColorStop(1, glowOuterBase.replace(/,1\)/, `,0)`));
                     ctx.fillStyle = gradGlow;
                     ctx.beginPath();
                     ctx.arc(0,0,glowRadiusToDraw, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                case 'rect': // Confetti
                    ctx.fillStyle = p.color; // Base color 'rgba(r,g,b,1)', globalAlpha handles fade
                    ctx.fillRect(-p.customData.width / 2, -p.customData.height / 2, p.customData.width, p.customData.height);
                    break;
                case 'glitchPixel':
                    ctx.fillStyle = p.color; // No alpha in glitch color string, globalAlpha is 1.0
                    ctx.fillRect(-p.customData.w / 2, -p.customData.h / 2, p.customData.w, p.customData.h);
                    break;
                case 'line': // Laser, Wind
                    ctx.beginPath();
                    ctx.moveTo(0, -p.customData.length / 2);
                    ctx.lineTo(0, p.customData.length / 2);
                    ctx.strokeStyle = p.color; // Base color, globalAlpha handles fade
                    ctx.lineWidth = p.radius * 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    break;
                case 'customSparkler':
                     ctx.lineWidth = p.customData.currentWidth;
                     ctx.strokeStyle = p.color; // Base color, globalAlpha handles fade
                     ctx.lineCap = 'round';
                     p.customData.lineAngles.forEach(angleOffset => {
                         ctx.beginPath();
                         const currentRotation = 0 + angleOffset;
                         ctx.moveTo(Math.cos(currentRotation) * -p.customData.currentLength / 2, Math.sin(currentRotation) * -p.customData.currentLength / 2);
                         ctx.lineTo(Math.cos(currentRotation) * p.customData.currentLength / 2, Math.sin(currentRotation) * p.customData.currentLength / 2);
                         ctx.stroke();
                     });
                    break;
                case 'star': // Magic, Sparkles
                    ctx.beginPath();
                    ctx.moveTo(0, -p.radius);
                    for (let j = 0; j < p.customData.spikes * 2; j++) {
                        const angle = (j * Math.PI) / p.customData.spikes;
                        const radius = j % 2 === 0 ? p.radius : p.customData.innerRadius;
                        ctx.lineTo(Math.sin(angle) * radius, -Math.cos(angle) * radius);
                    }
                    ctx.closePath();
                    ctx.fillStyle = p.color; // Base color, globalAlpha handles fade
                    ctx.fill();
                    if (currentEquippedCosmetics.trailCW === 'sparkles' && p.customData.glowColor) {
                        const originalGlobalAlpha = ctx.globalAlpha;
                        ctx.globalAlpha = Math.max(0, p.alpha * 0.6);
                        // p.customData.glowColor already has its own alpha, so we might want to scale it by p.alpha
                        const glowBaseRGB = p.customData.glowColor.match(/\d+/g).slice(0,3).join(',');
                        const glowInitialAlpha = parseFloat(p.customData.glowColor.match(/[\d\.]+(?=\))/));

                        const gradSparkle = ctx.createRadialGradient(0,0, p.radius * 0.2, 0,0, p.radius * 1.8);
                        gradSparkle.addColorStop(0, `rgba(${glowBaseRGB},${(glowInitialAlpha * p.alpha * 0.8).toFixed(2)})`);
                        gradSparkle.addColorStop(0.5, `rgba(${glowBaseRGB},${(glowInitialAlpha * p.alpha * 0.4).toFixed(2)})`);
                        gradSparkle.addColorStop(1, `rgba(${glowBaseRGB},0)`);
                        ctx.fillStyle = gradSparkle;
                        ctx.fill();
                        ctx.globalAlpha = originalGlobalAlpha;
                    }
                    break;
                case 'snowflake':
                    ctx.strokeStyle = p.color; // Base color, globalAlpha handles fade
                    ctx.lineWidth = p.customData.armWidth;
                    ctx.lineCap = 'round';
                    for(let k=0; k < p.customData.arms; k++){
                        const angle = (k * (Math.PI*2)) / p.customData.arms;
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength, Math.sin(angle) * p.customData.armLength);
                        const branchLength = p.customData.armLength * 0.4;
                        const branchAngleOffset = Math.PI / 5;
                        ctx.moveTo(Math.cos(angle) * p.customData.armLength * 0.6, Math.sin(angle) * p.customData.armLength * 0.6);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength * 0.6 + Math.cos(angle + branchAngleOffset) * branchLength,
                                   Math.sin(angle) * p.customData.armLength * 0.6 + Math.sin(angle + branchAngleOffset) * branchLength);
                        ctx.moveTo(Math.cos(angle) * p.customData.armLength * 0.6, Math.sin(angle) * p.customData.armLength * 0.6);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength * 0.6 + Math.cos(angle - branchAngleOffset) * branchLength,
                                   Math.sin(angle) * p.customData.armLength * 0.6 + Math.sin(angle - branchAngleOffset) * branchLength);
                        ctx.stroke();
                    }
                    break;
                case 'rgbDot':
                    // This shape's drawing logic inherently uses p.alpha for its glows and gradients.
                    // So, ctx.globalAlpha is already correctly set to p.alpha.
                    const bHC = p.color;
                    const lCX = 0 - p.radius * 0.30;
                    const lCY = 0 - p.radius * 0.30;
                    const gSM = 1.9;
                    const aGOR = p.radius * gSM;

                    const gGC = ctx.createRadialGradient(0, 0, p.radius, 0, 0, aGOR);
                    let rGS = parseInt(bHC.slice(1, 3), 16);
                    let gGS = parseInt(bHC.slice(3, 5), 16);
                    let bGS = parseInt(bHC.slice(5, 7), 16);
                    const gOAS = 0.3 * p.alpha; // Glow opacity uses p.alpha
                    gGC.addColorStop(0, `rgba(${rGS},${gGS},${bGS},${gOAS})`);
                    gGC.addColorStop(1, `rgba(${rGS},${gGS},${bGS},0)`);
                    ctx.fillStyle = gGC;
                    ctx.beginPath();
                    ctx.arc(0, 0, aGOR, 0, Math.PI * 2);
                    ctx.fill();

                    const bG = ctx.createRadialGradient(lCX, lCY, p.radius * 0.00, 0, 0, p.radius * 2.0);
                    let rB = rGS, gB = gGS, bB = bGS;
                    let [h_rgb, s_rgb, l_rgb] = fnR2H(rB, gB, bB);
                    const lIF = 0.20;
                    let lA = Math.min(1, l_rgb + lIF);
                    lA = Math.max(0, lA);
                    let [rM, gM, bM] = fnH2R(h_rgb, s_rgb, lA);
                    const mCIG = fnRA2Hex([rM, gM, bM]);
                    const hC = '#FFFFFF';
                    const sC = fnDarkC(mCIG, 40);

                    const hexToRgbaWithAlpha = (hex, alphaVal) => {
                        const r = parseInt(hex.slice(1,3),16);
                        const g_val = parseInt(hex.slice(3,5),16); // renamed g to g_val
                        const b = parseInt(hex.slice(5,7),16);
                        return `rgba(${r},${g_val},${b},${alphaVal.toFixed(2)})`;
                    };

                    bG.addColorStop(0, hexToRgbaWithAlpha(hC, p.alpha)); // Body opacity uses p.alpha
                    bG.addColorStop(0.4, hexToRgbaWithAlpha(mCIG, p.alpha));
                    bG.addColorStop(0.8, hexToRgbaWithAlpha(mCIG, p.alpha));
                    bG.addColorStop(1, hexToRgbaWithAlpha(sC, p.alpha));

                    ctx.fillStyle = bG;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            ctx.restore();
        }
    });
}

function fnUCWP(d) {
    for (let i = colorWheelParticles.length - 1; i >= 0; i--) {
        const p = colorWheelParticles[i];
        p.x += p.vx * d; // Apply delta time directly
        p.y += p.vy * d;
        p.rotation += p.angularVelocity * d;
        p.alpha -= d / p.lifespan;

        switch (currentEquippedCosmetics.trailCW) {
            case "smoke":
                if (p.radius < p.customData.maxRadius) {
                    p.radius += p.customData.growthRate * d;
                }
                p.vx += (fnSRnd() - 0.5) * 0.001 * _PCOR * d; // Small random drift, relative
                break;
            case "fire":
                p.radius -= 0.004 * _PCOR * d; // Relative shrink rate
                if (p.radius < 0) p.radius = 0;
                break;
            case "sparkler":
                p.customData.currentLength -= (p.customData.initialLength / p.lifespan) * d;
                p.customData.currentWidth -= (p.customData.initialWidth / p.lifespan) * d;
                if (p.customData.currentLength < 0) p.customData.currentLength = 0;
                if (p.customData.currentWidth < 0) p.customData.currentWidth = 0;
                p.radius = p.customData.currentWidth;
                break;
            case "bubbles":
                p.customData.wobbleTime += 6 * d; // Adjusted speed for wobble
                p.x += Math.sin(p.customData.wobbleTime) * p.customData.wobbleAmount * d;
                break;
            case "rainbow":
                p.customData.hue = (p.customData.hue + 120 * d) % 360; // Hue shift speed
                break;
            case "simpleLines":
                break;
            case "aurora":
                p.customData.waveTime += 3 * d; // Adjusted wave speed
                const yOffset = Math.sin(p.customData.waveTime + p.x * (0.006 / (_PCOR*0.01)) ) * p.customData.waveAmp * 0.1; // Wave frequency scaled by _PCOR
                p.y += yOffset * d;
                p.radius = p.customData.initialRadius * (p.alpha + 0.1);
                break;
            case "confetti":
                p.vy += 0.001 * _PCOR * d; // Gravity, relative
                break;
            case "glitch":
                if (fnSRnd() < 18 * d) { // Adjusted frequency for random shift
                    p.x += (fnSRnd() - 0.5) * 0.16 * _PCOR; // Relative shift
                    p.y += (fnSRnd() - 0.5) * 0.16 * _PCOR;
                }
                break;
            case "shadow":
                p.radius += p.customData.growthRate * d;
                break;
            case "plasma":
                p.customData.pulseTime += 6 * d; // Adjusted pulse speed
                const pulse = (Math.sin(p.customData.pulseTime) + 1) / 2;
                p.currentRadius = p.radius * (0.8 + pulse * 0.4);
                break;
            case "snow":
                p.customData.swayTime += 3 * d; // Adjusted sway speed
                p.x += Math.sin(p.customData.swayTime) * p.customData.swayAmount * d;
                break;
            case "lingeringGlow":
                p.radius += p.customData.growthRate * d;
                p.customData.hue = (p.customData.hue + 60 * d) % 360; // Hue shift
                p.color = `hsla(${p.customData.hue}, 90%, 70%, ${(p.alpha * 0.05 + 0.02).toFixed(3)})`;
                p.customData.coreColor = `hsla(${p.customData.hue}, 100%, 85%, ${(p.alpha * 0.1 + 0.05).toFixed(3)})`;
                break;
            case "dust":
                 break;
        }

        if (p.alpha <= 0 || (p.radius <= (_PCOR * 0.002) && (p.shape === 'circle' || p.shape === 'star' || p.shape === 'auroraGlow' || p.shape === 'glow' || p.shape === 'customSparkler' || p.shape === 'snowflake'))) { // Relative minimum radius
            colorWheelParticles.splice(i, 1);
        }
    }
}

function fnDCWP(ctx) {
    if (!playerCursor) return;

    colorWheelParticles.forEach(p => {
        const dx = p.x - playerCursor.x;
        const dy = p.y - playerCursor.y;
        const distSq = dx * dx + dy * dy;
        const isOutsideWheel = distSq > _PCOR * _PCOR;

        if (isOutsideWheel || currentEquippedCosmetics.trailCW === 'glitch' || currentEquippedCosmetics.trailCW === 'simpleLines' || currentEquippedCosmetics.trailCW === "laser") {
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.alpha);


            if (p.shape === 'simpleLineTrail') {
                ctx.beginPath();
                ctx.moveTo(p.x, p.y); // Start of the line (previous cursor pos)
                ctx.lineTo(playerCursor.x, playerCursor.y); // End of the line (current cursor pos)
                ctx.strokeStyle = p.color;
                ctx.lineWidth = p.radius;
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.restore();
                return; // Skip further transformations for this shape
            }

            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);

            switch (p.shape) {
                case 'circle':
                    ctx.beginPath();
                    let displayRadius = p.radius;
                     if ((currentEquippedCosmetics.trailCW === 'plasma' || currentEquippedCosmetics.trailCW === 'auroraGlow') && p.currentRadius) {
                        displayRadius = p.currentRadius;
                    }
                    ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;

                    if (currentEquippedCosmetics.trailCW === 'bubbles' && p.customData.highlightColor) {
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(displayRadius * 0.3, -displayRadius * 0.3, displayRadius * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = p.customData.highlightColor;
                    } else if (currentEquippedCosmetics.trailCW === 'plasma' && p.customData.coreColor) {
                        const coreRadius = displayRadius * 0.4;
                        const grad = ctx.createRadialGradient(0, 0, coreRadius * 0.5, 0, 0, displayRadius);
                        grad.addColorStop(0, p.customData.coreColor);
                        grad.addColorStop(1, p.color);
                        ctx.fillStyle = grad;
                    } else if (currentEquippedCosmetics.trailCW === 'rainbow') {
                         ctx.fillStyle = `hsla(${p.customData.hue}, 100%, 70%, ${p.alpha.toFixed(2)})`;
                    } else if (currentEquippedCosmetics.trailCW === 'rgbDots' && p.customData.glowColor) {
                        const glowRadius = displayRadius * 2.5;
                        const grad = ctx.createRadialGradient(0, 0, displayRadius * 0.5, 0, 0, glowRadius);
                        grad.addColorStop(0, p.color);
                        grad.addColorStop(0.7, p.customData.glowColor.replace(/[^,]+(?=\))/, (p.alpha * 0.5).toFixed(2)) );
                        grad.addColorStop(1, p.customData.glowColor.replace(/[^,]+(?=\))/, '0'));
                        ctx.fillStyle = grad;
                    }
                    ctx.fill();
                    break;
                case 'auroraGlow': // Dedicated shape for aurora
                    const auroraGrad = ctx.createRadialGradient(0,0, p.radius * 0.2, 0,0, p.radius);
                    const baseAuroraColor = p.color.substring(0, p.color.lastIndexOf(',')) + ','; //e.g. "rgba(r,g,b,"
                    auroraGrad.addColorStop(0, baseAuroraColor + (p.alpha * 0.5).toFixed(2) + ')');
                    auroraGrad.addColorStop(0.5, baseAuroraColor + (p.alpha * 0.2).toFixed(2) + ')');
                    auroraGrad.addColorStop(1, baseAuroraColor + '0)');
                    ctx.fillStyle = auroraGrad;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.radius * 1.5, p.radius * 0.7, p.rotation, 0, Math.PI * 2); // Elliptical glow
                    ctx.fill();
                    break;
                case 'glow': // For lingeringGlow
                     const glowGrad = ctx.createRadialGradient(0,0, p.radius * 0.3, 0,0, p.radius);
                     glowGrad.addColorStop(0, p.customData.coreColor.replace(/[^,]+(?=\))/, (p.alpha * 0.8).toFixed(3)) );
                     glowGrad.addColorStop(0.6, p.color.replace(/[^,]+(?=\))/, (p.alpha * 0.5).toFixed(3)) );
                     glowGrad.addColorStop(1, p.color.replace(/[^,]+(?=\))/, '0'));
                     ctx.fillStyle = glowGrad;
                     ctx.beginPath();
                     ctx.arc(0,0,p.radius, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                case 'rect': // Used by confetti
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.customData.width / 2, -p.customData.height / 2, p.customData.width, p.customData.height);
                    break;
                case 'glitchPixel': // Used by glitch
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.customData.w / 2, -p.customData.h / 2, p.customData.w, p.customData.h);
                    break;
                case 'line': // Used by sparkler, laser, wind
                    ctx.beginPath();
                    ctx.moveTo(0, -p.customData.length / 2);
                    ctx.lineTo(0, p.customData.length / 2);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.radius * 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    break;
                case 'customSparkler':
                     ctx.lineWidth = p.customData.currentWidth;
                     ctx.strokeStyle = p.color;
                     ctx.lineCap = 'round';
                     p.customData.lineAngles.forEach(angleOffset => {
                         ctx.beginPath();
                         const currentRotation = p.rotation + angleOffset;
                         ctx.moveTo(Math.cos(currentRotation) * -p.customData.currentLength / 2, Math.sin(currentRotation) * -p.customData.currentLength / 2);
                         ctx.lineTo(Math.cos(currentRotation) * p.customData.currentLength / 2, Math.sin(currentRotation) * p.customData.currentLength / 2);
                         ctx.stroke();
                     });
                    break;
                case 'star': // Used by magic, sparkles
                    ctx.beginPath();
                    ctx.moveTo(0, -p.radius);
                    for (let j = 0; j < p.customData.spikes * 2; j++) {
                        const angle = (j * Math.PI) / p.customData.spikes;
                        const radius = j % 2 === 0 ? p.radius : p.customData.innerRadius;
                        ctx.lineTo(Math.sin(angle) * radius, -Math.cos(angle) * radius);
                    }
                    ctx.closePath();
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    if (currentEquippedCosmetics.trailCW === 'sparkles' && p.customData.glowColor) {
                        ctx.globalAlpha = Math.max(0, p.alpha * 0.5); // Softer glow
                        ctx.fillStyle = p.customData.glowColor;
                        ctx.fill(); // Draw glow on top
                    }
                    break;
                case 'snowflake':
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.customData.armWidth;
                    ctx.lineCap = 'round';
                    for(let k=0; k < p.customData.arms; k++){
                        const angle = (k * (Math.PI*2)) / p.customData.arms;
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength, Math.sin(angle) * p.customData.armLength);
                        // Add smaller branches
                        const branchLength = p.customData.armLength * 0.4;
                        const branchAngleOffset = Math.PI / 5;
                        ctx.moveTo(Math.cos(angle) * p.customData.armLength * 0.6, Math.sin(angle) * p.customData.armLength * 0.6);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength * 0.6 + Math.cos(angle + branchAngleOffset) * branchLength,
                                   Math.sin(angle) * p.customData.armLength * 0.6 + Math.sin(angle + branchAngleOffset) * branchLength);
                        ctx.moveTo(Math.cos(angle) * p.customData.armLength * 0.6, Math.sin(angle) * p.customData.armLength * 0.6);
                        ctx.lineTo(Math.cos(angle) * p.customData.armLength * 0.6 + Math.cos(angle - branchAngleOffset) * branchLength,
                                   Math.sin(angle) * p.customData.armLength * 0.6 + Math.sin(angle - branchAngleOffset) * branchLength);
                        ctx.stroke();
                    }
                    break;
            }
            ctx.restore();
        }
    });
}

function fnAPGP(x, y) {
    const POWERUP_PARTICLE_VELOCITY_SCALE = _PCOR * 0.8; // Speed: e.g., 0.8 times player cursor outer radius per second
    const POWERUP_PARTICLE_RADIUS_MIN_SCALE = 0.015;      // Min radius as a fraction of _PCOR
    const POWERUP_PARTICLE_RADIUS_VARIATION_SCALE = 0.025; // Additional random radius as a fraction of _PCOR

    powerupGlowParticles.push({
        x: x,
        y: y,
        radius: (fnSRnd() * POWERUP_PARTICLE_RADIUS_VARIATION_SCALE + POWERUP_PARTICLE_RADIUS_MIN_SCALE) * _PCOR,
        alpha: 0.8, // Initial visual alpha
        color: `rgba(255,235,59,${0.5 + fnSRnd() * 0.3})`, // Color already has some alpha baked in
        vx: (fnSRnd() - 0.5) * 2 * POWERUP_PARTICLE_VELOCITY_SCALE, // Velocity in units per second
        vy: (fnSRnd() - 0.5) * 2 * POWERUP_PARTICLE_VELOCITY_SCALE, // Velocity in units per second
        life: 0.5 + fnSRnd() * 0.3 // Lifespan in seconds
    });
}

function fnUPGP(d){for(let i=powerupGlowParticles.length-1;i>=0;i--){const p=powerupGlowParticles[i];p.x+=p.vx*d;p.y+=p.vy*d;p.alpha-=d/p.life;if(p.alpha<=0)powerupGlowParticles.splice(i,1);}}
function fnDPGP(ctx){powerupGlowParticles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color.replace(/[^,]+(?=\))/,p.alpha.toFixed(2));ctx.fill();});}

function fnIAP() {
    atmosphericParticles.length = 0;
    const baseRadiusMin = 0.0015 * Math.min(gameWidth, gameHeight);
    const baseRadiusMax = 0.005 * Math.min(gameWidth, gameHeight);
    const speedBase = 0.05 * Math.min(gameWidth, gameHeight);

    const minAlpha = 0.05;
    const maxAlpha = 0.35;

    for (let i = 0; i < _NAP; i++) {
        const r = fnSRnd() * (baseRadiusMax - baseRadiusMin) + baseRadiusMin;
        const sMR = 2.0, sXR = 0.5;
        const nR = (baseRadiusMax - baseRadiusMin > 0) ? (r - baseRadiusMin) / (baseRadiusMax - baseRadiusMin) : 0;
        const sM = sMR + (sXR - sMR) * nR;

        atmosphericParticles.push({
            x: fnSRnd() * gameWidth,
            y: fnSRnd() * gameHeight,
            radius: r,
            alpha: fnSRnd() * (maxAlpha - minAlpha) + minAlpha,
            color: `rgba(200,220,255,1)`, // Base color is fully opaque, actual alpha applied in draw
            vx: (fnSRnd() - 0.5) * speedBase * 0.2,
            vy: (fnSRnd() - 0.5) * speedBase * 0.2,
            speedMultiplier: sM,
            maxSpeedComponent: speedBase * 0.1
        });
    }
}

function fnUAP(d) {
    // Increased acceleration base multiplier
    const accelerationBase = 0.5 * Math.min(gameWidth, gameHeight); // Was 0.1

    atmosphericParticles.forEach(p => {
        // Adjusted acceleration factor
        p.vx += (fnSRnd() - 0.5) * accelerationBase * 0.02 * d; // Was 0.01
        p.vy += (fnSRnd() - 0.5) * accelerationBase * 0.02 * d;

        const individualMaxSpeed = p.maxSpeedComponent * p.speedMultiplier;
        p.vx = Math.max(-individualMaxSpeed, Math.min(individualMaxSpeed, p.vx));
        p.vy = Math.max(-individualMaxSpeed, Math.min(individualMaxSpeed, p.vy));

        p.x += p.vx * d;
        p.y += p.vy * d;

        if (p.x < -p.radius) p.x = gameWidth + p.radius;
        if (p.x > gameWidth + p.radius) p.x = -p.radius;
        if (p.y < -p.radius) p.y = gameHeight + p.radius;
        if (p.y > gameHeight + p.radius) p.y = -p.radius;
    });
}

function fnDAP(ctx){atmosphericParticles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color.replace(/[^,]+(?=\))/,p.alpha.toFixed(2));ctx.fill();});}

function fnITP() {
    textureParticles.length = 0;
    // Increased base radius multipliers for texture particles
    const baseRadiusMinTex = 0.0006 * Math.min(gameWidth, gameHeight); // Was 0.0002
    const baseRadiusMaxTex = 0.0018 * Math.min(gameWidth, gameHeight); // Was 0.001

    for (let i = 0; i < _NTP; i++) {
        textureParticles.push({
            x: fnSRnd() * gameWidth,
            y: fnSRnd() * gameHeight,
            radius: fnSRnd() * (baseRadiusMaxTex - baseRadiusMinTex) + baseRadiusMinTex,
            alpha: fnSRnd() * 0.04 + 0.01 // Alpha can remain subtle
        });
    }
}

function fnDTP(ctx){textureParticles.forEach(p=>{ctx.fillStyle=`rgba(210,210,225,${p.alpha.toFixed(3)})`;ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fill();});}

function fnAPU(determinedPowerupTypeOrEventType, isProcessingRecordedEvent, recordedEventData) {
    const cST = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const currentModeForPowerup = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;

    if (currentModeForPowerup === 'hardcore' && determinedPowerupTypeOrEventType !== 'extraLives') {
        return;
    }

    let pT = "";
    let actualPowerupTypeToActivate;
    let oneColorValue = null;
    let calculatedEndTime;
    let powerupDetailsToRecord = {};

    if (isProcessingRecordedEvent && recordedEventData) {
        actualPowerupTypeToActivate = recordedEventData.powerupType;
        calculatedEndTime = recordedEventData.endTime;
        if (actualPowerupTypeToActivate === 'oneColor' && recordedEventData.color) {
            oneColorValue = recordedEventData.color;
        }
    } else {
        actualPowerupTypeToActivate = determinedPowerupTypeOrEventType;
        calculatedEndTime = cST + _PUDM;

        powerupDetailsToRecord.powerupType = actualPowerupTypeToActivate;
        powerupDetailsToRecord.endTime = calculatedEndTime;

        if (actualPowerupTypeToActivate === 'oneColor') {
            const rCI = Math.floor(fnSRnd() * BALL_COLOR_NAMES.length);
            oneColorValue = BALL_COLOR_NAMES[rCI];
            powerupDetailsToRecord.color = oneColorValue;
        }
        if (recordedEventData && recordedEventData.collectedBallId !== undefined) {
             powerupDetailsToRecord.collectedBallId = recordedEventData.collectedBallId;
        }

        if (!rVState.activeReplay) {
            fnPS('powerupCollect');
            if (actualPowerupTypeToActivate !== 'extraLives') {
                 fnRecordPowerupEvent('powerupActivate', powerupDetailsToRecord);
            }
            lastCollectedPowerupType = actualPowerupTypeToActivate;
        }
    }

    switch (actualPowerupTypeToActivate) {
        case 'slowFall':
            activePowerups.slowFall.active = true; activePowerups.slowFall.endTime = calculatedEndTime; pT = "Slow Fall";
            balls.forEach(b => { if (b.originalVy) { b.vy = b.originalVy * _SFSM; } }); cBllSS = _OBSS * _SFSM; break;
        case 'wideBucket':
            activePowerups.wideBucket.active = true; activePowerups.wideBucket.endTime = calculatedEndTime; pT = "Wide Bucket";
            cBktWR = _BBWRW; if (bucket) bucket.baseWidth = gameWidth * cBktWR; break;
        case 'oneColor':
            activePowerups.oneColor.active = true; activePowerups.oneColor.endTime = calculatedEndTime;
            activePowerups.oneColor.color = oneColorValue; pT = "One Color"; break;
        case 'doublePoints':
            activePowerups.doublePoints.active = true; activePowerups.doublePoints.endTime = calculatedEndTime; pT = "Double Points";
            if(isProcessingRecordedEvent && rVState.activeReplay) rVState.isReplayDoublePointsActive = true;
            break;
        case 'extraLives':
            if (!isProcessingRecordedEvent && !rVState.activeReplay) {
                lives += 3; fnRecordScoreLivesUpdate();
            }
            pT = "+3 Lives"; break;
        case 'whiteBallMagnet':
            activePowerups.whiteBallMagnet.active = true; activePowerups.whiteBallMagnet.endTime = calculatedEndTime; pT = "Magnet"; break;
    }

    if (pT && !rVState.activeReplay && !isProcessingRecordedEvent) {
        fnDPT(pT);
    }
    fnUPI();
}
function fnCP(currentTime) {
    const currentModeForPowerup = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    if (currentModeForPowerup === 'hardcore') return;

    let changed = false;
    for (const type in activePowerups) {
        const p = activePowerups[type];
        if (p.active && p.endTime && currentTime >= p.endTime) {
            p.active = false;
            changed = true;

            if (!rVState.activeReplay) {
                fnRecordPowerupEvent('powerupDeactivate', { powerupType: type });
            }
            if (type === 'wideBucket') {
                cBktWR = _BBWRN;
                if (bucket) bucket.baseWidth = gameWidth * cBktWR;
            }
            if (type === 'slowFall') {
                balls.forEach(b => { if (b.originalVy) { b.vy = b.originalVy; } });
                cBllSS = _OBSS;
            }
            if (type === 'oneColor') {
                p.color = null;
            }
            if (type === 'doublePoints' && rVState.activeReplay) {
                rVState.isReplayDoublePointsActive = false;
            }
        }
    }
    if (changed) {
        fnUPI();
    }
}
function fnGRPUT(){
    const allPowerupTypes = ['slowFall','wideBucket','oneColor','doublePoints','extraLives','whiteBallMagnet'];
    let availablePowerups = allPowerupTypes;

    if (lastCollectedPowerupType !== null) {
        availablePowerups = allPowerupTypes.filter(type => type !== lastCollectedPowerupType);
    }

    if (availablePowerups.length === 0) {
        availablePowerups = allPowerupTypes;
    }

    return availablePowerups[Math.floor(fnSRnd() * availablePowerups.length)];
}

function fnUPI(){ 
    const cST = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const currentModeForIcons = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    
    if (currentModeForIcons === 'hardcore') {
        if(powerupIconsContainerElem) powerupIconsContainerElem.style.display = 'none';
        return;
    }
    if(powerupIconsContainerElem) powerupIconsContainerElem.style.display = 'flex';

    for (const type in powerupIconElems) {
        const iconElem = powerupIconElems[type];
        if (!iconElem) continue;
        const p = activePowerups[type];
        if (p && p.active) {
            iconElem.classList.add('active');
            if (p.endTime && (p.endTime - cST) <= _PUFTM) {
                iconElem.classList.add('flashing');
            } else {
                iconElem.classList.remove('flashing');
            }
        } else {
            iconElem.classList.remove('active', 'flashing');
        }
    }
}

function fnDPT(text){const tE=document.createElement('div');tE.className='powerup-text-display';tE.textContent=text;const cA=document.getElementById('canvasArea');if(cA)cA.appendChild(tE);setTimeout(()=>{if(tE.parentNode)tE.parentNode.removeChild(tE);},1000);}

function fnSG(clickEvent){
    if (screenStack.length > 0 && screenStack[screenStack.length - 1] !== 'home') {
        screenStack = ['home'];
    } else if (screenStack.length === 0) {
        screenStack = ['home'];
    }

    if(!audioCtx){if(!initAudio()){}}
    if(audioCtx?.state==='suspended'){audioCtx.resume();}
    gameModeActive = true;
    if(rVState.activeReplay) fnStopRP();
    if(gameCanvas)gameCanvas.style.cursor='none';
    for(const k in keysPressed){delete keysPressed[k];}

    gSeed = Math.floor(Math.random() * 0xFFFFFFFF);
    nextBallId = 0;
    fnIPRNG(gSeed);

    lastSavedReplayId = null;
    lastSavedReplayIdToWatch = null;

    cRepData = {
        seed: gSeed,
        gameMode: currentGameMode,
        cosmetics: { ...currentEquippedCosmetics },
        sfx: {
            collectWheel: currentEquippedCosmetics.collectWheel || R_SFX_DEFAULTS.collectWheel,
            collectBucket: currentEquippedCosmetics.collectBucket || R_SFX_DEFAULTS.collectBucket,
            ballDrop: currentEquippedCosmetics.ballDrop || R_SFX_DEFAULTS.ballDrop,
            loseLife: currentEquippedCosmetics.loseLife || R_SFX_DEFAULTS.loseLife,
            collectPowerup: currentEquippedCosmetics.collectPowerup || R_SFX_DEFAULTS.collectPowerup,
        },
        events: [],
        finalGameScore: 0,
        finalTimeMs: 0,
        gameEndTimestampForHS: 0
    };

    if (saveReplayBtnElem) {
        updateButtonText(saveReplayBtnElem, "Save Replay");
        saveReplayBtnElem.classList.remove('saved');
        saveReplayBtnElem.classList.remove('limit-reached');
        saveReplayBtnElem.classList.remove('watch-mode'); // <<< RESET watch-mode
    }

    fnSS('game');
    fnRGSR(false);

    let initialCursorX = gameWidth / 2;
    let initialCursorY = gameHeight / 2;

    if (clickEvent && gameCanvas) {
        const rect = gameCanvas.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            initialCursorX = clickEvent.clientX - rect.left;
            initialCursorY = clickEvent.clientY - rect.top;
        }
    } else if (gameCanvas && typeof lastKnownMouseX === 'number' && typeof lastKnownMouseY === 'number') {
        const rect = gameCanvas.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            initialCursorX = lastKnownMouseX - rect.left;
            initialCursorY = lastKnownMouseY - rect.top;
        }
    }
    initialCursorX = Math.max(0, Math.min(gameWidth, initialCursorX));
    initialCursorY = Math.max(0, Math.min(gameHeight, initialCursorY));

    playerCursor = { x: initialCursorX, y: initialCursorY, outerRadius: _PCOR, ringThickness: _PCRT };

    fnUPI();
    fnUUI();

    lastTime=performance.now();
    timePausedStarted=0;
    if(animationFrameId)cancelAnimationFrame(animationFrameId);
    animationFrameId=requestAnimationFrame(fnGL);
    if(mRecIntId) clearInterval(mRecIntId);
    mRecIntId = setInterval(fnRMP, _RMRIM);
}

function fnRGSR(isForReplayOrSim) {
    if (!isForReplayOrSim) {
        score = 0;
        lives = currentGameMode === 'hardcore' ? 1 : 3;
        elapsedGameTimeMs = 0;
        gameRunning = true;
        gamePaused = false;
        gPausedByConf = false;
        if (cRepData) fnRecordScoreLivesUpdate();
        nextBallId = 0;
        lastCollectedPowerupType = null;
    } else {
        rVState.score = 0;
        const replayGameMode = rVState.activeReplay.gameMode;
        rVState.lives = (replayGameMode === 'hardcore' ? 1 : 3);
        nextBallId = 0;
        rVState.isReplayDoublePointsActive = false;
        playerCursor = { x: gameWidth / 2, y: gameHeight / 2, outerRadius: _PCOR, ringThickness: _PCRT };
    }

    // Clear all next spawn times at the start of a game/replay
    rateBasedTrailNextSpawnTime = {};

    balls.length = 0;
    colorWheelParticles.length = 0;
    powerupGlowParticles.length = 0;
    if (newHighScoreTextElem) newHighScoreTextElem.style.display = 'none';
    cBllSS = _OBSS;

    const cM = isForReplayOrSim ? rVState.activeReplay.gameMode : currentGameMode;
    if (powerupIconsContainerElem) {
        powerupIconsContainerElem.style.display = (cM === 'hardcore') ? 'none' : 'flex';
    }

    for (const type in activePowerups) {
        activePowerups[type].active = false;
        activePowerups[type].endTime = 0;
        if (type === 'oneColor') activePowerups.oneColor.color = null;
    }
    if (!isForReplayOrSim && cM === 'classic' && cRepData) {
        for (const type in activePowerups) {
             fnRecordPowerupEvent('powerupDeactivate', { powerupType: type });
        }
    }

    cBktWR = _BBWRN;
    fnUBS();

    const createDropper = (isRightMoving, dropperNum) => ({
        id: dropperNum,
        x: gameWidth / 2 - DROPPER_WIDTH_BOTTOM / 2,
        y: 0,
        width: DROPPER_WIDTH_BOTTOM,
        height: DROPPER_HEIGHT,
        topWidth: DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO,
        speed: (gameWidth - DROPPER_WIDTH_BOTTOM) / _IDTPS,
        direction: isRightMoving ? 1 : -1,
        currentDropIntervalMs: _IBDIM,
        timeSinceLastDrop: 0,
        isMaxSpeedOverride: false
    });
    dropper1 = createDropper(true, 1);
    dropper2 = createDropper(false, 2);

    const iBW = gameWidth * cBktWR;
    bucket = {
        baseWidth: iBW, height: BUCKET_HEIGHT, y: gameHeight - BUCKET_HEIGHT - (BUCKET_LINE_WIDTH / 2),
        x: (gameWidth / 2) - (iBW / 2),
        get sideRise() { return this.height; },
        get sideRun() { return this.height / Math.tan(BUCKET_SIDE_ANGLE); },
        get P1() { return { x: this.x - this.sideRun, y: this.y }; },
        get P2() { return { x: this.x, y: this.y + this.height }; },
        get P3() { return { x: this.x + this.baseWidth, y: this.y + this.height }; },
        get P4() { return { x: this.x + this.baseWidth + this.sideRun, y: this.y }; }
    };

    fnIAP();
    fnITP();
    if (aCtx) aCtx.clearRect(0,0,gameWidth,gameHeight);fnDTP(aCtx);
}

function fnEG() {
    if (cRepData && playerCursor && !rVState.activeReplay) {
        cRepData.events.push({
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: 'mouse',
            x: parseFloat(playerCursor.x.toFixed(1)),
            y: parseFloat(playerCursor.y.toFixed(1))
        });
    }
    gameModeActive = false;
    if (gameCanvas) gameCanvas.style.cursor = 'default';
    for (const k in keysPressed) { delete keysPressed[k]; }
    gameRunning = false; gamePaused = false; gPausedByConf = false;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (mRecIntId) clearInterval(mRecIntId); mRecIntId = null;

    const gameEndTimestampForHS = Date.now();
    let autoSaveAttemptedAndSuccessful = false;
    const MAX_REPLAYS_PER_MODE = 50;

    const currentReplayGameModeForEG = cRepData ? cRepData.gameMode : currentGameMode;
    const gameModeCompactCode = R_GM_MAP[currentReplayGameModeForEG];
    const existingReplaysInMode = sReps.filter(r => r.gm === gameModeCompactCode).length;

    const finalGameTimeStr = fnFT(elapsedGameTimeMs);
    const isNewHighScoreOverall = fnSHS(score, finalGameTimeStr, gameEndTimestampForHS);

    if (cRepData) {
        cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'gameEnd' });
        cRepData.finalGameScore = score;
        cRepData.finalTimeMs = elapsedGameTimeMs;
        cRepData.gameEndTimestampForHS = gameEndTimestampForHS;

        saveReplayBtnElem.style.display = 'inline-block';
        saveReplayBtnElem.classList.remove('limit-reached'); // Reset first

        if (autosaveReplays === 'yes' && score > autosaveThreshold) {
            if (existingReplaysInMode < MAX_REPLAYS_PER_MODE) {
                const currentBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (!currentBtnText.includes("Limit Reached")) {
                    updateButtonText(saveReplayBtnElem, "Save Replay");
                    saveReplayBtnElem.classList.remove('saved');
                }
                fnSCR();
                if (saveReplayBtnElem.classList.contains('saved')) {
                    autoSaveAttemptedAndSuccessful = true;
                }
            } else {
                updateButtonText(saveReplayBtnElem, "Limit Reached");
                saveReplayBtnElem.classList.add('limit-reached'); // <<< ADD CLASS
                saveReplayBtnElem.classList.remove('saved');
                fnShowReplayLimitNotification(`${currentReplayGameModeForEG.charAt(0).toUpperCase() + currentReplayGameModeForEG.slice(1)} Replays Full! (${MAX_REPLAYS_PER_MODE}/${MAX_REPLAYS_PER_MODE})`);
            }
        }

        if (!autoSaveAttemptedAndSuccessful) {
            if (existingReplaysInMode >= MAX_REPLAYS_PER_MODE) {
                updateButtonText(saveReplayBtnElem, "Limit Reached");
                saveReplayBtnElem.classList.add('limit-reached'); // <<< ADD CLASS
                saveReplayBtnElem.classList.remove('saved');
            } else {
                 const currentBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (!currentBtnText.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                    updateButtonText(saveReplayBtnElem, "Save Replay");
                    saveReplayBtnElem.classList.remove('saved');
                    saveReplayBtnElem.classList.remove('limit-reached'); // Ensure removed if not limit
                }
            }
        }
    } else {
        saveReplayBtnElem.style.display = 'none';
    }

    const gOT = document.getElementById('gameOverTitle');
    if (gOT) {
        if (currentGameMode === 'classic') gOT.textContent = "Classic Mode";
        else if (currentGameMode === 'hardcore') gOT.textContent = "Hardcore Mode";
        else gOT.textContent = "Game Over";
    }
    if (finalScoreDisplay) finalScoreDisplay.textContent = score;
    if (finalTimeDisplay) finalTimeDisplay.textContent = finalGameTimeStr;

    if (isNewHighScoreOverall && newHighScoreTextElem) newHighScoreTextElem.style.display = 'block';
    else if (newHighScoreTextElem) newHighScoreTextElem.style.display = 'none';

    fnSS('gameOver');
    fnPS('loseLife');
}

function fnUUI(){ 
    const dSc=rVState.activeReplay?rVState.score:score; 
    const dTm=rVState.activeReplay?rVState.currentTimeMs:elapsedGameTimeMs; 
    const dLv=rVState.activeReplay?rVState.lives:lives; 
    if(scoreDisplay)scoreDisplay.textContent=dSc; 
    if(timeDisplay)timeDisplay.textContent=fnFT(dTm); 
    if(livesDisplay)livesDisplay.textContent='❤'.repeat(Math.max(0,dLv)); 
    if(rVState.activeReplay && replayTimeDisplayElem){
        replayTimeDisplayElem.textContent=`${fnFT(rVState.currentTimeMs)} / ${fnFT(rVState.totalDurationMs)}`;
    } 
    if(rVState.activeReplay && replaySeekBar){
        if(rVState.totalDurationMs > 0 && replaySeekBar.max > 0){
            replaySeekBar.value=(rVState.currentTimeMs / rVState.totalDurationMs) * parseFloat(replaySeekBar.max);
        } else {
            replaySeekBar.value=0;
        }
    }
}

function fnFT(ms){let s=Math.floor(ms/1000),m=Math.floor(s/60);s%=60;let t=Math.floor((ms%1000)/100);return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${t}`;}

function fnUGP(dTS, currentTimeForLogic) { 
    const effectiveTime = rVState.activeReplay ? currentTimeForLogic : elapsedGameTimeMs;
    if (!rVState.activeReplay) {
        elapsedGameTimeMs += dTS * 1000;
    }
    const p = Math.min(1, effectiveTime / _MST);
    const updateDropperProgression = (dr) => {
        if (!dr) return;
        const currentKeys = rVState.activeReplay ? rVState.keysPressedReplay : keysPressed;
        const maxSpeedActive = currentKeys[keybindMaxSpeed.toLowerCase()];
        dr.isMaxSpeedOverride = maxSpeedActive;
        if (maxSpeedActive) {
            dr.speed = (gameWidth - dr.width) / _FDTP;
            dr.currentDropIntervalMs = _FBDIM;
        } else {
            const dynamicTimePerScreenS = _IDTPS - (_IDTPS - _FDTP) * p;
            dr.speed = (gameWidth - dr.width) / dynamicTimePerScreenS;
            dr.currentDropIntervalMs = _IBDIM - (_IBDIM - _FBDIM) * p;
        }
    };
    updateDropperProgression(dropper1);
    updateDropperProgression(dropper2);
    fnCP(effectiveTime); 
}

function fnUBS(){const tTT=_XBTTS-((_BS-1)/9)*(_XBTTS-_MBTTS);cBktSPS=gameWidth/tTT;}
function fnDarkC(h,p){h=h.replace(/^#/,'');if(h.length===3)h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2];let r=parseInt(h.substring(0,2),16),g=parseInt(h.substring(2,4),16),b=parseInt(h.substring(4,6),16);r=Math.max(0,Math.floor(r*(1-p/100)));g=Math.max(0,Math.floor(g*(1-p/100)));b=Math.max(0,Math.floor(b*(1-p/100)));return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;}
function fnR2H(r,g,b){r/=255,g/=255,b/=255;let x=Math.max(r,g,b),n=Math.min(r,g,b);let h,s,l=(x+n)/2;if(x==n)h=s=0;else{let d=x-n;s=l>0.5?d/(2-x-n):d/(x+n);switch(x){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;}h/=6;}return [h,s,l];}
function fnH2R(h,s,l){let r,g,b;if(s==0)r=g=b=l;else{function q(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}let q2=l<0.5?l*(1+s):l+s-l*s;let p2=2*l-q2;r=q(p2,q2,h+1/3);g=q(p2,q2,h);b=q(p2,q2,h-1/3);}return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];}
function fnRA2Hex(a){return "#"+a.map(c=>{const h=c.toString(16);return h.length==1?"0"+h:h;}).join('');}

function fnUSD(drpr, deltaTimeS, isPrimaryDropper) {
    if (!drpr) return;
    drpr.x += drpr.speed * drpr.direction * deltaTimeS;
    if (drpr.x + drpr.width > gameWidth) { drpr.x = gameWidth - drpr.width; drpr.direction *= -1; }
    if (drpr.x < 0) { drpr.x = 0; drpr.direction *= -1; }
    
    
    const isV3Replay = rVState.activeReplay && rVState.activeReplay.v === REPLAY_FORMAT_VERSION;
    if (isV3Replay) { 
        drpr.timeSinceLastDrop += deltaTimeS * 1000;
        if (drpr.timeSinceLastDrop >= drpr.currentDropIntervalMs) {
            drpr.timeSinceLastDrop = 0; 
        }
        return;
    }
    
    drpr.timeSinceLastDrop += deltaTimeS * 1000;
    const cM = rVState.activeReplay ? rVState.activeReplay.gameMode : currentGameMode; 
    const currentSimTime = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;

    if (drpr.timeSinceLastDrop >= drpr.currentDropIntervalMs) {
        drpr.timeSinceLastDrop = 0;
        
        let ballParams = {}; 
        ballParams.id = nextBallId++; 
        ballParams.dropperId = drpr.id;

        if (cM === 'hardcore') {
            ballParams.isPowerup = false;
            const cRnd = fnSRnd();
            if (cRnd < 0.3333) { ballParams.colorHex = BALL_COLORS[0]; ballParams.colorName = BALL_COLOR_NAMES[0]; }
            else if (cRnd < 0.6666) { ballParams.colorHex = BALL_COLORS[1]; ballParams.colorName = BALL_COLOR_NAMES[1]; }
            else { ballParams.colorHex = BALL_COLORS[2]; ballParams.colorName = BALL_COLOR_NAMES[2]; }
        } else { 
            let bTRnd = fnSRnd();
            if (isPrimaryDropper) {
                if (bTRnd < 0.025) { ballParams.isPowerup = true; ballParams.colorHex = POWERUP_BALL_COLOR_HEX; ballParams.colorName = 'powerup'; }
                else {
                    ballParams.isPowerup = false; 
                    if (activePowerups.oneColor.active && activePowerups.oneColor.color) {
                        ballParams.colorName = activePowerups.oneColor.color; ballParams.colorHex = BALL_COLORS[BALL_COLOR_NAMES.indexOf(ballParams.colorName)];
                    } else {
                        let cRnd = fnSRnd();
                        if (cRnd < 0.33) { ballParams.colorHex = BALL_COLORS[0]; ballParams.colorName = BALL_COLOR_NAMES[0]; }
                        else if (cRnd < 0.66) { ballParams.colorHex = BALL_COLORS[1]; ballParams.colorName = BALL_COLOR_NAMES[1]; }
                        else { ballParams.colorHex = BALL_COLORS[2]; ballParams.colorName = BALL_COLOR_NAMES[2]; }
                    }
                }
            } else { 
                if (bTRnd < 0.025) { ballParams.isPowerup = true; ballParams.colorHex = POWERUP_BALL_COLOR_HEX; ballParams.colorName = 'powerup'; }
                else { ballParams.isPowerup = false; ballParams.colorHex = WHITE_BALL_COLOR_HEX; ballParams.colorName = 'white'; }
            }
        }
        ballParams.fallSpeedFactor = _MBFTS + fnSRnd() * (_XBFTS - _MBFTS);
        ballParams.sizeMultiplier = _MINBSM + fnSRnd() * (_MAXBSM - _MINBSM);
        ballParams.swayTime = fnSRnd() * Math.PI * 2;
        ballParams.vx_sway_direction = (fnSRnd() < 0.5 ? -1 : 1);

        if (!rVState.activeReplay) { 
            fnRecordBallSpawnEvent(ballParams); 
        }
        
        const newBall = {
            id: ballParams.id,
            x: drpr.x + drpr.width / 2,
            y: drpr.y + drpr.height,
            radius: BALL_RADIUS_BASE * ballParams.sizeMultiplier,
            colorHex: ballParams.colorHex,
            colorName: ballParams.colorName,
            originalVy: gameHeight / ballParams.fallSpeedFactor,
            isPowerup: ballParams.isPowerup,
            swayOffset: 0,
            swayTime: ballParams.swayTime,
            vx_sway_direction: ballParams.vx_sway_direction,
            spawnTimeMs: currentSimTime 
        };
        newBall.vy = (cM === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
        balls.push(newBall);

        if (!rVState.activeReplay) fnPS('drop');
    }
}


function fnDSD(ctx,drpr){if(drpr){ctx.fillStyle=DROPPER_COLOR;ctx.beginPath();const tO=(drpr.width-drpr.topWidth)/2;ctx.moveTo(drpr.x+tO,drpr.y);ctx.lineTo(drpr.x+drpr.width-tO,drpr.y);ctx.lineTo(drpr.x+drpr.width,drpr.y+drpr.height);ctx.lineTo(drpr.x,drpr.y+drpr.height);ctx.closePath();ctx.fill();}}
function fnLCC(p1,p2,cC,r){let d={x:p2.x-p1.x,y:p2.y-p1.y};let pTC={x:cC.x-p1.x,y:cC.y-p1.y};let t=(pTC.x*d.x+pTC.y*d.y)/(d.x*d.x+d.y*d.y);t=Math.max(0,Math.min(1,t));let cP={x:p1.x+d.x*t,y:p1.y+d.y*t};let dSq=(cC.x-cP.x)**2+(cC.y-cP.y)**2;return dSq<=r**2;}

function fnUB(dTS) { 
    const currentSimTime = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const cM = rVState.activeReplay ? rVState.activeReplay.gameMode : currentGameMode;
    const isV3Replay = rVState.activeReplay && rVState.activeReplay.v === REPLAY_FORMAT_VERSION;


    for (let i = balls.length - 1; i >= 0; i--) {
        const b = balls[i];
        b.y += b.vy * dTS;
        b.swayTime += cBllSS * dTS * b.vx_sway_direction;
        b.swayOffset = Math.sin(b.swayTime) * gameWidth * _BSAR;
        let dX = b.x + b.swayOffset;

        if (b.colorName === 'white' && cM === 'classic' && activePowerups.whiteBallMagnet.active && playerCursor) {
            const mTX = playerCursor.x, mTY = playerCursor.y;
            let dTCX = mTX - dX, dTCY = mTY - b.y;
            let distTC = Math.sqrt(dTCX * dTCX + dTCY * dTCY);
            if (distTC > 1) {
                let pS = (_MBPP + _MPI / (distTC + 10)) * dTS;
                pS = Math.min(pS, distTC);
                let pXC = (dTCX / distTC) * pS, pYC = (dTCY / distTC) * pS;
                b.x += pXC; b.y += pYC; dX = b.x + b.swayOffset;
            }
        }

        if (dX - b.radius < 0) { dX = b.radius; b.x = dX - b.swayOffset; b.vx_sway_direction *= -1; if (gameWidth * _BSAR !== 0) b.swayTime = Math.asin(Math.max(-1, Math.min(1, (dX - b.x) / (gameWidth * _BSAR)))); }
        else if (dX + b.radius > gameWidth) { dX = gameWidth - b.radius; b.x = dX - b.swayOffset; b.vx_sway_direction *= -1; if (gameWidth * _BSAR !== 0) b.swayTime = Math.asin(Math.max(-1, Math.min(1, (dX - b.x) / (gameWidth * _BSAR))));}

        if (b.isPowerup && cM === 'classic') fnAPGP(dX, b.y); 

        if (playerCursor) {
            const dCX = dX - playerCursor.x, dCY = b.y - playerCursor.y;
            const distC = Math.sqrt(dCX * dCX + dCY * dCY);
            
            if (distC < b.radius + _PCOR) { 
                if (b.isPowerup) {
                    if (!rVState.activeReplay) { 
                        let powerupTypeDetermined = fnGRPUT(); 
                        fnAPU(powerupTypeDetermined, false, { collectedBallId: b.id }); 
                        fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedPowerupWheel'); 
                        balls.splice(i, 1); continue;
                    } else if (!isV3Replay) { 
                        balls.splice(i,1); 
                        continue; 
                    } 
                }
                
                let pointsMultiplier = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive)) ) ? 2 : 1;
                let soundToPlay = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive))) ? 'collectGoodDouble' : 'collectGood';

                if (b.colorName === 'white') {
                    if (!rVState.activeReplay) { score += 3 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS(soundToPlay); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelWhite');}
                    if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
                    continue;
                }

                const ang = (Math.atan2(dCY, dCX) + 2 * Math.PI) % (2 * Math.PI);
                let segmentHit = null;
                function isAngleInSegment(targetAngle, segmentStart, segmentEnd) { return segmentStart < segmentEnd ? (targetAngle >= segmentStart && targetAngle < segmentEnd) : (targetAngle >= segmentStart || targetAngle < segmentEnd); }
                if (isAngleInSegment(ang, _PCSA.green.start, _PCSA.green.end)) segmentHit = 'green';
                else if (isAngleInSegment(ang, _PCSA.red.start, _PCSA.red.end)) segmentHit = 'red';
                else if (isAngleInSegment(ang, _PCSA.blue.start, _PCSA.blue.end)) segmentHit = 'blue';

                if (segmentHit) {
                    if (!rVState.activeReplay) { 
                        if (segmentHit === b.colorName) { score += 3 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS(soundToPlay); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelCorrect');}
                        else { lives--; fnRecordScoreLivesUpdate(); fnPS('loseLife'); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelWrong');}
                    }
                    if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
                    continue;
                }
            }
        }

        if (bucket && (fnLCC(bucket.P1, bucket.P2, { x: dX, y: b.y }, b.radius) ||
                       fnLCC(bucket.P2, bucket.P3, { x: dX, y: b.y }, b.radius) ||
                       fnLCC(bucket.P3, bucket.P4, { x: dX, y: b.y }, b.radius))) {
            if (b.isPowerup) {
                if (!rVState.activeReplay) {
                    let powerupTypeDetermined = fnGRPUT();
                    fnAPU(powerupTypeDetermined, false, { collectedBallId: b.id });
                    fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedPowerupBucket');
                }
            } else {
                if (!rVState.activeReplay) {
                    let pointsMultiplier = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive)) ) ? 2 : 1;
                    score += 1 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS('collectBucket');
                    fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedBucket');
                }
            }
            if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
            continue;
        }

        if (b.y - b.radius > gameHeight) { 
            if (!rVState.activeReplay) {
                let reason = 'missedOffScreen';
                if (cM === 'hardcore' || (!b.isPowerup && b.colorName !== 'white')) {
                    lives--; fnRecordScoreLivesUpdate(); fnPS('loseLife');
                    reason = 'missedOffScreen_LifeLoss';
                }
                fnRecordBallDespawnEvent(b.id, currentSimTime, reason);
            }
            if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
            continue;
        }
    }
}


function fnDB(ctx){
    const whiteBallsToDraw = [];
    const powerupBallsToDraw = [];
    const rgbBallsToDraw = [];

    balls.forEach(b => {
        if (b.isPowerup) {
            powerupBallsToDraw.push(b);
        } else if (b.colorName === 'white') {
            whiteBallsToDraw.push(b);
        } else {
            rgbBallsToDraw.push(b);
        }
    });

    const drawBallType = (ballArray) => {
        ballArray.forEach(b => {
            const dX=b.x+b.swayOffset,bY=b.y,lCX=dX-b.radius*0.30,lCY=bY-b.radius*0.30,bHC=b.colorHex,gSM=1.9,aGOR=b.radius*gSM;
            const gGC=ctx.createRadialGradient(dX,bY,b.radius,dX,bY,aGOR);
            let rGS=parseInt(bHC.slice(1,3),16),gGS=parseInt(bHC.slice(3,5),16),bGS=parseInt(bHC.slice(5,7),16);
            const gOAS=0.3;
            gGC.addColorStop(0,`rgba(${rGS},${gGS},${bGS},${gOAS})`);
            gGC.addColorStop(1,`rgba(${rGS},${gGS},${bGS},0)`);
            ctx.fillStyle=gGC;
            ctx.beginPath();
            ctx.arc(dX,bY,aGOR,0,Math.PI*2);
            ctx.fill();
            const bG=ctx.createRadialGradient(lCX,lCY,b.radius*0.00,dX,bY,b.radius*2.0);
            if(b.colorName==='white'){
                bG.addColorStop(0,'#FFFFFF');
                bG.addColorStop(0.25,'#FAFAFA');
                bG.addColorStop(0.5,'#F0F0F0');
                bG.addColorStop(0.75,'#E0E0E0');
                bG.addColorStop(1,'#D0D0D0');
            }else{
                let rB=parseInt(bHC.slice(1,3),16),gB=parseInt(bHC.slice(3,5),16),bB=parseInt(bHC.slice(5,7),16);
                let [h,s,l]=fnR2H(rB,gB,bB);
                const lIF=0.20;
                let lA=Math.min(1,l+lIF);
                lA=Math.max(0,lA);
                let [rM,gM,bM]=fnH2R(h,s,lA);
                const mCIG=fnRA2Hex([rM,gM,bM]);
                const hC='#FFFFFF';
                const sC=fnDarkC(mCIG,40);
                bG.addColorStop(0,hC);
                bG.addColorStop(0.4,mCIG);
                bG.addColorStop(0.8,mCIG);
                bG.addColorStop(1,sC);
            }
            ctx.fillStyle=bG;
            ctx.beginPath();
            ctx.arc(dX,bY,b.radius,0,Math.PI*2);
            ctx.fill();
        });
    };

    drawBallType(whiteBallsToDraw);
    if(currentGameMode==='classic'){fnDPGP(ctx);} 
    drawBallType(powerupBallsToDraw);
    drawBallType(rgbBallsToDraw);
}
function fnUBkt(dTS){ if(!bucket)return; const cK=rVState.activeReplay?rVState.keysPressedReplay:keysPressed; if(cK[keybindLeft]){bucket.x-=cBktSPS*dTS;} if(cK[keybindRight]){bucket.x+=cBktSPS*dTS;} if(bucket.x+bucket.baseWidth+bucket.sideRun<0){bucket.x=gameWidth+bucket.sideRun;} else if(bucket.x-bucket.sideRun>gameWidth){bucket.x=-bucket.baseWidth-bucket.sideRun;}}
function fnDBkt(ctx){if(!bucket)return;ctx.strokeStyle=BUCKET_COLOR;ctx.lineWidth=BUCKET_LINE_WIDTH;ctx.lineCap='round';ctx.beginPath();ctx.moveTo(bucket.P1.x,bucket.P1.y);ctx.lineTo(bucket.P2.x,bucket.P2.y);ctx.stroke();ctx.beginPath();ctx.moveTo(bucket.P4.x,bucket.P4.y);ctx.lineTo(bucket.P3.x,bucket.P3.y);ctx.stroke();ctx.lineCap='butt';ctx.beginPath();ctx.moveTo(bucket.P2.x,bucket.P2.y);ctx.lineTo(bucket.P3.x,bucket.P3.y);ctx.stroke();}

function fnDPC(ctx){ // ctx is gameCtx
    if(!playerCursor)return;

    const dprMultiplier = QUALITY_SETTINGS_MAP[currentQualitySetting];
    const cOR = _PCOR; // Logical outer radius

    const tempCanvas = document.createElement('canvas');
    // Ensure integer dimensions for the temporary canvas
    tempCanvas.width = Math.ceil(cOR * 2 * dprMultiplier);
    tempCanvas.height = Math.ceil(cOR * 2 * dprMultiplier);
    const tempCtx = tempCanvas.getContext('2d');

    // Scale first, then translate by logical center
    tempCtx.scale(dprMultiplier, dprMultiplier);
    tempCtx.translate(cOR, cOR); // (0,0) in drawing now refers to logical center

    const cBB=0.45,eDF=0.15,gTS=0.65,gTE=0.65; // Styling constants for dS

    // dS takes target context, logical centerX, logical centerY, logical outerRadius
    const dS = (targetCtx, currentCX, currentCY, currentOR, bHC, sK) => {
        const sA=_PCSA[sK],bSA=sA.start,bEA=sA.end;
        let rB=parseInt(bHC.slice(1,3),16),gB=parseInt(bHC.slice(3,5),16),bB=parseInt(bHC.slice(5,7),16);
        let [h,s,lO]=fnR2H(rB,gB,bB);
        let lBr=Math.min(1,lO+cBB);
        lBr=Math.max(0,lBr);
        const bSC=fnRA2Hex(fnH2R(h,s,lBr));
        const lIF=0.20;
        let lN=Math.min(1,lO+lIF);
        lN=Math.max(0,lN);
        const nSC=fnRA2Hex(fnH2R(h,s,lN));
        let lDa=Math.min(1,lO-eDF);
        lDa=Math.max(0,lDa);
        const dSC=fnRA2Hex(fnH2R(h,s,lDa));
        const grad=targetCtx.createRadialGradient(currentCX,currentCY,0,currentCX,currentCY,currentOR);
        grad.addColorStop(0,bSC);
        grad.addColorStop(gTS,nSC);
        grad.addColorStop(gTE,nSC);
        grad.addColorStop(1,dSC);
        targetCtx.beginPath();
        targetCtx.moveTo(currentCX, currentCY);
        targetCtx.arc(currentCX, currentCY, currentOR, bSA, bEA, false);
        // Removed targetCtx.lineTo(currentCX, currentCY); as closePath() handles this.
        targetCtx.closePath(); 
        targetCtx.fillStyle=grad;
        targetCtx.fill();
    };

    // Draw segments onto tempCtx, centered at logical (0,0) with logical radius cOR
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[0],'red');
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[2],'blue');
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[1],'green');

    // Draw separators onto tempCtx
    const sepA=[_PCSA.red.start,_PCSA.blue.start,_PCSA.green.start];
    let logicalLineWidth = Math.max(1, cOR / 4.0); // Logical line width
    tempCtx.lineWidth = logicalLineWidth; // Set line width in logical units
    tempCtx.strokeStyle='rgba(0,0,0,1)';
    tempCtx.globalCompositeOperation='destination-out';
    tempCtx.lineCap='butt';
    sepA.forEach(a=>{
        tempCtx.beginPath();
        tempCtx.moveTo(0,0); // Logical center
        // Extend line slightly (0.5 logical pixel for a clean cutout)
        const lL= cOR + tempCtx.lineWidth / 2; 
        tempCtx.lineTo(0 + lL*Math.cos(a), 0 + lL*Math.sin(a));
        tempCtx.stroke();
    });
    tempCtx.globalCompositeOperation='source-over'; // Reset composite operation
    tempCtx.clearRect(-1, -1, 2, 2);

    // Draw the temporary canvas onto the main game canvas (ctx)
    // Position using playerCursor's logical coordinates, draw with logical dimensions
    const smoothingEnabled = ctx.imageSmoothingEnabled; // Store current state
    ctx.imageSmoothingEnabled = false;
    // ctx.mozImageSmoothingEnabled = false; // Firefox
    // ctx.webkitImageSmoothingEnabled = false; // Chrome/Safari
    // ctx.msImageSmoothingEnabled = false; // IE/Edge

    ctx.drawImage(tempCanvas, playerCursor.x - cOR, playerCursor.y - cOR, cOR * 2, cOR * 2);

    ctx.imageSmoothingEnabled = smoothingEnabled; // Restore original state
    // ctx.mozImageSmoothingEnabled = smoothingEnabled;
    // ctx.webkitImageSmoothingEnabled = smoothingEnabled;
    // ctx.msImageSmoothingEnabled = smoothingEnabled;
}

function fnGL(timestamp){
    if(!gameRunning||!gameModeActive)return;
    if(gamePaused){animationFrameId=requestAnimationFrame(fnGL);return;}
    const dTS=(timestamp-lastTime)/1000;
    lastTime=timestamp;

    fnUGP(dTS, elapsedGameTimeMs);
    if(dropper1)fnUSD(dropper1,dTS,true);
    if(dropper2)fnUSD(dropper2,dTS,false);
    if(bucket)fnUBkt(dTS);
    fnUB(dTS);

    if (playerCursor) {
        fnACWP(playerCursor.x, playerCursor.y, elapsedGameTimeMs); // Pass elapsedGameTimeMs
    }
    fnUCWP(dTS);

    if(currentGameMode==='classic'){fnUPGP(dTS);fnUPI();}
    fnUAP(dTS);

    gameCtx.clearRect(0,0,gameWidth,gameHeight);
    fnDAP(gameCtx);
    if(bucket)fnDBkt(gameCtx,bucket);
    fnDCWP(gameCtx);
    if(playerCursor)fnDPC(gameCtx);
    fnDB(gameCtx);
    if(dropper1)fnDSD(gameCtx,dropper1);
    if(dropper2)fnDSD(gameCtx,dropper2);
    fnUUI();
    if(lives<=0){fnEG();return;}
    animationFrameId=requestAnimationFrame(fnGL);
}

function fnSRP(replayDataToPlay, isFromImport = false) {
    if (!replayDataToPlay) {
        return;
    }

    let verboseReplay;
    if (isFromImport || (replayDataToPlay.v === REPLAY_FORMAT_VERSION && replayDataToPlay.e)) {
        verboseReplay = fnDecodeReplayData(replayDataToPlay);
        if (!verboseReplay) {
            fnSS('home');
            return;
        }
    } else if (replayDataToPlay.events) {
        verboseReplay = replayDataToPlay;
    } else {
        fnSS('home');
        return;
    }

    fnSS('replayViewer');
    rVState.activeReplay = verboseReplay;
    const originalEquippedCosmetics = { ...currentEquippedCosmetics };
    currentEquippedCosmetics = {
        ...R_COSMETIC_DEFAULTS,
        ...R_SFX_DEFAULTS
    };
    if (verboseReplay.cosmetics) {
        Object.keys(verboseReplay.cosmetics).forEach(key => {
            if (currentEquippedCosmetics.hasOwnProperty(key)) {
                currentEquippedCosmetics[key] = verboseReplay.cosmetics[key];
            }
        });
    }
    if (verboseReplay.sfx) {
        Object.keys(verboseReplay.sfx).forEach(key => {
            if (currentEquippedCosmetics.hasOwnProperty(key)) {
                 currentEquippedCosmetics[key] = verboseReplay.sfx[key];
            }
        });
    }
    rVState.originalEquippedCosmetics = originalEquippedCosmetics;
    rVState.isPlaying = false;
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    rVState.currentTimeMs = 0;
    rVState.totalDurationMs = verboseReplay.events[verboseReplay.events.length - 1]?.t || 0;
    if (rVState.totalDurationMs === 0 && verboseReplay.finalTimeMs) {
        rVState.totalDurationMs = verboseReplay.finalTimeMs;
    }
    rVState.keysPressedReplay = {};
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;

    fnAREUTT(0, true);

    fnSetReplayButtonIcon(false);
    if (replaySeekBar) {
         replaySeekBar.value = 0;
    }

    if (gameScreenDeleteReplayBtnInOverlay) {
        gameScreenDeleteReplayBtnInOverlay.style.display = 'flex';
    }

    redrawStaticFrame();
    fnURUI();
    fnUPI();
}

function fnStopRP() {
    if(rAnimId)cancelAnimationFrame(rAnimId); rAnimId=null;
    rVState.activeReplay=null; rVState.isPlaying=false;
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    uiOverlayElem.classList.remove('replay-mode');
    powerupIconsContainerElem.classList.remove('replay-mode');
    replayControlsContainerElem.style.display='none';
    fnSetReplayButtonIcon(false);
    gameModeActive=false;
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;
    balls.length = 0;
    for (const type in activePowerups) {
        activePowerups[type].active = false;
        activePowerups[type].endTime = 0;
        if (type === 'oneColor') activePowerups.oneColor.color = null;
    }
    cBktWR = _BBWRN;
    cBllSS = _OBSS;
    rVState.isReplayDoublePointsActive = false;

    if (gameScreenDeleteReplayBtnInOverlay) {
        gameScreenDeleteReplayBtnInOverlay.style.display = 'none';
    }

    fnUPI();
    if (rVState.originalEquippedCosmetics) {
        currentEquippedCosmetics = { ...rVState.originalEquippedCosmetics };
        delete rVState.originalEquippedCosmetics;
    } else {
        currentEquippedCosmetics = { ...R_COSMETIC_DEFAULTS, ...R_SFX_DEFAULTS };
    }
    fnSCS();
}

function fnAREUTT(targetTimeMs, fullReset = false) {
    if (!rVState.activeReplay) return;

    const allowSoundAtReplayEndCondition = rVState.activeReplay && !rVState.isPlaying && !rVState.isSeeking && (targetTimeMs >= rVState.totalDurationMs);

    if (fullReset) {
        fnIPRNG(rVState.activeReplay.gameSeed);
        fnRGSR(true);

        rVState.nextEventIndex = 0;
        rVState.lastProcessedMouseTime = -1;

        const firstMouseEvent = rVState.activeReplay.events.find(e => e.type === 'mouse');
        const initialMouseX = firstMouseEvent ? firstMouseEvent.x : (playerCursor?.x || gameWidth / 2);
        const initialMouseY = firstMouseEvent ? firstMouseEvent.y : (playerCursor?.y || gameHeight / 2);
        rVState.prevReplayMouse = { x: initialMouseX, y: initialMouseY, t: 0 };
        let foundNextMouse = false;
        for (let i = 0; i < rVState.activeReplay.events.length; i++) {
            if (rVState.activeReplay.events[i].type === 'mouse') {
                rVState.nextReplayMouse = { ...rVState.activeReplay.events[i] };
                foundNextMouse = true;
                break;
            }
        }
        if (!foundNextMouse) {
            rVState.nextReplayMouse = { ...rVState.prevReplayMouse };
        }

        rVState.keysPressedReplay = {};
        rVState.isReplayDoublePointsActive = false;

        let simulatedTimeMs = 0;
        let currentReplayEventStreamIndex = 0;

        while (simulatedTimeMs < targetTimeMs) {
            const deltaTimeMs = Math.min(REPLAY_SIM_STEP_MS, targetTimeMs - simulatedTimeMs);
            const deltaTimeS = deltaTimeMs / 1000;
            const currentTimeStepTarget = simulatedTimeMs + deltaTimeMs;

            for (let i = currentReplayEventStreamIndex; i < rVState.activeReplay.events.length; i++) {
                const event = rVState.activeReplay.events[i];
                if (event.t >= currentTimeStepTarget) {
                    currentReplayEventStreamIndex = i;
                    break;
                }
                if (event.type === 'mouse') {
                    if (event.t >= rVState.lastProcessedMouseTime) {
                        rVState.prevReplayMouse = { x: event.x, y: event.y, t: event.t };
                        rVState.lastProcessedMouseTime = event.t;
                        rVState.nextReplayMouse = { ...rVState.prevReplayMouse };
                        for (let j = i + 1; j < rVState.activeReplay.events.length; j++) {
                            if (rVState.activeReplay.events[j].type === 'mouse') {
                                rVState.nextReplayMouse = { ...rVState.activeReplay.events[j] };
                                break;
                            }
                        }
                    }
                } else if (event.type === 'keydown') {
                    rVState.keysPressedReplay[event.key] = true;
                } else if (event.type === 'keyup') {
                    rVState.keysPressedReplay[event.key] = false;
                } else if (event.type === 'scoreLivesUpdate') {
                    if (event.lives < rVState.lives) {
                        let prevEvent = rVState.activeReplay.events[i-1];
                        let alreadyPlayedSoundForDespawn = false;
                        if (prevEvent && prevEvent.type === 'ballDespawn' && Math.abs(prevEvent.t - event.t) < REPLAY_SIM_STEP_MS*2) {
                            if (prevEvent.reason === 'collectedWheelWrong' || prevEvent.reason === 'missedOffScreen_LifeLoss') {
                                alreadyPlayedSoundForDespawn = true;
                            }
                        }
                        if (!alreadyPlayedSoundForDespawn) {
                            if (rVState.isPlaying || rVState.isSeeking || (allowSoundAtReplayEndCondition && event.lives < rVState.lives)) {
                                fnPS('loseLife');
                            }
                        }
                    }
                    rVState.score = event.score;
                    rVState.lives = event.lives;
                } else if (event.type === 'powerupActivate') {
                    const typesFromGRPUT = ['slowFall', 'wideBucket', 'oneColor', 'doublePoints', 'extraLives', 'whiteBallMagnet'];
                    if (typesFromGRPUT.includes(event.powerupType)) fnSRnd();
                    if (event.powerupType === 'oneColor') fnSRnd();
                    fnAPU(event.powerupType, true, event);
                } else if (event.type === 'powerupDeactivate') {
                    if(activePowerups[event.powerupType]) {
                        activePowerups[event.powerupType].active = false;
                        if (event.powerupType === 'wideBucket') { cBktWR = _BBWRN; if(bucket) bucket.baseWidth = gameWidth * cBktWR; }
                        if (event.powerupType === 'slowFall') {
                            balls.forEach(b => { if(b.originalVy) b.vy = b.originalVy; });
                            cBllSS = _OBSS;
                        }
                        if (event.powerupType === 'oneColor') { activePowerups.oneColor.color = null; }
                        if (event.powerupType === 'doublePoints') rVState.isReplayDoublePointsActive = false;
                    }
                } else if (event.type === 'ballSpawn' && rVState.activeReplay.v >= 2) {
                    if (rVState.isPlaying || rVState.isSeeking) fnPS('drop');
                    const mode = rVState.activeReplay.gameMode;
                    const isPrimary = (event.dropperId === dropper1.id);
                    if (mode === 'hardcore') { fnSRnd(); }
                    else { fnSRnd();
                        if (isPrimary && event.isPowerup === false && (!activePowerups.oneColor.active || !activePowerups.oneColor.color)) {
                           fnSRnd();
                        }
                    }
                    fnSRnd(); fnSRnd(); fnSRnd(); fnSRnd();
                    const spawningDropper = event.dropperId === dropper1.id ? dropper1 : dropper2;
                    if (!spawningDropper) continue;
                    const newBall = {
                        id: event.id,
                        x: spawningDropper.x + spawningDropper.width / 2,
                        y: spawningDropper.y + spawningDropper.height,
                        radius: BALL_RADIUS_BASE * event.sizeMultiplier,
                        colorHex: event.colorHex,
                        colorName: event.colorName,
                        originalVy: gameHeight / event.fallSpeedFactor,
                        isPowerup: event.isPowerup,
                        swayOffset: 0,
                        swayTime: event.swayTime,
                        vx_sway_direction: event.vx_sway_direction,
                        spawnTimeMs: event.t
                    };
                    newBall.vy = (mode === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
                    balls.push(newBall);
                } else if (event.type === 'ballDespawn' && rVState.activeReplay.v >= 2) {
                    const ballIndex = balls.findIndex(b => b.id === event.ballId);
                    if (ballIndex !== -1) {
                        balls.splice(ballIndex, 1);
                        if (rVState.isPlaying || rVState.isSeeking || allowSoundAtReplayEndCondition) {
                            switch(event.reason) {
                                case 'collectedWheelCorrect': case 'collectedWheelWhite': fnPS(rVState.isReplayDoublePointsActive ? 'collectGoodDouble' : 'collectGood'); break;
                                case 'collectedBucket': fnPS('collectBucket'); break;
                                case 'collectedPowerupWheel': case 'collectedPowerupBucket': fnPS('powerupCollect'); break;
                                case 'collectedWheelWrong': fnPS('loseLife'); break;
                                case 'missedOffScreen_LifeLoss': fnPS('loseLife'); break;
                            }
                        }
                    }
                }
                if (i === rVState.activeReplay.events.length - 1) currentReplayEventStreamIndex = i + 1;
            }
            rVState.nextEventIndex = currentReplayEventStreamIndex;

            const tempActualCurrentTime = rVState.currentTimeMs;
            rVState.currentTimeMs = currentTimeStepTarget;
            fnIMFR();
            rVState.currentTimeMs = tempActualCurrentTime;

            fnUGP(deltaTimeS, simulatedTimeMs);
            if (dropper1) fnUSD(dropper1, deltaTimeS, true);
            if (dropper2) fnUSD(dropper2, deltaTimeS, false);
            if (bucket) fnUBkt(deltaTimeS);
            fnUB(deltaTimeS);

            if (playerCursor) {
                fnACWP(playerCursor.x, playerCursor.y, currentTimeStepTarget); // Pass currentTimeStepTarget
            }
            fnUCWP(deltaTimeS);

            if (rVState.activeReplay.gameMode === 'classic') { fnUPGP(deltaTimeS); }
            fnUAP(deltaTimeS);

            simulatedTimeMs = currentTimeStepTarget;
        }
        fnUPI();
    } else {
        for (let i = rVState.nextEventIndex; i < rVState.activeReplay.events.length; i++) {
            const event = rVState.activeReplay.events[i];
            if (event.t > targetTimeMs) {
                rVState.nextEventIndex = i; break;
            }
            if (event.type === 'mouse') {
                if (event.t >= rVState.lastProcessedMouseTime) {
                    rVState.prevReplayMouse = { x: event.x, y: event.y, t: event.t };
                    rVState.lastProcessedMouseTime = event.t;
                    rVState.nextReplayMouse = { ...rVState.prevReplayMouse };
                    for (let j = i + 1; j < rVState.activeReplay.events.length; j++) {
                        if (rVState.activeReplay.events[j].type === 'mouse') {
                            rVState.nextReplayMouse = { ...rVState.activeReplay.events[j] };
                            break;
                        }
                    }
                }
            } else if (event.type === 'keydown') { rVState.keysPressedReplay[event.key] = true;
            } else if (event.type === 'keyup') { rVState.keysPressedReplay[event.key] = false;
            } else if (event.type === 'scoreLivesUpdate') {
                if (event.lives < rVState.lives) {
                    let prevEvent = rVState.activeReplay.events[i-1];
                    let alreadyPlayedSoundForDespawn = false;
                     if (prevEvent && prevEvent.type === 'ballDespawn' && Math.abs(prevEvent.t - event.t) < REPLAY_SIM_STEP_MS*2) {
                        if (prevEvent.reason === 'collectedWheelWrong' || prevEvent.reason === 'missedOffScreen_LifeLoss') {
                            alreadyPlayedSoundForDespawn = true;
                        }
                    }
                    if (!alreadyPlayedSoundForDespawn) {
                        if (rVState.isPlaying || rVState.isSeeking || (allowSoundAtReplayEndCondition && event.lives < rVState.lives)) {
                            fnPS('loseLife');
                        }
                    }
                }
                rVState.score = event.score; rVState.lives = event.lives;
            } else if (event.type === 'powerupActivate') {
                const typesFromGRPUT = ['slowFall','wideBucket','oneColor','doublePoints','extraLives','whiteBallMagnet'];
                if(typesFromGRPUT.includes(event.powerupType)) fnSRnd();
                if(event.powerupType === 'oneColor') fnSRnd();
                fnAPU(event.powerupType, true, event);
            } else if (event.type === 'powerupDeactivate') {
                 if(activePowerups[event.powerupType]) {
                    activePowerups[event.powerupType].active = false;
                    if (event.powerupType === 'wideBucket') { cBktWR = _BBWRN; if(bucket) bucket.baseWidth = gameWidth * cBktWR; }
                    if (event.powerupType === 'slowFall') { balls.forEach(b => { if(b.originalVy) b.vy = b.originalVy; }); cBllSS = _OBSS; }
                    if (event.powerupType === 'oneColor') { activePowerups.oneColor.color = null; }
                    if (event.powerupType === 'doublePoints') rVState.isReplayDoublePointsActive = false;
                }
            } else if (event.type === 'ballSpawn' && rVState.activeReplay.v >=2) {
                if (rVState.isPlaying || rVState.isSeeking) fnPS('drop');
                const mode = rVState.activeReplay.gameMode;
                const isPrimary = (event.dropperId === dropper1.id);
                if (mode === 'hardcore') { fnSRnd(); }
                else { fnSRnd();
                    if (isPrimary && event.isPowerup === false && (!activePowerups.oneColor.active || !activePowerups.oneColor.color)) {
                        fnSRnd();
                    }
                }
                fnSRnd(); fnSRnd(); fnSRnd(); fnSRnd();
                const spawningDropper = event.dropperId === dropper1.id ? dropper1 : dropper2;
                if (!spawningDropper) continue;
                const newBall = { id: event.id, x: spawningDropper.x + spawningDropper.width / 2, y: spawningDropper.y + spawningDropper.height, radius: BALL_RADIUS_BASE * event.sizeMultiplier, colorHex: event.colorHex, colorName: event.colorName, originalVy: gameHeight / event.fallSpeedFactor, isPowerup: event.isPowerup, swayOffset: 0, swayTime: event.swayTime, vx_sway_direction: event.vx_sway_direction, spawnTimeMs: event.t };
                newBall.vy = (mode === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
                balls.push(newBall);
            } else if (event.type === 'ballDespawn' && rVState.activeReplay.v >= 2) {
                const ballIndex = balls.findIndex(b => b.id === event.ballId);
                if (ballIndex !== -1) {
                     balls.splice(ballIndex, 1);
                    if (rVState.isPlaying || rVState.isSeeking || allowSoundAtReplayEndCondition) {
                        switch(event.reason) {
                            case 'collectedWheelCorrect': case 'collectedWheelWhite': fnPS(rVState.isReplayDoublePointsActive ? 'collectGoodDouble' : 'collectGood'); break;
                            case 'collectedBucket': fnPS('collectBucket'); break;
                            case 'collectedPowerupWheel': case 'collectedPowerupBucket': fnPS('powerupCollect'); break;
                            case 'collectedWheelWrong': fnPS('loseLife'); break;
                            case 'missedOffScreen_LifeLoss': fnPS('loseLife'); break;
                        }
                    }
                }
            }
            if (i === rVState.activeReplay.events.length - 1) { rVState.nextEventIndex = i + 1; }
        }
    }
}


function fnIMFR() {
    if (!rVState.activeReplay || !playerCursor) return;

    const cT = rVState.currentTimeMs;
    const p = rVState.prevReplayMouse; 
    const n = rVState.nextReplayMouse; 

    if (!p || !n) { 
        if (playerCursor && gameWidth && gameHeight) {
            playerCursor.x = gameWidth / 2;
            playerCursor.y = gameHeight / 2;
        }
        return;
    }

    let rawX, rawY;

    if (cT <= p.t) {
        rawX = p.x;
        rawY = p.y;
    } else if (cT >= n.t) {
        rawX = n.x;
        rawY = n.y;
    } else {
        const timeDiff = n.t - p.t;
        if (timeDiff <= 0) { 
            rawX = p.x;
            rawY = p.y;
        } else {
            const factor = (cT - p.t) / timeDiff;
            rawX = p.x + (n.x - p.x) * factor;
            rawY = p.y + (n.y - p.y) * factor;
        }
    }

    if (rVState.activeReplay.originalGameWidth && rVState.activeReplay.originalGameHeight) {
        const scaleX = gameWidth / rVState.activeReplay.originalGameWidth;
        const scaleY = gameHeight / rVState.activeReplay.originalGameHeight;
        playerCursor.x = rawX * scaleX;
        playerCursor.y = rawY * scaleY;
    } else {
        playerCursor.x = rawX;
        playerCursor.y = rawY;
    }
    
    playerCursor.x = Math.max(0, Math.min(gameWidth, playerCursor.x));
    playerCursor.y = Math.max(0, Math.min(gameHeight, playerCursor.y));
}

function fnURUI() { if(!rVState.activeReplay)return; fnUUI(); }

function fnRGL(timestamp) {
    if (!rVState.activeReplay) {
         if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null; return;
    }

    if (rVState.isPlaying && rVState.justSeeked) {
        rVState.justSeeked = false;
    }

    if (!rVState.isPlaying) {
        if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null;
        if (!rVState.justSeeked) {
            redrawStaticFrame();
        }
        if (rVState.justSeeked) {
             rVState.justSeeked = false;
        }
        return;
    }

    const dTS = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    const previousCurrentTimeMs = rVState.currentTimeMs;
    let newCurrentTimeMs = previousCurrentTimeMs + dTS * 1000;

    const effectiveDTS = (newCurrentTimeMs >= rVState.totalDurationMs) ?
                         Math.max(0, (rVState.totalDurationMs - previousCurrentTimeMs) / 1000.0) :
                         dTS;

    rVState.currentTimeMs = Math.min(newCurrentTimeMs, rVState.totalDurationMs);

    fnAREUTT(rVState.currentTimeMs, false);
    fnIMFR();

    fnUGP(effectiveDTS, previousCurrentTimeMs);
    if (dropper1) fnUSD(dropper1, effectiveDTS, true);
    if (dropper2) fnUSD(dropper2, effectiveDTS, false);
    if (bucket) fnUBkt(effectiveDTS);
    fnUB(effectiveDTS);

    if (playerCursor) {
        fnACWP(playerCursor.x, playerCursor.y, rVState.currentTimeMs); // Pass rVState.currentTimeMs
    }
    fnUCWP(effectiveDTS);
    if (rVState.activeReplay.gameMode === 'classic') { fnUPGP(effectiveDTS); }
    fnUAP(effectiveDTS);

    fnUPI();

    gameCtx.clearRect(0, 0, gameWidth, gameHeight);
    fnDAP(gameCtx);
    if (bucket) fnDBkt(gameCtx, bucket);
    fnDCWP(gameCtx);
    if (playerCursor) fnDPC(gameCtx);
    fnDB(gameCtx);
    if (dropper1) fnDSD(gameCtx, dropper1);
    if (dropper2) fnDSD(gameCtx, dropper2);
    if (rVState.activeReplay.gameMode === 'classic') { fnDPGP(gameCtx); }

    fnURUI();

    if (rVState.currentTimeMs >= rVState.totalDurationMs) {
        rVState.isPlaying = false;
        fnSetReplayButtonIcon(false);
        if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null;
        if (rVState.justSeeked) rVState.justSeeked = false;
        return;
    }

    if (rVState.isPlaying) {
        rAnimId = requestAnimationFrame(fnRGL);
    } else {
        if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null;
        redrawStaticFrame();
        if (rVState.justSeeked) rVState.justSeeked = false;
    }
}

function getSharedNote(timestamp, mode) {
    if (timestamp === undefined || mode === undefined) return "";
    const notes = JSON.parse(localStorage.getItem('orbilaSharedNotes') || '{}');
    const compositeKey = `${mode}_${timestamp}`;
    return notes[compositeKey] || "";
}

function saveSharedNote(timestamp, mode, noteText) {
    if (timestamp === undefined || mode === undefined) return;
    let notes = JSON.parse(localStorage.getItem('orbilaSharedNotes') || '{}');
    const compositeKey = `${mode}_${timestamp}`;

    if (noteText.trim() === "") {
        delete notes[compositeKey]; // Remove note if empty
    } else {
        notes[compositeKey] = noteText;
    }
    try {
        localStorage.setItem('orbilaSharedNotes', JSON.stringify(notes));
    } catch (e) {
        console.error("Error saving shared note to localStorage:", e);
    }
}

window.onload=()=>{
    canvasArea = document.getElementById('canvasArea'); gameCanvas=document.getElementById('gameCanvas'); gameCtx=gameCanvas.getContext('2d'); aCvs=document.getElementById('atmosphericCanvas'); aCtx=aCvs.getContext('2d');
    qualitySelectElement = document.getElementById('qualitySelect');
    screens.home=document.getElementById('homeScreen'); screens.game=document.getElementById('gameScreen');
    screens.settings=document.getElementById('settingsScreen'); screens.highScores=document.getElementById('highScoresScreen');
    screens.howToPlay=document.getElementById('howToPlayScreen'); screens.replays=document.getElementById('replaysScreen');
    screens.appearance=document.getElementById('appearanceScreen');
    gameScreenDeleteReplayBtnInOverlay = document.getElementById('gameScreenDeleteReplayBtnInOverlay');
    gameOverScreen = document.getElementById('gameOverScreen');
    pauseOverlay = document.getElementById('pauseOverlay');

    uiOverlayElem = document.getElementById('uiOverlay'); powerupIconsContainerElem = document.getElementById('powerupIconsContainer'); replayControlsContainerElem = document.getElementById('replayControlsContainer');
    scoreDisplay=document.getElementById('scoreDisplay'); timeDisplay=document.getElementById('timeDisplay'); livesDisplay=document.getElementById('livesDisplay'); finalScoreDisplay=document.getElementById('finalScoreDisplay'); finalTimeDisplay=document.getElementById('finalTimeDisplay'); gameOverQuitBtn=document.getElementById('gameOverQuitBtn'); saveReplayBtnElem = document.getElementById('saveReplayBtn');
    volumeSlider=document.getElementById('volumeSlider'); volumeValueDisplay=document.getElementById('volumeValueDisplay'); sensitivitySlider=document.getElementById('sensitivitySlider'); sensitivityValueDisplay=document.getElementById('sensitivityValueDisplay');
    keybindLeftBtn=document.getElementById('keybindLeftBtn'); keybindRightBtn=document.getElementById('keybindRightBtn'); keybindMaxSpeedBtn=document.getElementById('keybindMaxSpeedBtn'); keybindPauseBtn=document.getElementById('keybindPauseBtn');
    newHighScoreTextElem=document.getElementById('newHighScoreText'); powerupIconElems.slowFall=document.getElementById('slowFallIcon');powerupIconElems.wideBucket=document.getElementById('wideBucketIcon');powerupIconElems.oneColor=document.getElementById('oneColorIcon');powerupIconElems.doublePoints=document.getElementById('doublePointsIcon');powerupIconElems.whiteBallMagnet=document.getElementById('magnetIcon');
    quitConfirmationDialog=document.getElementById('quitConfirmationDialog'); confirmQuitBtn=document.getElementById('confirmQuitBtn'); cancelQuitBtn=document.getElementById('cancelQuitBtn'); gameScreenHomeBtn=document.getElementById('gameScreenHomeBtnInOverlay');
    modeSelectionDialogElem=document.getElementById('modeSelectionDialog');
    deleteReplayConfirmationDialog = document.getElementById('deleteReplayConfirmationDialog'); confirmDeleteReplayBtn = document.getElementById('confirmDeleteReplayBtn'); cancelDeleteReplayBtn = document.getElementById('cancelDeleteReplayBtn');
    deleteAllReplaysConfirmationDialog = document.getElementById('deleteAllReplaysConfirmationDialog'); confirmDeleteAllReplaysBtn = document.getElementById('confirmDeleteAllReplaysBtn'); cancelDeleteAllReplaysBtn = document.getElementById('cancelDeleteAllReplaysBtn');
    exportReplayDialog = document.getElementById('exportReplayDialog'); exportReplayTextArea = document.getElementById('exportReplayTextArea'); copyExportReplayBtn = document.getElementById('copyExportReplayBtn'); closeExportReplayBtn = document.getElementById('closeExportReplayBtn');
    importReplayDialog = document.getElementById('importReplayDialog'); importReplayTextArea = document.getElementById('importReplayTextArea'); importReplayError = document.getElementById('importReplayError'); importReplayAndPlayBtn = document.getElementById('importReplayAndPlayBtn'); cancelImportReplayBtn = document.getElementById('cancelImportReplayBtn');

    autosaveReplaysSelect = document.getElementById('autosaveReplaysSelect');
    autosaveThresholdElements = document.getElementById('autosaveThresholdElements');
    autosaveThresholdBtn = document.getElementById('autosaveThresholdBtn');

    replayPlayPauseBtn = document.getElementById('replayPlayPauseBtn'); replaySeekBar = document.getElementById('replaySeekBar'); replayTimeDisplayElem = document.getElementById('replayTimeDisplay');

    screenStack = [];

    fnLRS(); 
    initAudio(); 
    fnLS();    
    
    handleResize(); 
    fnUBS(); 

    fnSEL(); 
    
    setupCosmeticTabs(); 

    fnSS('home'); 
    isInitialLoad = false;

    document.addEventListener('visibilitychange',fnHVC);
    window.addEventListener('blur',fnHFC);
    window.addEventListener('focus',fnHFC);
    window.addEventListener('resize',handleResize);
    document.addEventListener('mousemove',(e)=>{
        lastKnownMouseX = e.clientX;
        lastKnownMouseY = e.clientY;

        if(gameModeActive && gameRunning && !gamePaused && playerCursor){
            const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return;
            const rect=gameCanvas.getBoundingClientRect();
            playerCursor.x=e.clientX-rect.left;
            playerCursor.y=e.clientY-rect.top;
        }
    });

    if (aCtx) {
        aCtx.clearRect(0,0,gameWidth,gameHeight);
        fnDTP(aCtx);
    }
    if (gameOverScreen && gameOverScreen.style.display === 'flex') {
        redrawStaticFrame();
    }
};
</script>
</body>
</html>
