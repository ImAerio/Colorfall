<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <title>Colorfall</title>
    <style>
        body{font-family:'Inter',sans-serif;background-color:#1a1a1a;color:#e0e0e0;margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}
        .screen{display:none;flex-direction:column;align-items:center;padding:20px;box-sizing:border-box;width:100%;max-width:1000px;text-align:center}
        #homeScreen{justify-content:center}
        .screen.active{display:flex !important}
        
        #gameScreenContainer { 
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px; 
        }
        #canvasArea { 
            position: relative;
            width: 100%; 
            height: auto; 
        }
        canvas#gameCanvas{border:1px solid #444;background:linear-gradient(80deg,#0f0e14,#211f29 23%,#211f29 30%,#1c1a24 50%,#211f29 70%,#211f29 77%,#0f0e14);cursor:none;position:relative;z-index:2; display: block;}
        #atmosphericCanvas{position:absolute;top:0;left:0;pointer-events:none;z-index:1; display: block;}
        
                
        #leaderboardsContainer {
            display:flex;
            justify-content: space-between; 
            width:100%;
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            padding-bottom:10px;
             
        }
        #replaysListContainerOuter { 
            display: flex; 
            flex-direction: column; 
            width: 100%; 
            flex-grow: 1; 
            overflow-y:auto; 
            min-height:0; 
            padding-bottom:10px;
        } 
        #replaysListContainer {
            display:flex;
            justify-content: space-between; 
            width:100%;
             
        }

        
        .leaderboard, .replay-category {
            width: 49%; 
            text-align:center; 
            margin-bottom: 20px;
        }
        .leaderboard:last-child, .replay-category:last-child {margin-bottom: 0;} 
        .leaderboard h3, #replaysScreen h3, #highScoresScreen h3, #appearanceScreen h3 {color:#61dafb;margin-top:0;margin-bottom:15px} 
        

        
        .leaderboard ol, .replays-mode-list {
            list-style-type:none;
            padding-left:0;
            margin:0 auto; 
            text-align:left;
            width: 100%; 
        }

        
        .replay-list-entry {
            list-style-type: none;
            margin-bottom: 6px; 
        }

        
        .score-list-entry {
            list-style-type: none;
            margin-bottom: 6px; 
        }
        
        .score-list-entry-ranked {
     display: flex;
     align-items: flex-start; /* Or center, depending on vertical alignment preference for rank vs content */
     /* flex-wrap: wrap; NO LONGER NEEDED HERE if wrapper handles vertical stack */
}

        .score-rank { 
            font-size: 1.4em; 
            font-weight: bold;
            color: #e0e0e0; 
            margin-right: 15px;
            margin-top: 15px; 
            min-width: 47px; 
            text-align: right; 
        }

        
        .item-content-box { 
            background-color:#333;
            padding: 8px 12px; 
            border-radius:3px;
            font-size:0.95em;
            word-break:break-word; 
            
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            
            min-height: 42px; 
            
            
            width: 100%; 
            box-sizing: border-box;
        }
.item-note-container {
    background-color: #444; /* Your preference */
    padding: 8px 12px;
    border-radius: 0 0 3px 3px;
    /* margin-top: 0; */ /* Remove or comment out margin-top */
    font-size: 0.9em;
    color: #e0e0e0;
    display: none;
    cursor: pointer;
    min-height: 20px;
    word-break: break-word;
    width: 100%;
    box-sizing: border-box;

    position: relative; /* <<< ADD: Allow z-index and top/bottom/left/right adjustments */
    top: -3px;          /* <<< ADD: Pulls the element up by 3px */
    z-index: 1;         /* <<< ADD: (Optional) Ensure it's above the content box if true overlap desired */
                        /* You might need a higher z-index if other elements interfere */
    /* border-top: none; */ /* Still relevant if you want no top border on the note itself */
}

.item-note-container.visible {
    display: block;
}

.note-placeholder-text {
    color: #e0e0e0;
    font-style: italic;
}

.note-editable-area {
    color: #e0e0e0;
    background-color: #3f3f3f;
    padding: 5px;
    border: 1px solid #555;
    border-radius: 3px;
    min-height: 20px;
    outline: none;
    width: calc(100% - 10px);
    box-sizing: border-box;
    cursor: text;
}
        
        .score-list-entry-ranked {
     display: flex; /* For rank and the content-box wrapper */
     flex-wrap: wrap; /* Allows note-container to wrap below the rank+content group */
     align-items: flex-start; /* Align items at the start of the cross axis */
}

        
        .item-info { 
            flex-grow: 1; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
        }
        .item-info div { 
            line-height: 1.3; 
        }

        .item-actions { 
            display: flex; 
            align-items: center; 
            margin-left: 10px; 
        }
        
        
        .item-actions button { 
            margin-left: 5px; 
            padding: 0; 
            width: 36px; height: 36px; 
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            border: none; border-radius: 4px;
            transition: background-color 0.2s;
        }
        
         

        
        .item-actions button.play-btn-geom { background-color: #28a745; }
        .item-actions button.play-btn-geom:hover { background-color: #218838; }
        .item-actions button.delete-btn-geom { background-color: #dc3545; }
        .item-actions button.delete-btn-geom:hover { background-color: #c82333; }
        .item-actions button.export-btn-geom { background-color: #17a2b8; } 
        .item-actions button.export-btn-geom:hover { background-color: #138496; }

button.copied-success {
            background-color: #28a745 !important; 
            
            
        }
        button.copied-success:hover {
            background-color: #28a745 !important; 
        }

        
        
        .play-svg-icon, .delete-svg-icon, .export-svg-icon, .import-svg-icon, .menu-btn-icon { 
             width: 20px; height: 20px; fill: white; stroke: white; 
        }
        #settingsBtn .menu-btn-icon { 
            width: 23px; height: 23px;
        }
        .delete-svg-icon { stroke-width: 1.5; }
        .export-svg-icon { stroke-width: 2.2; fill: none; } 
        .import-svg-icon { stroke-width: 2.2; fill: none; } 
        .menu-btn-icon { margin-right: 10px; }
        .cancel-svg-icon { width: 18px; height: 18px; margin-right: 8px; fill: white; }

        
        
        

        
        #uiOverlay{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;align-items:center;font-size:1.2em;color:#fff;pointer-events:none;background-color:rgba(0,0,0,0.3);padding:8px 15px;border-radius:5px;z-index:5}
        #uiOverlay.replay-mode { background: none; }
        #uiOverlay .game-stats{display:flex;align-items:center}
        #uiOverlay .game-stats > div{margin-right:25px}
        #uiOverlay .game-stats > div:last-child{margin-right:0}
        #gameScreenHomeBtnInOverlay {background-color:#007bff;color:white;border:none;border-radius:5px;cursor:pointer;padding:8px;width:42px;height:42px;display:flex;justify-content:center;align-items:center;transition:background-color 0.2s;margin:0;pointer-events:auto;align-self:center}
        #gameScreenHomeBtnInOverlay:hover {background-color:#0056b3}
        .home-svg-icon{width:24px;height:24px;fill:white} 
        #powerupIconsContainer{position:absolute;top:80px;left:15px;display:flex;flex-direction:column;gap:10px;pointer-events:none;z-index:5}
        #powerupIconsContainer.replay-mode { top: 80px; bottom: auto;}
        .powerup-icon{width:40px;height:40px;border:2px solid #555;background-color:rgba(0,0,0,0.4);display:flex;justify-content:center;align-items:center;font-size:1.2em;font-weight:bold;color:#777;border-radius:5px;transition:color 0.2s,border-color 0.2s,box-shadow 0.2s;position:relative;overflow:hidden}
        .powerup-icon.active{color:#fff;border-color:#FFDC00;box-shadow:0 0 8px #FFDC00}
        #oneColorIcon.active{color:#fff}
        .powerup-icon.flashing{animation:flashPowerup 0.3s ease-in-out infinite alternate}
        @keyframes flashPowerup{from{border-color:#FFDC00;box-shadow:0 0 10px #FFDC00;opacity:1}to{border-color:#777;box-shadow:0 0 3px #777;opacity:0.7}}
        #magnetIcon .magnet-body{width:60%;height:40%;border:5px solid #777777;border-bottom:none;border-radius:15px 15px 0 0;position:absolute;top:20%;left:50%;transform:translateX(-50%);box-sizing:border-box}
        #magnetIcon .magnet-pole{width:13%;height:10%;background-color:#777777;position:absolute;bottom:20%;box-sizing:border-box}
        #magnetIcon .magnet-pole-left{left:20%}
        #magnetIcon .magnet-pole-right{right:20%}
        #magnetIcon.active .magnet-body{border-color:white}
        #magnetIcon.active .magnet-pole{background-color:white}
        #gameOverScreen{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(0,0,0,0.85);padding:25px 30px;border-radius:10px;border:1px solid #555;z-index:100;display:flex;flex-direction:column;align-items:center;min-width:350px}
        #newHighScoreText{color:#FFDC00;font-size:1.3em;margin-bottom:10px}
        #gameOverScreen h2{margin-top:0;margin-bottom:20px;color:#61dafb;font-weight:700}
        #gameOverScoreTime{display:flex;justify-content:space-around;width:100%;margin-bottom:25px;font-size:1.1em}
        #gameOverButtons{display:flex;justify-content:center;width:100%; flex-wrap: wrap;}
        #gameOverButtons button{margin:5px 10px}
#gameOverScreen{
    position:absolute;
    top:50%;left:50%;transform:translate(-50%,-50%);
    background-color:rgba(0,0,0,0.85);
    padding:25px 30px;border-radius:10px;border:1px solid #555;
    z-index:100;display:flex;flex-direction:column;align-items:center;
    min-width: 400px; 
}

#gameOverButtons {
    display: flex;
    flex-direction: column; 
    align-items: center;  
    width: 100%;
}

.game-over-button-row { 
    display: flex;
    justify-content: center; 
    width: 100%;
    margin-bottom: 10px; 
}
.game-over-button-row:last-child {
    margin-bottom: 0; 
}


#gameOverButtons button { 
    margin: 5px; 
    min-width: 160px; 
}


#gameOverQuitBtn {
    
    
}
#autosaveThresholdBtn {
            font-family: inherit;
            background-color: #007bff; /* Blue background */
            color: white;
            border: none;
            padding: 0 15px; /* Horizontal padding, vertical controlled by height */
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 0;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
            text-align: center;
            height: 44px; /* Explicit height */
            box-sizing: border-box;
        }
        #autosaveThresholdBtn:hover {
            background-color: #0056b3;
        }
        /* Ensure the points text next to threshold button is aligned */
        #autosaveThresholdContainer .setting-control-group span {
            display: inline-flex;
            align-items: center;
            margin-left: 5px; /* Spacing after the button */
        }
#saveReplayBtn .menu-btn-icon,
#saveReplayBtn .btn-text {
    vertical-align: middle;
}


        #saveReplayBtn.saved { background-color: #28a745; cursor: default; }
        #saveReplayBtn.saved:hover { background-color: #28a745; }
        #gameOverQuitBtn{background-color:#dc3545}
        #gameOverQuitBtn:hover{background-color:#c82333}
        #slowFallIcon .up-arrow-shaft{position:absolute;width:6px;height:18px;background-color:#777;left:50%;bottom:8px;transform:translateX(-50%);transition:background-color 0.2s}
        #slowFallIcon .up-arrow-head{position:absolute;width:0;height:0;border-left:9px solid transparent;border-right:9px solid transparent;border-bottom:12px solid #777;left:50%;top:8px;transform:translateX(-50%);transition:border-bottom-color 0.2s}
        #slowFallIcon.active .up-arrow-shaft{background-color:white}
        #slowFallIcon.active .up-arrow-head{border-bottom-color:white}
        #wideBucketIcon .wide-bucket-base-angled{position:absolute;width:60%;height:12%;background-color:#777;bottom:30%;left:50%;transform:translateX(-50%);transition:background-color 0.2s}
        #wideBucketIcon .wide-bucket-side-angled{position:absolute;width:12%;height:30%;background-color:#777;bottom:33%;transition:background-color 0.2s}
        #wideBucketIcon .wide-bucket-left-angled{left:20%;transform-origin:bottom center;transform:rotate(-22.5deg)}
        #wideBucketIcon .wide-bucket-right-angled{right:20%;transform-origin:bottom center;transform:rotate(22.5deg)}
        #wideBucketIcon.active .wide-bucket-base-angled,
        #wideBucketIcon.active .wide-bucket-side-angled{background-color:white}
        #oneColorIcon .one-color-circle-shape{width:55%;height:55%;background-color:#777;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transition:background-color 0.2s}
        #oneColorIcon.active .one-color-circle-shape{background-color:white}
        
        button{font-family:inherit;background-color:#007bff;color:white;border:none;padding:12px 25px;font-size:1em;border-radius:5px;cursor:pointer;margin:10px;transition:background-color 0.2s; display: inline-flex; align-items: center; justify-content: center;}
        button:hover{background-color:#0056b3}
        .keybindBtn{min-width:80px;text-align:center; justify-content: center;} 
        .keybindBtn:disabled{background-color:#555;cursor:not-allowed}
        
        h1{color:#61dafb;font-weight:700;margin-bottom:25px}

        #settingsScreen, #highScoresScreen, #howToPlayScreen, #replaysScreen, #appearanceScreen {
    justify-content:flex-start;
    align-items:stretch; 
    max-height:100vh; 
    height: 100%; 
    padding-top: 0; 
    padding-bottom: 0; 
}
        
        
        .screen-header{
            display:flex;align-items:center;justify-content:center;
            width:100%; margin-bottom:25px;position:sticky; 
            top:0; 
            background-color: #1a1a1a; 
            z-index: 10; 
            padding-top: 20px; 
            padding-bottom: 10px; 
            box-sizing: border-box;
        } 
        .screen-header h2{text-align:center;color:#61dafb;font-weight:700;margin:0; flex-grow: 1;}
        .screen-header-btn {background-color:#007bff;color:white;border:none;border-radius:5px;cursor:pointer;padding:8px;width:42px;height:42px;display:flex;justify-content:center;align-items:center;transition:background-color 0.2s;margin:0;position:absolute;top:50%;transform:translateY(-50%);}
        .home-icon-btn{right:0;}
        .import-icon-btn{right: 52px; background-color: #17a2b8;} 
        .import-icon-btn:hover{background-color: #138496;}
        .screen-header-btn:hover{background-color:#0056b3}

        
        .scrollable-content-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            width: 100%;
            padding: 0 20px 20px 20px; 
            box-sizing: border-box;
        }

        .settings-content-wrapper{
            flex-grow:1;
            overflow-y:auto;
            min-height:0;
            width:100%;
            padding-bottom:10px
        }
        .settings-content-wrapper > div {
            background-color: #333;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 1.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            max-width: 600px;
            margin: 0 auto 15px auto;
        }
        .settings-content-wrapper label{
            margin-right: 20px;
            width: 220px;
            text-align: left;
            flex-shrink: 0;
            color: #e0e0e0;
        }
        .settings-content-wrapper input[type="range"]{vertical-align:middle;width:200px;cursor:pointer}
        .settings-content-wrapper .slider-value-display{min-width:30px;display:inline-block;text-align:left}

        .setting-control-group {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            flex-grow: 1;
        }
        .setting-control-group input[type="range"] {
            margin-right: 10px;
        }
        button.keybindBtn {
            font-family: inherit;
            background-color: #007bff; /* Blue background */
            color: white;
            border: none;
            padding: 0 15px; /* Horizontal padding, vertical controlled by height */
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 0;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
            text-align: center;
            height: 44px; /* Explicit height */
            box-sizing: border-box;
        }
        button.keybindBtn:hover {
            background-color: #0056b3;
        }
        button.keybindBtn:disabled{
            background-color:#555;
            cursor:not-allowed;
        }

        select.styled-select {
            font-family: inherit;
            background-color: #007bff; /* Blue background */
            color: white;             /* White text */
            border: none;
            padding-left: 15px;       /* Left padding */
            padding-right: 35px;      /* Right padding to make space for arrow */
            font-size: 1em;           /* Match keybindBtn font size */
            border-radius: 5px;
            cursor: pointer;
            min-width: 150px;
            height: 44px;             /* Explicit height to match keybind buttons */
            box-sizing: border-box;
            margin: 0;                /* Reset margin */

            /* Remove default system appearance for full styling control */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;

            /* Custom dropdown arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-13z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center; /* Position arrow */
            background-size: 10px 10px;             /* Size of the arrow */
        }

        select.styled-select:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        select.styled-select:focus {
            outline: none; /* Optional: remove focus outline if desired */
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5); /* Example focus style */
        }

        /* Ensure options within the select also pick up some basic styling if needed */
        select.styled-select option {
            background-color: #333; /* Or your preferred dropdown background */
            color: #e0e0e0;      /* Or your preferred dropdown text color */
        }

        /* Rule for keybind rows to make them shorter */
        .settings-content-wrapper > div.keybind-setting-row {
            padding-top: 8px;    /* Reduced top padding */
            padding-bottom: 8px; /* Reduced bottom padding */
        }
        #howToPlayScreenContent, #appearanceScreenContent {flex-grow:1;overflow-y:auto;min-height:0;width:100%;padding-right:15px;text-align:left;padding-bottom:20px}
        #howToPlayScreenContent > p, #howToPlayScreenContent > ul, #appearanceScreenContent > p {margin-bottom:15px;font-size:1.1em}
        #howToPlayScreenContent ul{list-style-position:inside;max-width:500px;margin-left:auto;margin-right:auto}
        #pauseOverlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);color:white;display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:2em;z-index:99;text-align:center}
        #pauseOverlay small{font-size:0.6em;margin-top:10px}
        .powerup-text-display{position:absolute;left:50%;top:40%;transform:translateX(-50%);font-size:2.5em;font-weight:bold;color:#FFDC00;text-shadow:0 0 5px black;pointer-events:none;z-index:101;opacity:1;animation:powerupTextAnim 1s forwards}
        @keyframes powerupTextAnim{0%{transform:translateX(-50%) scale(1);opacity:1}50%{transform:translateX(-50%) scale(1.1);opacity:1}100%{transform:translateX(-50%) scale(1.3);opacity:0}}
        
        #quitConfirmationDialog, #deleteReplayConfirmationDialog, #deleteAllReplaysConfirmationDialog, #exportReplayDialog, #importReplayDialog {
            position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(20,20,25,0.95);
            padding:25px 30px;border-radius:10px;border:1px solid #555;z-index:200;text-align:center;color:#e0e0e0;
            box-shadow:0 0 15px rgba(0,0,0,0.5);display:flex;flex-direction:column;align-items:center; min-width: 300px; max-width: 90vw;
        }
        #quitConfirmationDialog p, #deleteReplayConfirmationDialog p, #deleteAllReplaysConfirmationDialog p, #exportReplayDialog p, #importReplayDialog p {
             font-size:1.25em;margin-top:0;margin-bottom:25px
        }
        #quitConfirmationButtons, #deleteReplayConfirmationButtons, #deleteAllReplaysConfirmationButtons, #exportReplayButtons, #importReplayButtons {
            display:flex;justify-content:center; width:100%;
        }
        #quitConfirmationButtons button, #deleteReplayConfirmationButtons button, #deleteAllReplaysConfirmationButtons button, #exportReplayButtons button, #importReplayButtons button {
            margin:0 10px
        }
        #confirmQuitBtn, #confirmDeleteReplayBtn, #confirmDeleteAllReplaysBtn {background-color:#dc3545}
        #confirmQuitBtn:hover, #confirmDeleteReplayBtn:hover, #confirmDeleteAllReplaysBtn:hover {background-color:#c82333}
        #closeExportReplayBtn, {background-color:#007bff}
#closeExportReplayBtn:hover, {background-color:#0056b3}
        
        #exportReplayTextArea { width: 90%; min-height: 100px; max-height: 200px; margin-bottom: 15px; background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #444; font-family: monospace; resize: vertical;}
        #importReplayTextArea { width: 90%; min-height: 100px; max-height: 200px; margin-bottom: 15px; background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #444; font-family: monospace; resize: vertical;}
        #importReplayError {
            color: #dc3545;
            margin-top: 10px; /* This provides space below the textarea */
            font-size: 0.9em;
            min-height: 1.2em; /* Ensures it occupies space even when empty */
            position: relative; /* Enable offsetting */
            top: -15px; /* Move the text 5 pixels up from its normal position */
        }
        #importReplayAndPlayBtn { background-color: #28a745 !important; display: flex; align-items: center; justify-content: center; padding: 10px 15px !important;}
        #importReplayAndPlayBtn svg.play-svg-icon { margin-right: 8px; width:18px; height:18px;} 

        #modeSelectionDialog{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(20,20,25,0.95);padding:30px 40px;border-radius:10px;border:1px solid #555;z-index:250;text-align:center;color:#e0e0e0;box-shadow:0 0 20px rgba(0,0,0,0.6);flex-direction:column;align-items:center}
        #modeSelectionDialog h2{margin-top:0;margin-bottom:25px;color:#61dafb}
        #modeSelectionButtons{display:flex;justify-content:center;margin-bottom:10px}
        #modeSelectionButtons button{margin:0 15px;min-width:120px}
        
        #replayControlsContainer { 
            display: none; flex-direction: row; align-items: center; justify-content: center; 
            padding: 10px; background-color: rgba(0,0,0,0.5); width: 100%; 
            max-width: 800px; box-sizing: border-box; z-index: 6; height: 50px; 
        }
        #replayControlsContainer button { padding: 8px 15px; font-size: 0.9em; margin: 0 5px; }
#replayControlsContainer button#replayPlayPauseBtn {
    padding: 0;
    width: 36px; 
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 0;
}

.replay-control-svg-icon {
    width: 18px; 
    height: 18px;
}
        #replaySeekBar { flex-grow: 1; margin: 0 10px; cursor: pointer; }
        #replayTimeDisplay { font-size: 0.9em; color: #fff; min-width: 100px; text-align: center; }

        #deleteAllReplaysContainer { margin-top: 20px; width: 100%; display: flex; justify-content: center; }
        #deleteAllReplaysBtn { background-color: #dc3545; display:inline-flex; align-items:center; justify-content: center;}
        #deleteAllReplaysBtn:hover { background-color: #c82333; }
        #deleteAllReplaysBtn svg { margin-right: 8px; }


        
    #howToPlayBtn {
        background-color: #28a745; 
        margin-bottom: 40px; 
    }
    #howToPlayBtn:hover { background-color: #218838; }
    
    #howToPlayBtn, #howToPlayBtn .menu-btn-icon {
        color: #ffffff;
        fill: #ffffff;
        stroke: #ffffff;
    }


    #startGameBtn { background-color: #007bff; } 
    #startGameBtn:hover { background-color: #0056b3; }

    #appearanceBtn { background-color: #6f42c1; } 
    #appearanceBtn:hover { background-color: #5a32a3; }

    #settingsBtn { background-color: #17a2b8; } 
    #settingsBtn:hover { background-color: #138496; }

    #highScoresBtn {
        background-color: #ffc107;     }
    #highScoresBtn:hover { background-color: #e0a800; }
    #highScoresBtn .menu-btn-icon { 
        fill: #ffffff;
        stroke: #ffffff;
    }

    #replaysBtn { background-color: #fd7e14; } 
    #replaysBtn:hover { background-color: #e66800; }

    
    #startGameBtn .menu-btn-icon,
    #appearanceBtn .menu-btn-icon,
    #settingsBtn .menu-btn-icon,
    #replaysBtn .menu-btn-icon {
        fill: #ffffff;
        stroke: #ffffff;
    }

        
        #classicModeBtn { background-color: #28a745; } 
        #classicModeBtn:hover { background-color: #218838; }
        #hardcoreModeBtn { background-color: #dc3545; } 
        #hardcoreModeBtn:hover { background-color: #c82333; }
#cancelModeSelectionBtn,
#cancelDeleteAllReplaysBtn,
#cancelDeleteReplayBtn,
#cancelQuitBtn,
#closeExportReplayBtn,
#cancelImportReplayBtn { background-color: #6c757d; }
#cancelModeSelectionBtn:hover,
#cancelDeleteAllReplaysBtn:hover,
#cancelDeleteReplayBtn:hover,
#cancelQuitBtn:hover,
#closeExportReplayBtn:hover,
#cancelImportReplayBtn:hover { background-color: #5a6268; }


body #replaysScreen .screen-header .screen-header-btn { 
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    width: 42px !important; 
    height: 42px !important; 
    padding: 8px !important; 
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-width: auto !important; 
}

body #replaysScreen .screen-header .import-icon-btn .import-svg-icon { 
    width: 20px !important;
    height: 20px !important;
    
}


body #replaysScreen .replays-mode-list .replay-item .item-actions button { 
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important;
    margin: 0 0 0 5px !important; 
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-width: auto !important; 
    border-radius: 4px !important; 
}

body #replaysScreen .replays-mode-list .replay-item .item-actions button svg { 
    width: 20px !important;
    height: 20px !important;
    
}


body #replaysScreen .replays-mode-list .replay-item .item-actions button.play-btn-geom,
body #replaysScreen .replays-mode-list .replay-item .item-actions button.delete-btn-geom,
body #replaysScreen .replays-mode-list .replay-item .item-actions button.export-btn-geom {
    
    padding: 0 !important; 
}
.threshold-editable-area {
     /* Inherit button styles or set them explicitly to match */
     background-color: #007bff; /* Match keybindBtn background */
     color: white;             /* Match keybindBtn text color */
     border: none;             /* Match keybindBtn border */
     padding: 0 15px;        /* Match keybindBtn horizontal padding */
                              /* Vertical padding is often controlled by height/line-height */
     font-size: 1em;           /* Match keybindBtn font size */
     border-radius: 5px;       /* Match keybindBtn border-radius */
     cursor: text;             /* Keep text cursor */
     min-width: 80px;          /* Match keybindBtn min-width */
     height: 44px;             /* Match keybindBtn explicit height */
     box-sizing: border-box;
     text-align: center;       /* Match keybindBtn text-align */

     display: inline-flex;     /* To use align-items and justify-content like button */
     align-items: center;      /* Vertically center text */
     justify-content: center;  /* Horizontally center text (if width is more than content) */
     outline: none;            /* Remove focus outline on the div */
     /* vertical-align: middle; /* May not be needed if height and display:inline-flex is used */
 }
    </style>
</head>
<body>
    <div id="homeScreen" class="screen active">
        <h1>Colorfall</h1>
        <button id="howToPlayBtn">
            <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.00024">
                <g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM10.3027 13.3942C10.2316 13.7147 10.5038 14 10.8479 14H13.0406C13.2979 14 13.5151 13.8351 13.6064 13.6061C13.697 13.3789 14.0117 12.9674 14.254 12.7518C14.4827 12.5112 14.7213 12.2848 14.9563 12.0618C15.8824 11.183 16.754 10.356 16.754 8.91047C16.754 6.40301 14.582 5 12.2707 5C10.5038 5 8.06416 5.80604 7.58396 8.50363C7.48716 9.04737 7.94773 9.5 8.50002 9.5H9.91229C10.4388 9.5 10.8312 9.07642 11.0121 8.582C11.1863 8.10604 11.5379 7.7551 12.2707 7.7551C13.6066 7.7551 13.6064 9.22371 12.8346 10.1843C12.5434 10.5467 12.2023 10.8677 11.8648 11.1853C11.1798 11.8298 10.5098 12.4602 10.3027 13.3942ZM13.9999 17C13.9999 18.1046 13.1045 19 11.9999 19C10.8954 19 9.99994 18.1046 9.99994 17C9.99994 15.8954 10.8954 15 11.9999 15C13.1045 15 13.9999 15.8954 13.9999 17Z" fill="currentColor"></path> </g>
            </svg>
            How to Play
        </button>
        <button id="startGameBtn"> 
            <svg viewBox="0 0 24 24" class="menu-btn-icon play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path>
            </svg>
            Play
        </button>
        <button id="appearanceBtn"> 
            <svg class="menu-btn-icon" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve">
                 <g> <path d="M410.842,207.265c97.767-8.626,117.891-54.628,89.098-97.749C448.234,32.075,334.016,1.59,218.762,36.607 C73.721,80.672-22.226,214.687,4.453,335.938C31.13,457.19,170.334,519.762,315.375,475.697 c62.951-19.13,116.653-55.201,155.091-99.821c15.516-18.01,20.891-73.726-50.998-70.844 C342.812,308.106,332.197,214.206,410.842,207.265z M385.949,102.144c7.068-7.059,16.84-11.111,26.839-11.111 c9.998,0,19.762,4.052,26.838,11.111c7.067,7.076,11.119,16.848,11.119,26.847s-4.052,19.762-11.119,26.838 c-7.076,7.067-16.84,11.12-26.838,11.12c-9.999,0-19.771-4.052-26.839-11.12c-7.067-7.076-11.119-16.839-11.119-26.838 S378.882,109.22,385.949,102.144z M65.256,226.724c5.711-17.185,24.26-26.485,41.436-20.782 c17.185,5.711,26.493,24.261,20.79,41.437c-5.711,17.184-24.269,26.484-41.438,20.789C68.861,262.449,59.553,243.9,65.256,226.724z M127.946,377.433c-11.794,12.451-31.455,12.998-43.905,1.214c-12.459-11.793-12.998-31.446-1.204-43.896 c11.785-12.459,31.437-13.006,43.896-1.213C139.182,345.323,139.73,364.975,127.946,377.433z M190.542,171.051 c-15.466,11.128-37.031,7.606-48.159-7.86c-11.128-15.474-7.606-37.03,7.859-48.159v-0.008 c15.475-11.119,37.032-7.598,48.159,7.868C209.53,138.358,206.009,159.923,190.542,171.051z M250.461,105.589 c-2.317-19.88,11.919-37.857,31.8-40.165c19.872-2.308,37.857,11.929,40.165,31.8c2.316,19.872-11.928,37.856-31.801,40.164 C270.746,139.706,252.769,125.461,250.461,105.589z M360.897,377.106c0,12.121-4.911,23.948-13.478,32.524 c-8.567,8.566-20.411,13.478-32.533,13.478c-12.113,0-23.965-4.912-32.524-13.478c-8.566-8.576-13.478-20.403-13.478-32.524 c0-12.122,4.912-23.974,13.478-32.542c8.559-8.559,20.411-13.47,32.524-13.47c12.122,0,23.966,4.911,32.533,13.47 C355.986,353.131,360.897,364.983,360.897,377.106z"></path> </g>
            </svg>
            Cosmetic
        </button>
        <button id="settingsBtn">
            <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.00024">
                <g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M14.2788 2.15224C13.9085 2 13.439 2 12.5 2C11.561 2 11.0915 2 10.7212 2.15224C10.2274 2.35523 9.83509 2.74458 9.63056 3.23463C9.53719 3.45834 9.50065 3.7185 9.48635 4.09799C9.46534 4.65568 9.17716 5.17189 8.69017 5.45093C8.20318 5.72996 7.60864 5.71954 7.11149 5.45876C6.77318 5.2813 6.52789 5.18262 6.28599 5.15102C5.75609 5.08178 5.22018 5.22429 4.79616 5.5472C4.47814 5.78938 4.24339 6.1929 3.7739 6.99993C3.30441 7.80697 3.06967 8.21048 3.01735 8.60491C2.94758 9.1308 3.09118 9.66266 3.41655 10.0835C3.56506 10.2756 3.77377 10.437 4.0977 10.639C4.57391 10.936 4.88032 11.4419 4.88029 12C4.88026 12.5581 4.57386 13.0639 4.0977 13.3608C3.77372 13.5629 3.56497 13.7244 3.41645 13.9165C3.09108 14.3373 2.94749 14.8691 3.01725 15.395C3.06957 15.7894 3.30432 16.193 3.7738 17C4.24329 17.807 4.47804 18.2106 4.79606 18.4527C5.22008 18.7756 5.75599 18.9181 6.28589 18.8489C6.52778 18.8173 6.77305 18.7186 7.11133 18.5412C7.60852 18.2804 8.2031 18.27 8.69012 18.549C9.17714 18.8281 9.46533 19.3443 9.48635 19.9021C9.50065 20.2815 9.53719 20.5417 9.63056 20.7654C9.83509 21.2554 10.2274 21.6448 10.7212 21.8478C11.0915 22 11.561 22 12.5 22C13.439 22 13.9085 22 14.2788 21.8478C14.7726 21.6448 15.1649 21.2554 15.3694 20.7654C15.4628 20.5417 15.4994 20.2815 15.5137 19.902C15.5347 19.3443 15.8228 18.8281 16.3098 18.549C16.7968 18.2699 17.3914 18.2804 17.8886 18.5412C18.2269 18.7186 18.4721 18.8172 18.714 18.8488C19.2439 18.9181 19.7798 18.7756 20.2038 18.4527C20.5219 18.2105 20.7566 17.807 21.2261 16.9999C21.6956 16.1929 21.9303 15.7894 21.9827 15.395C22.0524 14.8691 21.9088 14.3372 21.5835 13.9164C21.4349 13.7243 21.2262 13.5628 20.9022 13.3608C20.4261 13.0639 20.1197 12.558 20.1197 11.9999C20.1197 11.4418 20.4261 10.9361 20.9022 10.6392C21.2263 10.4371 21.435 10.2757 21.5836 10.0835C21.9089 9.66273 22.0525 9.13087 21.9828 8.60497C21.9304 8.21055 21.6957 7.80703 21.2262 7C20.7567 6.19297 20.522 5.78945 20.2039 5.54727C19.7799 5.22436 19.244 5.08185 18.7141 5.15109C18.4722 5.18269 18.2269 5.28136 17.8887 5.4588C17.3915 5.71959 16.7969 5.73002 16.3099 5.45096C15.8229 5.17191 15.5347 4.65566 15.5136 4.09794C15.4993 3.71848 15.4628 3.45833 15.3694 3.23463C15.1649 2.74458 14.7726 2.35523 14.2788 2.15224ZM12.5 15C14.1695 15 15.5228 13.6569 15.5228 12C15.5228 10.3431 14.1695 9 12.5 9C10.8305 9 9.47716 10.3431 9.47716 12C9.47716 13.6569 10.8305 15 12.5 15Z" fill="currentColor"></path> </g>
            </svg>
            Settings
        </button>
        <button id="highScoresBtn">
            <svg class="menu-btn-icon" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" stroke-width="0.00064">
                <g id="SVGRepo_iconCarrier"> <path d="M60,4H48c0-2.215-1.789-4-4-4H20c-2.211,0-4,1.785-4,4H4C1.789,4,0,5.785,0,8v8c0,8.836,7.164,16,16,16 c0.188,0,0.363-0.051,0.547-0.059C17.984,37.57,22.379,41.973,28,43.43V56h-8c-2.211,0-4,1.785-4,4v4h32v-4c0-2.215-1.789-4-4-4h-8 V43.43c5.621-1.457,10.016-5.859,11.453-11.488C47.637,31.949,47.812,32,48,32c8.836,0,16-7.164,16-16V8C64,5.785,62.211,4,60,4z M8,16v-4h8v12C11.582,24,8,20.414,8,16z M56,16c0,4.414-3.582,8-8,8V12h8V16z"></path> </g>
            </svg>
            Personal Bests
        </button>
        <button id="replaysBtn"> 
             <svg viewBox="0 0 24 24" class="menu-btn-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                <rect x="1.71" y="2" width="20.57" height="14" rx="2"></rect>
                <rect x="9.43" y="16" width="5.14" height="4" rx="1"></rect>
                <rect x="5.55" y="20" width="12.88" height="2" rx="1"></rect>
            </svg>
            Replays
        </button>
    </div>

    <div id="gameScreen" class="screen"> 
        <div id="gameScreenContainer">
            <div id="canvasArea">
                <canvas id="atmosphericCanvas"></canvas>
                <canvas id="gameCanvas"></canvas>
                <div id="uiOverlay">
                    <div class="game-stats">
                        <div>Score: <span id="scoreDisplay">0</span></div>
                        <div>Time: <span id="timeDisplay">00:00.0</span></div>
                        <div>Lives: <span id="livesDisplay">❤❤❤</span></div>
                    </div>
                    <button id="gameScreenHomeBtnInOverlay" class="screen-header-btn home-icon-btn" title="Back to Home"> 
                        <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
                    </button>
                </div>
                <div id="powerupIconsContainer">
                    <div class="powerup-icon" id="slowFallIcon" title="Slow Fall (Vertical & Horizontal)"><div class="up-arrow-shaft"></div><div class="up-arrow-head"></div></div>
                    <div class="powerup-icon" id="wideBucketIcon" title="Wide Bucket"><div class="wide-bucket-base-angled"></div><div class="wide-bucket-side-angled wide-bucket-left-angled"></div><div class="wide-bucket-side-angled wide-bucket-right-angled"></div></div>
                    <div class="powerup-icon" id="oneColorIcon" title="One Color"><div class="one-color-circle-shape"></div></div>
                    <div class="powerup-icon" id="doublePointsIcon" title="Double Points">x2</div>
                    <div class="powerup-icon" id="magnetIcon" title="White Ball Magnet"><div class="magnet-body"></div><div class="magnet-pole magnet-pole-left"></div><div class="magnet-pole magnet-pole-right"></div></div>
                </div>
                <div id="gameOverScreen" style="display:none;">
                    <h2 id="gameOverTitle">Game Mode</h2> 
                    <div id="newHighScoreText" style="display:none;">New Personal Best!</div>
                    <div id="gameOverScoreTime">
                        <span>Score: <span id="finalScoreDisplay">0</span></span>
                        <span>Time: <span id="finalTimeDisplay">00:00.0</span></span>
                    </div>
                    <div id="gameOverButtons">
                        <div class="game-over-button-row">
                            <button id="playAgainBtn">
                                 <svg viewBox="-1.5 0 19 19" class="menu-btn-icon" version="1.1" xmlns="http://www.w3.org/2000/svg">
                                    <g stroke="none" stroke-width="1" fill-rule="evenodd">
                                        <g transform="translate(-1193.000000, -305.000000)">
                                            <g transform="translate(1189.000000, 302.000000)">
                                                <path d="M12,7 C15.8659932,7 19,10.1340068 19,14 C19,17.8659932 15.8659932,21 12,21 C8.13400675,21 5,17.8659932 5,14" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"> </path>
                                                <path d="M10.8260915,10.8857148 L5.69568021,7.30477744 C5.47956961,7.17854145 5.43577155,6.93976099 5.5978545,6.77144635 C5.62566353,6.74256812 5.65860149,6.71691486 5.69568021,6.69525619 L10.8260915,3.11431886 C11.1502574,2.92496489 11.610137,2.97613213 11.8532614,3.2286041 C11.948511,3.32751578 12,3.4478202 12,3.5714598 L12,10.4285738 C12,10.7441638 11.6715145,11 11.2663072,11 C11.1075579,11 10.9530909,10.9598985 10.8260915,10.8857148 Z" fill="#ffffff"> </path>
                                            </g>
                                        </g>
                                    </g>
                                </svg>
                                <span class="btn-text">Play Again</span>
                            </button>
                            <button id="saveReplayBtn" style="display: inline-block;"> 
                                <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 18 24" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="0.00024"><path d="M21,20V8.414a1,1,0,0,0-.293-.707L16.293,3.293A1,1,0,0,0,15.586,3H4A1,1,0,0,0,3,4V20a1,1,0,0,0,1,1H20A1,1,0,0,0,21,20ZM9,8h4a1,1,0,0,1,0,2H9A1,1,0,0,1,9,8Zm7,11H8V15a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1Z"></path></svg>
                                <span class="btn-text">Save Replay</span>
                            </button>
                        </div>
                        <button id="gameOverQuitBtn">
                            <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><g><path d="M510.371,226.513c-1.088-2.603-2.645-4.971-4.629-6.955l-63.979-63.979c-8.341-8.32-21.824-8.32-30.165,0 c-8.341,8.341-8.341,21.845,0,30.165l27.584,27.584H320.013c-11.797,0-21.333,9.557-21.333,21.333s9.536,21.333,21.333,21.333 h119.168l-27.584,27.584c-8.341,8.341-8.341,21.845,0,30.165c4.16,4.181,9.621,6.251,15.083,6.251s10.923-2.069,15.083-6.251 l63.979-63.979c1.984-1.963,3.541-4.331,4.629-6.955C512.525,237.606,512.525,231.718,510.371,226.513z"></path> <path d="M362.68,298.667c-11.797,0-21.333,9.557-21.333,21.333v106.667h-85.333V85.333c0-9.408-6.187-17.728-15.211-20.437 l-74.091-22.229h174.635v106.667c0,11.776,9.536,21.333,21.333,21.333s21.333-9.557,21.333-21.333v-128 C384.013,9.557,374.477,0,362.68,0H21.347c-0.768,0-1.451,0.32-2.197,0.405c-1.003,0.107-1.92,0.277-2.88,0.512 c-2.24,0.576-4.267,1.451-6.165,2.645c-0.469,0.299-1.045,0.32-1.493,0.661C8.44,4.352,8.376,4.587,8.205,4.715 C5.88,6.549,3.939,8.789,2.531,11.456c-0.299,0.576-0.363,1.195-0.597,1.792c-0.683,1.621-1.429,3.2-1.685,4.992 c-0.107,0.64,0.085,1.237,0.064,1.856c-0.021,0.427-0.299,0.811-0.299,1.237V448c0,10.176,7.189,18.923,17.152,20.907 l213.333,42.667c1.387,0.299,2.795,0.427,4.181,0.427c4.885,0,9.685-1.685,13.525-4.843c4.928-4.053,7.808-10.091,7.808-16.491 v-21.333H362.68c11.797,0,21.333-9.557,21.333-21.333V320C384.013,308.224,374.477,298.667,362.68,298.667z"></path></g></svg>
                            <span class="btn-text">Quit</span>
                        </button>
                    </div>
                </div>
                <div id="pauseOverlay" style="display:none;">Game Paused<small>(Press 'P' or Click to Resume)</small></div>
            </div>
            <div id="replayControlsContainer"> 
                <button id="replayPlayPauseBtn"></button>
                <input type="range" id="replaySeekBar" min="0" max="100" value="0">
                <span id="replayTimeDisplay">00:00.0 / 00:00.0</span>
            </div>
        </div>
    </div>
    
    <div id="settingsScreen" class="screen">
        <div class="screen-header"><h2>Settings</h2><button id="settingsToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home">
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div class="settings-content-wrapper scrollable-content-wrapper">
            <div>
                <label for="volumeSlider">Master Volume:</label>
                <span class="setting-control-group">
                    <input type="range" id="volumeSlider" min="0" max="100" value="70">
                    <span id="volumeValueDisplay" class="slider-value-display">70</span>
                </span>
            </div>
            <div>
                <label for="sensitivitySlider">Bucket Sensitivity:</label>
                <span class="setting-control-group">
                    <input type="range" id="sensitivitySlider" min="1" max="10" value="5">
                    <span id="sensitivityValueDisplay" class="slider-value-display">5</span>
                </span>
            </div>
            <div>
                <label for="qualitySelect">Graphics Quality:</label>
                <span class="setting-control-group">
                    <select id="qualitySelect" class="styled-select">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </span>
            </div>
            <div>
                <div style="display: flex; flex-direction: column; align-items: flex-start; width: 100%;">
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 8px;">
                        <label for="autosaveReplaysSelect" style="margin-right: 20px; width: 220px; text-align: left; flex-shrink: 0;">Autosave Replays:</label>
                        <span class="setting-control-group" style="justify-content: flex-end; flex-grow: 1;">
                            <select id="autosaveReplaysSelect" class="styled-select">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                        </span>
                    </div>

                    <div id="autosaveThresholdElements" style="display: none; justify-content: space-between; align-items: center; width: 100%; padding-left: 0px;">
                        <label for="autosaveThresholdBtn" style="margin-right: 20px; width: 220px; text-align: left; flex-shrink: 0;">Above score:</label>
                        <span class="setting-control-group" style="justify-content: flex-end; flex-grow: 1;">
                            <button class="keybindBtn" id="autosaveThresholdBtn" style="margin-right: 5px;">100</button>
                        </span>
                    </div>
                </div>
            </div>
            <div class="keybind-setting-row">
                <label>Move Bucket Left: </label>
                <span class="setting-control-group">
                    <button class="keybindBtn" id="keybindLeftBtn">A</button>
                </span>
            </div>
            <div class="keybind-setting-row">
                <label>Move Bucket Right: </label>
                <span class="setting-control-group">
                    <button class="keybindBtn" id="keybindRightBtn">D</button>
                </span>
            </div>
            <div class="keybind-setting-row">
                <label>Max Speed Toggle: </label>
                <span class="setting-control-group">
                    <button class="keybindBtn" id="keybindMaxSpeedBtn">W</button>
                </span>
            </div>
            <div class="keybind-setting-row">
                <label>Pause Game: </label>
                <span class="setting-control-group">
                    <button class="keybindBtn" id="keybindPauseBtn">P</button>
                </span>
            </div>
        </div>
    </div>
    <div id="highScoresScreen" class="screen">
        <div class="screen-header"><h2>Personal Bests</h2><button id="highScoresToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div id="leaderboardsContainer" class="scrollable-content-wrapper"> 
            <div class="leaderboard"><h3>Classic Mode</h3><ol id="classicHighScoresList"></ol></div>
            <div class="leaderboard"><h3>Hardcore Mode</h3><ol id="hardcoreHighScoresList"></ol></div>
        </div>
    </div>
    <div id="howToPlayScreen" class="screen">
        <div class="screen-header"><h2>How to Play</h2><button id="howToPlayToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div id="howToPlayScreenContent" class="scrollable-content-wrapper">
            <p><strong>Objective:</strong> Score as many points as possible before running out of lives!</p>
            <h3>Controls:</h3><ul><li>Use mouse for <strong>Color Wheel</strong>.</li><li><strong>'A'</strong>/<strong>'D'</strong> (or custom) for <strong>Bucket</strong>.</li><li>Hold <strong>'W'</strong> (or custom) for <strong>Max Speed</strong>.</li><li>Press <strong>'P'</strong> (or custom) to pause/resume.</li><li>Press <strong>'Escape'</strong> to go back a page.</li></ul>
            <h3>Gameplay (Classic Mode):</h3><ul><li>Balls from two droppers.</li><li>Primary: RGB, Yellow (power-up).</li><li>Secondary: White, Yellow (power-up).</li><li>Match Color Wheel to RGB balls.</li><li>White balls: any segment.</li><li>Bucket: safety net.</li><li>Difficulty increases.</li></ul>
            <h3>Gameplay (Hardcore Mode):</h3><ul><li>1 life.</li><li>Both droppers: RGB.</li><li>No power-ups.</li></ul>
            <h3>Scoring:</h3><ul><li>Color Wheel Catch: +3.</li><li>Bucket Catch: +1.</li></ul>
            <h3>Power-ups (Classic Mode):</h3><ul><li>Slow Fall.</li><li>Wide Bucket.</li><li>One Color.</li><li>Double Points.</li><li>Magnet (White balls).</li><li>+3 Lives.</li><li>Last 10 seconds.</li></ul>
            <h3>Losing Lives:</h3><ul><li>3 (Classic) / 1 (Hardcore) life.</li><li>Lose if: wrong Color Wheel segment; ball missed by Wheel & Bucket.</li><li>White/Power-up balls off screen: no life loss.</li><li>Game ends at 0 lives.</li></ul>
        </div>
    </div>
    <div id="appearanceScreen" class="screen">
        <div class="screen-header"><h2>Cosmetic</h2><button id="appearanceToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
             <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
        </button></div>
        <div id="appearanceScreenContent" class="scrollable-content-wrapper">
            <p>Cosmetic settings will be here soon!</p>
        </div>
    </div>
     <div id="replaysScreen" class="screen">
        <div class="screen-header">
            <button id="importReplaysBtn" class="screen-header-btn import-icon-btn" title="Import Replay">
                <svg viewBox="0 0 24 24" class="import-svg-icon" xmlns="http://www.w3.org/2000/svg">
                  <line x1="12" y1="5" x2="12" y2="15" stroke="white" stroke-width="3" stroke-linecap="round"/>
                  <polyline points="8 11 12 15 16 11" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                  <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <h2>Replays</h2>
            <button id="replaysToHomeBtnIcon" class="screen-header-btn home-icon-btn" title="Back to Home"> 
                 <svg fill="#ffffff" viewBox="0 0 24 24" class="home-svg-icon" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M12 3s-6.186 5.34-9.643 8.232c-.203.184-.357.452-.357.768 0 .553.447 1 1 1h2v7c0 .553.447 1 1 1h3c.553 0 1-.448 1-1v-4h4v4c0 .552.447 1 1 1h3c.553 0 1-.447 1-1v-7h2c.553 0 1-.447 1-1 0-.316-.154-.584-.383-.768-3.433-2.892-9.617-8.232-9.617-8.232z"></path></svg>
            </button>
        </div>
        <div id="replaysListContainerOuter" class="scrollable-content-wrapper">
            <div id="replaysListContainer">
                <div class="replay-category"><h3>Classic Mode</h3><ol id="classicReplaysList" class="replays-mode-list"></ol></div>
                <div class="replay-category"><h3>Hardcore Mode</h3><ol id="hardcoreReplaysList" class="replays-mode-list"></ol></div>
            </div>
            <div id="deleteAllReplaysContainer">
                <button id="deleteAllReplaysBtn">
                    <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                    </svg>
                    Delete All Replays
                </button>
            </div>
        </div>
    </div>

    <div id="quitConfirmationDialog" style="display:none;">
        <p>Are you sure you want to quit?</p>
        <div id="quitConfirmationButtons">
            <button id="confirmQuitBtn">
                 <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><g><path d="M510.371,226.513c-1.088-2.603-2.645-4.971-4.629-6.955l-63.979-63.979c-8.341-8.32-21.824-8.32-30.165,0 c-8.341,8.341-8.341,21.845,0,30.165l27.584,27.584H320.013c-11.797,0-21.333,9.557-21.333,21.333s9.536,21.333,21.333,21.333 h119.168l-27.584,27.584c-8.341,8.341-8.341,21.845,0,30.165c4.16,4.181,9.621,6.251,15.083,6.251s10.923-2.069,15.083-6.251 l63.979-63.979c1.984-1.963,3.541-4.331,4.629-6.955C512.525,237.606,512.525,231.718,510.371,226.513z"></path> <path d="M362.68,298.667c-11.797,0-21.333,9.557-21.333,21.333v106.667h-85.333V85.333c0-9.408-6.187-17.728-15.211-20.437 l-74.091-22.229h174.635v106.667c0,11.776,9.536,21.333,21.333,21.333s21.333-9.557,21.333-21.333v-128 C384.013,9.557,374.477,0,362.68,0H21.347c-0.768,0-1.451,0.32-2.197,0.405c-1.003,0.107-1.92,0.277-2.88,0.512 c-2.24,0.576-4.267,1.451-6.165,2.645c-0.469,0.299-1.045,0.32-1.493,0.661C8.44,4.352,8.376,4.587,8.205,4.715 C5.88,6.549,3.939,8.789,2.531,11.456c-0.299,0.576-0.363,1.195-0.597,1.792c-0.683,1.621-1.429,3.2-1.685,4.992 c-0.107,0.64,0.085,1.237,0.064,1.856c-0.021,0.427-0.299,0.811-0.299,1.237V448c0,10.176,7.189,18.923,17.152,20.907 l213.333,42.667c1.387,0.299,2.795,0.427,4.181,0.427c4.885,0,9.685-1.685,13.525-4.843c4.928-4.053,7.808-10.091,7.808-16.491 v-21.333H362.68c11.797,0,21.333-9.557,21.333-21.333V320C384.013,308.224,374.477,298.667,362.68,298.667z"></path></g></svg>
                Quit
            </button>
            <button id="cancelQuitBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>
    <div id="deleteReplayConfirmationDialog" style="display:none;">
        <p>Are you sure you want to delete this replay?</p>
        <div id="deleteReplayConfirmationButtons">
            <button id="confirmDeleteReplayBtn">
                 <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                        <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                </svg>
                Delete
            </button>
            <button id="cancelDeleteReplayBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>
    <div id="deleteAllReplaysConfirmationDialog" style="display:none;">
        <p>Are you sure you want to delete ALL replays? This cannot be undone.</p>
        <div id="deleteAllReplaysConfirmationButtons">
            <button id="confirmDeleteAllReplaysBtn">
                <svg class="menu-btn-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                    <g id="SVGRepo_iconCarrier"> <path d="M8 1.5V2.5H3C2.44772 2.5 2 2.94772 2 3.5V4.5C2 5.05228 2.44772 5.5 3 5.5H21C21.5523 5.5 22 5.05228 22 4.5V3.5C22 2.94772 21.5523 2.5 21 2.5H16V1.5C16 0.947715 15.5523 0.5 15 0.5H9C8.44772 0.5 8 0.947715 8 1.5Z" fill="currentColor"></path> <path d="M3.9231 7.5H20.0767L19.1344 20.2216C19.0183 21.7882 17.7135 23 16.1426 23H7.85724C6.28636 23 4.98148 21.7882 4.86544 20.2216L3.9231 7.5Z" fill="currentColor"></path> </g>
                </svg>
                Delete All</button>
            <button id="cancelDeleteAllReplaysBtn">
                <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel</button>
        </div>
    </div>
    
    <div id="exportReplayDialog" style="display:none;">
        <p>Replay Code:</p>
        <textarea id="exportReplayTextArea" readonly></textarea>
        <div id="exportReplayButtons">
                                    <button id="copyExportReplayBtn">
                <svg class="menu-btn-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="0.144" fill="currentColor" style="margin-right: 8px;">
                    
                    <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
                    <g id="SVGRepo_iconCarrier">
                        <path d="M14 8H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V10c0-1.103-.897-2-2-2z"></path>
                        <path d="M20 2H10a2 2 0 0 0-2 2v2h8a2 2 0 0 1 2 2v8h2a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"></path>
                    </g>
                </svg>
                <span class="btn-text-dynamic">Copy</span>
            </button>
            <button id="closeExportReplayBtn">Close</button>
        </div>
    </div>

    <div id="importReplayDialog" style="display:none;">
        <p>Paste Replay Code:</p>
        <textarea id="importReplayTextArea"></textarea>
        <div id="importReplayError"></div>
        <div id="importReplayButtons">
            <button id="importReplayAndPlayBtn">
                <svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px; width:18px; height:18px;">
                    <path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path>
                </svg>
                Import & Play
            </button>
            <button id="cancelImportReplayBtn">
                 <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
                Cancel
            </button>
        </div>
    </div>

    <div id="modeSelectionDialog" style="display:none;">
        <h2>Select Game Mode</h2>
        <div id="modeSelectionButtons">
            <button id="classicModeBtn">
                <svg viewBox="0 0 24.00 24.00" class="menu-btn-icon" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="0.00024"><path d="M2 9.1371C2 14 6.01943 16.5914 8.96173 18.9109C10 19.7294 11 20.5 12 20.5C13 20.5 14 19.7294 15.0383 18.9109C17.9806 16.5914 22 14 22 9.1371C22 4.27416 16.4998 0.825464 12 5.50063C7.50016 0.825464 2 4.27416 2 9.1371Z" fill="#ffffff"></path></svg>
                Classic
            </button>
            <button id="hardcoreModeBtn">
                <svg fill="#ffffff" class="menu-btn-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff"><path d="M256 0C114.6 0 0 100.3 0 224c0 70.1 36.9 132.6 94.5 173.7 9.6 6.9 15.2 18.1 13.5 29.9l-9.4 66.2c-1.4 9.6 6 18.2 15.7 18.2H192v-56c0-4.4 3.6-8 8-8h16c4.4 0 8 3.6 8 8v56h64v-56c0-4.4 3.6-8 8-8h16c4.4 0 8 3.6 8 8v56h77.7c9.7 0 17.1-8.6 15.7-18.2l-9.4-66.2c-1.7-11.7 3.8-23 13.5-29.9C475.1 356.6 512 294.1 512 224 512 100.3 397.4 0 256 0zm-96 320c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64 64zm192 0c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64 64z"></path></svg>
                Hardcore
            </button>
        </div>
        <button id="cancelModeSelectionBtn" style="margin-top: 15px;">
            <svg class="cancel-svg-icon" viewBox="-10.24 -10.24 532.48 532.48" xmlns="http://www.w3.org/2000/svg"><path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M64,256c0-106.1,86-192,192-192 c42.1,0,81,13.7,112.6,36.7L100.7,368.6C77.7,337,64,298.1,64,256z M256,448c-42.1,0-81-13.7-112.6-36.7l267.9-267.9 c23,31.7,36.7,70.5,36.7,112.6C448,362.1,362,448,256,448z"></path></svg>
            Cancel
        </button>
<div id="replayLimitNotification" style="display:none; position:fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #1a1a1a; color: red; padding: 10px 20px; border-radius: 5px; border: 1px solid #555; z-index: 300; font-size: 1.1em; text-align: center;">
        Replay Limit Reached!
    </div>
<script>

let isInitialLoad = true; const _RMRIM = 1000 / 30; 
const REPLAY_SIM_STEP_MS = 16; 
const REPLAY_FORMAT_VERSION = 4; 
let lastClickSoundTime = 0;
const CLICK_SOUND_COOLDOWN_MS = 20;
let lastCollectedPowerupType = null;
let currentQualitySetting = 'high';
const QUALITY_SETTINGS_MAP = {
    low: 0.75,
    medium: 1.0,
    high: window.devicePixelRatio || 1 
};
let qualitySelectElement;
const playIconSVG = `<svg viewBox="0 0 24 24" class="replay-control-svg-icon" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z"/></svg>`;
const pauseIconSVG = `<svg viewBox="170 3605 8 8" class="replay-control-svg-icon" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M172,3605 C171.448,3605 171,3605.448 171,3606 L171,3612 C171,3612.552 171.448,3613 172,3613 C172.552,3613 173,3612.552 173,3612 L173,3606 C173,3605.448 172.552,3605 172,3605 M177,3606 L177,3612 C177,3612.552 176.552,3613 176,3613 C175.448,3613 175,3612.552 175,3612 L175,3606 C175,3605.448 175.448,3605 176,3605 C176.552,3605 177,3605.448 177,3606"/></svg>`;
const R_GM_MAP = { classic: 0, hardcore: 1 };
const R_GM_REV_MAP = ["classic", "hardcore"];
const R_PU_TYPES = { slowFall: 0, wideBucket: 1, oneColor: 2, doublePoints: 3, extraLives: 4, whiteBallMagnet: 5 };
const R_PU_REV_TYPES = ["slowFall", "wideBucket", "oneColor", "doublePoints", "extraLives", "whiteBallMagnet"];
const R_COLOR_CODES = { red: 0, green: 1, blue: 2, white: 3, powerup: 4 };
const R_REV_COLOR_NAMES = ["red", "green", "blue", "white", "powerup"]; 
const R_EV_TYPES = {
    MOUSE: 0, KEYDOWN: 1, KEYUP: 2, SCORE_LIVES: 3,
    POWERUP_ACT: 4, POWERUP_DEACT: 5,
    BALL_SPAWN: 6, BALL_DESPAWN: 7, GAME_END: 8
};
const R_REV_EV_TYPES = [ 
    "mouse", "keydown", "keyup", "scoreLivesUpdate",
    "powerupActivate", "powerupDeactivate",
    "ballSpawn", "ballDespawn", "gameEnd"
];
const R_DESPAWN_REASONS = {
    collectedPowerupWheel: 0, collectedWheelWhite: 1, collectedWheelCorrect: 2, collectedWheelWrong: 3,
    collectedPowerupBucket: 4, collectedBucket: 5,
    missedOffScreen: 6, missedOffScreen_LifeLoss: 7 
};
const R_REV_DESPAWN_REASONS = [
    "collectedPowerupWheel", "collectedWheelWhite", "collectedWheelCorrect", "collectedWheelWrong",
    "collectedPowerupBucket", "collectedBucket",
    "missedOffScreen", "missedOffScreen_LifeLoss"
];
const R_COSMETIC_DEFAULTS = { colorWheel: 0, bucket: 0 }; 

let screenStack = [];
const MAX_HISTORY_LENGTH = 10;
const NAVIGABLE_MENU_SCREENS = ['home', 'settings', 'highScores', 'howToPlay', 'replays', 'appearance'];
let gSeed = 0; let pState = { x: 123456789, y: 362436069, z: 521288629, w: 88675123 };
let cRepData = null; let mRecIntId = null; 
let sReps = []; let rDelId = null; 
let rVState = { activeReplay: null, isPlaying: false, isSeeking: false, currentTimeMs: 0, totalDurationMs: 0, nextEventIndex: 0, lastProcessedMouseTime: -1, prevReplayMouse: { x: 0, y: 0, t: 0 }, nextReplayMouse: { x: 0, y: 0, t: 0 }, keysPressedReplay: {}, score: 0, lives: 0, isReplayDoublePointsActive: false, wasPlayingBeforeSeek: false };
let isResizingDuringReplay = false;
let rAnimId = null; 
let _MST=2*60*1000; let gameCanvas,gameCtx, canvasArea; let aCvs,aCtx;
let gameWidth,gameHeight; let score=0,lives=3,elapsedGameTimeMs=0;
let gameRunning=false,gamePaused=false, gameModeActive = false; 
let animationFrameId,lastTime=0,timePausedStarted=0;
let dropper1,dropper2; const balls=[]; let bucket,playerCursor;
let nextBallId = 0; 
let autosaveReplays = 'no';
let autosaveThreshold = 100;
let autosaveReplaysSelect, autosaveThresholdElements, autosaveThresholdBtn;

const colorWheelParticles=[]; const POWERUP_BALL_GLOW_COLOR='rgba(255, 229, 100, 0.2)'; const powerupGlowParticles=[];
const atmosphericParticles=[]; const _NAP=150; const _APAS=150; const _APMSC=5; const _NTP=400; const textureParticles=[];
const BALL_COLORS=['#FF0000','#00FF00','#0000FF']; const BALL_COLOR_NAMES=['red','green','blue'];
const POWERUP_BALL_COLOR_HEX='#FFD500'; const WHITE_BALL_COLOR_HEX='#E0E0E0';
let BALL_RADIUS_BASE; const _MBFTS=3.0; const _XBFTS=7.0; const _BSAR=0.03;
const DROPPER_COLOR='gray'; let DROPPER_WIDTH_BOTTOM; const DROPPER_HEIGHT=30; const DROPPER_TOP_WIDTH_RATIO=0.5;
let _IDTPS=7; const _FDTP=2; let _IBDIM=1000; let _FBDIM=250;
const BUCKET_COLOR='gray'; const BUCKET_HEIGHT=20; const BUCKET_LINE_WIDTH=4.5;
const _BBWRN=0.18; const _BBWRW=0.42; let cBktWR=_BBWRN; const BUCKET_SIDE_ANGLE=Math.PI/8;
let _BS=5; let _MBTTS=1.0; let _XBTTS=5; let cBktSPS; let _PCOR,_PCRT;
const PLAYER_CURSOR_OUTLINE_COLORS=['#FF0000','#00FF00','#0000FF'];
const _PCSA={red:{start:Math.PI/6,end:5*Math.PI/6},blue:{start:5*Math.PI/6,end:3*Math.PI/2},green:{start:3*Math.PI/2,end:Math.PI/6}};
const keysPressed={}; let keybindLeft='a',keybindRight='d',keybindMaxSpeed='w',keybindPause='p';
let lstnKey=null; const _PUDM=10000; const _PUFTM=2000; const _MINBSM=0.6; const _MAXBSM=1.4*1.1;
const _SFSM=0.45; const _OBSS=1.5; let cBllSS=_OBSS;
const activePowerups={slowFall:{active:false,endTime:0},wideBucket:{active:false,endTime:0},oneColor:{active:false,endTime:0,color:null},doublePoints:{active:false,endTime:0},whiteBallMagnet:{active:false,endTime:0}};
const _MBPP=40; const _MPI=15000; let currentGameMode='classic';
let screens={}; let scoreDisplay,timeDisplay,livesDisplay;
let finalScoreDisplay,finalTimeDisplay,gameOverQuitBtn,saveReplayBtnElem;
let sensitivitySlider,sensitivityValueDisplay; let volumeSlider,volumeValueDisplay;
let keybindLeftBtn,keybindRightBtn,keybindMaxSpeedBtn,keybindPauseBtn;
let newHighScoreTextElem; let powerupIconElems={};
let audioCtx; let masterVolume=0.7;
let quitConfirmationDialog,confirmQuitBtn,cancelQuitBtn,gameScreenHomeBtn;
let deleteReplayConfirmationDialog, confirmDeleteReplayBtn, cancelDeleteReplayBtn;
let deleteAllReplaysConfirmationDialog, confirmDeleteAllReplaysBtn, cancelDeleteAllReplaysBtn;
let exportReplayDialog, exportReplayTextArea, copyExportReplayBtn, closeExportReplayBtn;
let importReplayDialog, importReplayTextArea, importReplayError, importReplayAndPlayBtn, cancelImportReplayBtn;
let lastKnownMouseX = window.innerWidth / 2;
let lastKnownMouseY = window.innerHeight / 2;
let gPausedBefConf=false; let gPausedByConf=false; let modeSelectionDialogElem;
let replayPlayPauseBtn, replaySeekBar, replayTimeDisplayElem, replayControlsContainerElem;
let uiOverlayElem, powerupIconsContainerElem;
let lastSavedReplayId = null; 
let gameOverScreen; 
let pauseOverlay; 


function fnIPRNG(seed) { pState.x = seed | 0; pState.y = (pState.x ^ 0xDEADBEEF) | 0; pState.z = (pState.y ^ 0xFACEFEED) | 0; pState.w = (pState.z ^ 0xC0FFEE) | 0; if (pState.x === 0 && pState.y === 0 && pState.z === 0 && pState.w === 0) { pState.w = 1;}}
function fnSRnd() { let t = pState.x; t ^= t << 11; t ^= t >>> 8; pState.x = pState.y; pState.y = pState.z; pState.z = pState.w; pState.w ^= pState.w >>> 19; pState.w ^= t; return (pState.w >>> 0) / 0x100000000;}

function fnSetReplayButtonIcon(isPlaying) {
    if (replayPlayPauseBtn) {
        replayPlayPauseBtn.innerHTML = isPlaying ? pauseIconSVG : playIconSVG;
    }
}

function handleResize(){
    const oldGameWidth = gameWidth;
    const oldGameHeight = gameHeight;

    const dprMultiplier = QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1);

    const maxContainerWidth = window.innerWidth;
    const maxContainerHeight = window.innerHeight;

    let targetDisplayWidth = maxContainerWidth * 0.9;
    let targetDisplayHeight = maxContainerHeight * 0.8;

    let newCanvasWidthBasedOnHeight = targetDisplayHeight * (16 / 9);
    let newCanvasHeightBasedOnWidth = targetDisplayWidth * (9 / 16);

    let finalDisplayWidth;
    let finalDisplayHeight;

    if (newCanvasHeightBasedOnWidth <= targetDisplayHeight) {
        finalDisplayWidth = targetDisplayWidth;
        finalDisplayHeight = newCanvasHeightBasedOnWidth;
    } else {
        finalDisplayHeight = targetDisplayHeight;
        finalDisplayWidth = newCanvasWidthBasedOnHeight;
    }

    finalDisplayWidth = Math.min(finalDisplayWidth, window.innerWidth * 0.9);
    finalDisplayHeight = Math.min(finalDisplayHeight, window.innerHeight * 0.8);

    const aspectRatio = finalDisplayWidth / finalDisplayHeight;
    const targetAspectRatio = 16 / 9;
    const tolerance = 0.01;

    if (aspectRatio > targetAspectRatio + tolerance) {
        finalDisplayWidth = finalDisplayHeight * targetAspectRatio;
    } else if (aspectRatio < targetAspectRatio - tolerance) {
        finalDisplayHeight = finalDisplayWidth / targetAspectRatio;
    }

    if (canvasArea) {
        canvasArea.style.width = finalDisplayWidth + 'px';
        canvasArea.style.height = finalDisplayHeight + 'px';
    }

    if (gameCanvas && gameCtx) {
        gameCanvas.width = finalDisplayWidth * dprMultiplier;
        gameCanvas.height = finalDisplayHeight * dprMultiplier;
        gameCanvas.style.width = finalDisplayWidth + 'px';
        gameCanvas.style.height = finalDisplayHeight + 'px';
        gameCtx.setTransform(dprMultiplier, 0, 0, dprMultiplier, 0, 0);
    }

    if (aCvs && aCtx) {
        aCvs.width = finalDisplayWidth * dprMultiplier;
        aCvs.height = finalDisplayHeight * dprMultiplier;
        aCvs.style.width = finalDisplayWidth + 'px';
        aCvs.style.height = finalDisplayHeight + 'px';
        aCtx.setTransform(dprMultiplier, 0, 0, dprMultiplier, 0, 0);
    }

    gameWidth = finalDisplayWidth;
    gameHeight = finalDisplayHeight;

    _PCOR = gameWidth * 0.05;
    _PCRT = _PCOR * 0.35;
    BALL_RADIUS_BASE = (_PCOR - _PCRT) / 3.5;
    DROPPER_WIDTH_BOTTOM = BALL_RADIUS_BASE * _MAXBSM * 2;

    const wasActive = gameRunning || (rVState.activeReplay && (rVState.isPlaying || rVState.isSeeking));
    const wasReplayActive = rVState.activeReplay !== null;
    const wasReplayPlaying = rVState.isPlaying;
    const wasReplaySeeking = rVState.isSeeking;
    const currentReplayTimeBeforeStateReset = rVState.currentTimeMs;


    if (wasActive && !wasReplayActive) {
        const timeProgress = elapsedGameTimeMs / _MST;
        const currentDropperTimePerScreenS = _IDTPS - (_IDTPS - _FDTP) * Math.min(1, timeProgress);
        if (bucket) {
            bucket.baseWidth = gameWidth * cBktWR;
            if (oldGameWidth && oldGameWidth > 0) bucket.x = (bucket.x / oldGameWidth) * gameWidth;
            bucket.y = gameHeight - BUCKET_HEIGHT - (BUCKET_LINE_WIDTH / 2);
        }
        if (dropper1) {
            if (oldGameWidth && oldGameWidth > 0) dropper1.x = (dropper1.x / oldGameWidth) * gameWidth;
            dropper1.width = DROPPER_WIDTH_BOTTOM;
            dropper1.topWidth = DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO;
            dropper1.speed = (gameWidth - DROPPER_WIDTH_BOTTOM) / currentDropperTimePerScreenS;
        }
        if (dropper2) {
            if (oldGameWidth && oldGameWidth > 0) dropper2.x = (dropper2.x / oldGameWidth) * gameWidth;
            dropper2.width = DROPPER_WIDTH_BOTTOM;
            dropper2.topWidth = DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO;
            dropper2.speed = (gameWidth - DROPPER_WIDTH_BOTTOM) / currentDropperTimePerScreenS;
        }
        balls.forEach(ball => {
            if (oldGameWidth && oldGameWidth > 0 && oldGameHeight && oldGameHeight > 0) {
                ball.x = (ball.x / oldGameWidth) * gameWidth;
                ball.y = (ball.y / oldGameHeight) * gameHeight;
            }
            const oldBallRadiusBaseVal = (oldGameWidth && oldGameWidth > 0) ? ((oldGameWidth * 0.05) - (oldGameWidth * 0.05 * 0.35)) / 3.5 : BALL_RADIUS_BASE;
            const sizeMultiplier = ball.radius / (oldBallRadiusBaseVal > 0 ? oldBallRadiusBaseVal : BALL_RADIUS_BASE);
            ball.radius = BALL_RADIUS_BASE * sizeMultiplier;
            if (ball.originalVy && ball.vy) {
                const isSlowFallCurrentlyActive = activePowerups.slowFall.active && (currentGameMode === 'classic' && !rVState.activeReplay);
                const currentEffectiveOldHeight = (oldGameHeight && oldGameHeight > 0) ? oldGameHeight : gameHeight;
                const fallDuration = currentEffectiveOldHeight / (ball.originalVy / (isSlowFallCurrentlyActive ? _SFSM : 1));
                if (fallDuration > 0) {
                    ball.originalVy = gameHeight / fallDuration;
                    ball.vy = isSlowFallCurrentlyActive ? ball.originalVy * _SFSM : ball.originalVy;
                } else {
                    ball.originalVy = gameHeight / _MBFTS;
                    ball.vy = ball.originalVy;
                }
            }
        });
        if (playerCursor) {
            if (oldGameWidth && oldGameWidth > 0 && oldGameHeight && oldGameHeight > 0) {
                playerCursor.x = (playerCursor.x / oldGameWidth) * gameWidth;
                playerCursor.y = (playerCursor.y / oldGameHeight) * gameHeight;
            }
        }
    }

    fnITP();
    fnIAP();

    if (aCtx) aCtx.clearRect(0, 0, gameWidth, gameHeight);
    fnDTP(aCtx);

    if (wasReplayActive) {
        isResizingDuringReplay = true; // <<< SET FLAG
        fnAREUTT(currentReplayTimeBeforeStateReset, true);
        isResizingDuringReplay = false; // <<< UNSET FLAG

        if(replaySeekBar && rVState.totalDurationMs > 0) {
            replaySeekBar.value = (rVState.currentTimeMs / rVState.totalDurationMs) * 100;
        }
        fnURUI();

        if (!wasReplayPlaying || wasReplaySeeking) {
            redrawStaticFrame();
        }
        if (wasReplayPlaying && !wasReplaySeeking) {
            lastTime = performance.now();
        }

    } else if (wasActive && gamePaused) {
        redrawStaticFrame();
    } else if (!wasActive && (gameCtx || aCtx)) {
        if (gameCtx) gameCtx.clearRect(0, 0, gameWidth, gameHeight);
        if (aCtx) {
            aCtx.clearRect(0, 0, gameWidth, gameHeight);
            fnDTP(aCtx);
        }
    }
}

function fnShowReplayLimitNotification(message) {
    const notificationElement = document.getElementById('replayLimitNotification');
    if (notificationElement) {
        notificationElement.textContent = message;
        notificationElement.style.display = 'block';
        fnPS('loseLife'); 
        setTimeout(() => {
            notificationElement.style.display = 'none';
        }, 3000); 
    }
}

function updateButtonText(buttonElement, newText) {
    const textSpan = buttonElement.querySelector('.btn-text');
    if (textSpan) {
        textSpan.textContent = newText;
    } else {
        
        
        let firstChild = buttonElement.firstChild;
        let textNode = null;
        if (firstChild && firstChild.nodeName.toLowerCase() === 'svg') {
            textNode = firstChild.nextSibling;
        } else {
            textNode = firstChild;
        }

        if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            textNode.nodeValue = " " + newText; 
        } else {
            
            const newTextNode = document.createTextNode(" " + newText);
            if (firstChild && firstChild.nodeName.toLowerCase() === 'svg') {
                buttonElement.insertBefore(newTextNode, firstChild.nextSibling);
            } else {
                buttonElement.appendChild(newTextNode);
            }
        }
    }
}

function redrawStaticFrame() {
    if (!gameCtx) return; // Guard clause in case context isn't ready

    gameCtx.clearRect(0,0,gameWidth,gameHeight);
    fnDAP(gameCtx); // Atmospheric background

    // Draw Bucket first
    if (bucket) fnDBkt(gameCtx,bucket);

    // Draw Player Cursor and its particles
    fnDCWP(gameCtx); // Color wheel particles
    if (playerCursor) fnDPC(gameCtx); // Player cursor itself

    // Draw Balls NEXT
    fnDB(gameCtx);

    // Draw Droppers AFTER Balls
    if (dropper1) fnDSD(gameCtx,dropper1);
    if (dropper2) fnDSD(gameCtx,dropper2);

    const currentDisplayMode = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    if(currentDisplayMode === 'classic'){fnDPGP(gameCtx);} // Power-up glow particles

    fnUUI(); // Update score/time/lives display
}
function fnHVC() {
    if (document.hidden) {
        if (gameModeActive && gameRunning && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) {
            fnPG();
        }
        if (rVState.activeReplay && rVState.isPlaying) {
            rVState.isPlaying = false;
            fnSetReplayButtonIcon(false);
            if (rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = null;
        }
    }
}
function fnHFC(event) {
    if (event.type === 'blur') {
        if (gameModeActive && gameRunning && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) {
            fnPG();
        }
        if (rVState.activeReplay && rVState.isPlaying) {
            rVState.isPlaying = false;
            fnSetReplayButtonIcon(false);
            if (rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = null;
        }
    }
}
function fnTP(){ if(!gameModeActive || !gameRunning)return; if(quitConfirmationDialog&&quitConfirmationDialog.style.display!=='none')return; if(gamePaused){fnRG();}else{fnPG();}}
function fnPG(){ if(!gameModeActive || !gameRunning||gamePaused)return; gamePaused=true;gPausedByConf=false; timePausedStarted=performance.now(); if(animationFrameId)cancelAnimationFrame(animationFrameId); if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null; if(pauseOverlay)pauseOverlay.style.display='flex'; if(gameCanvas)gameCanvas.style.cursor='default'; fnPS('click');}
function fnRG(){ if(!gameModeActive || !gameRunning||!gamePaused)return; if(quitConfirmationDialog&&quitConfirmationDialog.style.display!=='none'){return;} gamePaused=false;gPausedByConf=false; const tWP=performance.now()-timePausedStarted; lastTime+=tWP; if(pauseOverlay)pauseOverlay.style.display='none'; animationFrameId=requestAnimationFrame(fnGL); if(!mRecIntId && gameRunning && !rVState.activeReplay) mRecIntId = setInterval(fnRMP, _RMRIM); if(gameCanvas)gameCanvas.style.cursor='none'; fnPS('click');}
function fnSQC(){ 
    if (rVState.activeReplay) { 
        fnStopRP();
        fnSS('home');
        fnPS('click');
        return;
    }
    if(quitConfirmationDialog){ 
        if(gameModeActive && gameRunning){ 
            if(!gamePaused){ 
                gPausedBefConf=false; gPausedByConf=true; gamePaused=true; 
                timePausedStarted=performance.now(); 
                if(animationFrameId)cancelAnimationFrame(animationFrameId); 
                if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null; 
                if(gameCanvas)gameCanvas.style.cursor='default'; 
            } else {
                gPausedBefConf=true; gPausedByConf=false;
            } 
        } 
        quitConfirmationDialog.style.display='flex';
        fnPS('click');
    }
}
function fnHQC(){ if(quitConfirmationDialog){ quitConfirmationDialog.style.display='none'; if(gameModeActive && gameRunning && gPausedByConf){ gamePaused=false; const tWP=performance.now()-timePausedStarted; lastTime+=tWP; animationFrameId=requestAnimationFrame(fnGL); if(!mRecIntId && !rVState.activeReplay) mRecIntId = setInterval(fnRMP, _RMRIM); if(gameCanvas)gameCanvas.style.cursor='none'; } gPausedByConf=false;fnPS('click');}}
function initAudio(){if(!audioCtx){try{audioCtx=new (window.AudioContext||window.webkitAudioContext)();}catch(e){console.error("Web Audio API not supported",e);return false;}}return true;}





function fnPSI(soundType){
    if(!audioCtx||audioCtx.state!=='running'){return;}
    if(masterVolume===0)return;

    if (rVState.isSeeking && soundType !== 'click') {
        return;
    }

    let canPlaySound = (rVState.activeReplay && (rVState.isPlaying || rVState.isSeeking)) ||
                         (gameModeActive && (!gamePaused || gPausedByConf));

    if (rVState.activeReplay && !rVState.isPlaying && !rVState.isSeeking &&
        rVState.currentTimeMs >= rVState.totalDurationMs && soundType === 'loseLife') {
        canPlaySound = true;
    }

    if(!canPlaySound && soundType !== 'click' && soundType !=='powerupCollect' && soundType !== 'collectGoodDouble' && soundType !== 'loseLife') return;
    if(!canPlaySound && soundType === 'loseLife' && !(rVState.activeReplay && rVState.currentTimeMs >= rVState.totalDurationMs)) return;
    
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    
    
    
    o.connect(g);g.connect(audioCtx.destination);
    const n=audioCtx.currentTime;let d=0.1,b=0.1;
    switch(soundType){
        
         case 'click':o.type='triangle';o.frequency.setValueAtTime(1000,n);b=0.1;d=0.1;break; case 'drop':o.type='sine';o.frequency.setValueAtTime(200,n);b=0.15;d=0.2;break; case 'collectGood':o.type='sine';o.frequency.setValueAtTime(660,n);b=0.2;d=0.15;break; case 'collectGoodDouble':o.type='sine';o.frequency.setValueAtTime(880,n);o.frequency.exponentialRampToValueAtTime(990,n+0.05);b=0.22;d=0.18;break; case 'collectBucket':
    o.type = 'square';
    o.frequency.setValueAtTime(150, n);
    b = 0.14;
    d = 0.11;
    break; case 'loseLife':o.type='sawtooth';o.frequency.setValueAtTime(150,n);o.frequency.exponentialRampToValueAtTime(80,n+0.3);b=0.25;d=0.3;break; case 'powerupCollect':o.type='triangle';o.frequency.setValueAtTime(880,n);o.frequency.exponentialRampToValueAtTime(1320,n+0.1);b=0.25;d=0.3;break; default:o.disconnect();g.disconnect();return;} const a=b*masterVolume;g.gain.setValueAtTime(a,n); g.gain.exponentialRampToValueAtTime(0.0001,n+d);o.start(n);o.stop(n+d);
}
function fnPS(type){
    if (isResizingDuringReplay && type !== 'click') { // Allow UI clicks, but mute game sounds
        return;
    }

    if(!initAudio()){return;}

    if (type === 'click') {
        const now = performance.now();
        if (now - lastClickSoundTime < CLICK_SOUND_COOLDOWN_MS) {
            return;
        }
        lastClickSoundTime = now;
    }

    if(audioCtx.state==='suspended'){
        audioCtx.resume().then(()=>{fnPSI(type);});
    } else if(audioCtx.state==='running'){
        fnPSI(type);
    }
}
function fnSS(screenName){
    const dialogs = [pauseOverlay, quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem];
    dialogs.forEach(d => { if(d) d.style.display = 'none';});

    let isNavigatingAwayFromGameOrReplay = (screenName !== 'game' && screenName !== 'gameOver' && screenName !== 'replayViewer');

    if (rVState.activeReplay && isNavigatingAwayFromGameOrReplay) {
         if (screens.game.classList.contains('active')) {
            fnStopRP();
         }
    }
    gameModeActive = (screenName === 'game' && !rVState.activeReplay && screenName !== 'replayViewer');

    if (NAVIGABLE_MENU_SCREENS.includes(screenName)) {
        if (screenName === 'home') {
            screenStack = ['home'];
        } else {
            if (screenStack.length === 0 || screenStack[screenStack.length - 1] !== screenName) {
                screenStack.push(screenName);
                if (screenStack.length > MAX_HISTORY_LENGTH) {
                    screenStack.shift();
                }
            }
        }
    }

    Object.values(screens).forEach(s=>{if(s?.classList.contains('screen'))s.classList.remove('active');});

    let isReplayViewing = (screenName === 'replayViewer');
    if(screenName==='gameOver'){
        screens.game.classList.add('active');
        replayControlsContainerElem.style.display = 'none';
        uiOverlayElem.classList.remove('replay-mode');
        powerupIconsContainerElem.classList.remove('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display='flex';
    } else if (isReplayViewing) {
        screens.game.classList.add('active');
        replayControlsContainerElem.style.display = 'flex';
        uiOverlayElem.classList.add('replay-mode');
        powerupIconsContainerElem.classList.add('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display = 'none';
    } else if(screens[screenName]){
        screens[screenName].classList.add('active');
        replayControlsContainerElem.style.display = 'none';
        uiOverlayElem.classList.remove('replay-mode');
        powerupIconsContainerElem.classList.remove('replay-mode');
        if(gameOverScreen) gameOverScreen.style.display = 'none';
    }

    let cursorStyle = 'default';
    if (screenName === 'game' && gameModeActive && !gamePaused && (!quitConfirmationDialog || quitConfirmationDialog.style.display === 'none')) { cursorStyle = 'none'; }
    else if (isReplayViewing) { cursorStyle = 'default'; }
    if(gameCanvas) gameCanvas.style.cursor = cursorStyle;
}

function fnSMSD(){fnPS('click');if(modeSelectionDialogElem){if(!screens.home.classList.contains('active')){fnSS('home');} modeSelectionDialogElem.style.display='flex';}}
function fnHMSD(){fnPS('click');if(modeSelectionDialogElem){modeSelectionDialogElem.style.display='none';}}
function fnSGM(mode, event){ 
    currentGameMode=mode;
    fnHMSD();
    fnSG(event); // Pass the event to fnSG
}

function fnSEL(){
    if(!document.getElementById('startGameBtn')){console.error("DOM not ready");return;}
    qualitySelectElement = document.getElementById('qualitySelect');

    document.getElementById('startGameBtn').addEventListener('click',fnSMSD);
    document.getElementById('settingsBtn').addEventListener('click',()=>{ fnPS('click'); fnSS('settings'); });
    document.getElementById('highScoresBtn').addEventListener('click',()=>{ fnPS('click'); fnDHS(); fnSS('highScores'); });
    document.getElementById('howToPlayBtn').addEventListener('click',()=>{ fnPS('click'); fnSS('howToPlay'); });
    document.getElementById('replaysBtn').addEventListener('click', () => { fnPS('click'); fnDRpsL(); fnSS('replays'); });
    document.getElementById('appearanceBtn').addEventListener('click', () => { fnPS('click'); fnSS('appearance'); });

    document.getElementById('classicModeBtn').addEventListener('click',(e)=>{ fnPS('click'); fnSGM('classic', e); });
    document.getElementById('hardcoreModeBtn').addEventListener('click',(e)=>{ fnPS('click'); fnSGM('hardcore', e); });
    document.getElementById('cancelModeSelectionBtn').addEventListener('click',fnHMSD);

    volumeSlider.addEventListener('input',(e)=>{masterVolume=parseInt(e.target.value)/100;volumeValueDisplay.textContent=e.target.value;});
    volumeSlider.addEventListener('mouseup',()=>{fnSVS();fnPS('click');});
    sensitivitySlider.addEventListener('input',(e)=>{_BS=parseInt(e.target.value);sensitivityValueDisplay.textContent=_BS;fnUBS();});
    sensitivitySlider.addEventListener('mouseup',()=>{fnSVS();fnPS('click');});

    if (qualitySelectElement) {
        qualitySelectElement.addEventListener('mousedown', () => {
            fnPS('click');
        });
        qualitySelectElement.addEventListener('change', (e) => {
            currentQualitySetting = e.target.value;
            fnSVS();
            fnPS('click'); 
            handleResize();
            if (gamePaused || (rVState.activeReplay && !rVState.isPlaying)) {
                redrawStaticFrame();
            }
        });
    }

    if (autosaveReplaysSelect) {
        const autosaveThresholdElements = document.getElementById('autosaveThresholdElements'); // Get reference
        autosaveReplaysSelect.addEventListener('mousedown', () => fnPS('click'));
        autosaveReplaysSelect.addEventListener('change', (e) => {
            autosaveReplays = e.target.value;
            if (autosaveThresholdElements) { // Check if element exists
        autosaveThresholdElements.style.display = (autosaveReplays === 'yes') ? 'flex' : 'none';
            }
            fnSVS();
            fnPS('click');
        });
    }

if (autosaveThresholdBtn) {
    autosaveThresholdBtn.addEventListener('click', () => {
        fnPS('click');
        if (autosaveThresholdBtn.dataset.editing === "true") {
            return; // Already in edit mode
        }

        autosaveThresholdBtn.dataset.editing = "true";
        const currentValue = autosaveThresholdBtn.textContent;
        autosaveThresholdBtn.style.display = 'none'; // Hide the button

        const editableArea = document.createElement('div');
        editableArea.classList.add('threshold-editable-area');
        editableArea.contentEditable = "true";
        editableArea.textContent = currentValue;

        // Insert the editable area where the button was
        autosaveThresholdBtn.parentNode.insertBefore(editableArea, autosaveThresholdBtn);
        editableArea.focus();

        // Select text
        const range = document.createRange();
        range.selectNodeContents(editableArea);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        function saveAndExitEditingThreshold() {
            if (autosaveThresholdBtn.dataset.editing !== "true") return;

            const newValueStr = editableArea.textContent.trim();
            let newValueInt = parseInt(newValueStr);

            if (!isNaN(newValueInt) && newValueInt >= 0 && newValueInt <= 99999) {
                autosaveThreshold = newValueInt;
                autosaveThresholdBtn.textContent = autosaveThreshold;
                fnSVS(); // Save all settings
            } else {
                autosaveThresholdBtn.textContent = autosaveThreshold; // Revert to last valid
            }

            editableArea.parentNode.removeChild(editableArea);
            autosaveThresholdBtn.style.display = 'inline-flex'; // Show button again
            autosaveThresholdBtn.dataset.editing = "false";
        }

        editableArea.addEventListener('blur', () => {
            setTimeout(saveAndExitEditingThreshold, 50);
        });

        editableArea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveAndExitEditingThreshold();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                autosaveThresholdBtn.textContent = autosaveThreshold; // Revert to last valid before current edit
                saveAndExitEditingThreshold();
            } else if (!/^[0-9]$/.test(e.key) && e.key.length === 1 &&
                       !['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'].includes(e.key) &&
                       !(e.ctrlKey || e.metaKey)) {
                e.preventDefault(); // Only allow numbers
            }
        });
    });
}


    keybindLeftBtn.addEventListener('click',()=>fnSLFK('left'));
    keybindRightBtn.addEventListener('click',()=>fnSLFK('right'));
    keybindMaxSpeedBtn.addEventListener('click',()=>fnSLFK('maxSpeed'));
    keybindPauseBtn.addEventListener('click',()=>fnSLFK('pause'));

    document.getElementById('settingsToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
    document.getElementById('highScoresToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
    document.getElementById('howToPlayToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
    document.getElementById('appearanceToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
    document.getElementById('replaysToHomeBtnIcon').addEventListener('click',()=>{ fnPS('click'); fnSS('home'); });
    document.getElementById('importReplaysBtn').addEventListener('click', fnShowImportDialog);


    document.getElementById('playAgainBtn').addEventListener('click',()=>{ 
        fnPS('click'); 
        // Reset button before starting new game
        if (saveReplayBtnElem) {
            updateButtonText(saveReplayBtnElem, "Save Replay");
            saveReplayBtnElem.classList.remove('saved');
        }
        fnSG();
    });

    if(gameOverQuitBtn)gameOverQuitBtn.addEventListener('click',()=>{ 
        fnPS('click'); 
        // Reset button before going to home
        if (saveReplayBtnElem) {
            updateButtonText(saveReplayBtnElem, "Save Replay");
            saveReplayBtnElem.classList.remove('saved');
        }
        fnSS('home'); 
    });
    if(saveReplayBtnElem) saveReplayBtnElem.addEventListener('click', ()=>{
        if (saveReplayBtnElem.classList.contains('saved')) return;
        fnPS('click');
        fnSCR();
    });
    if(gameScreenHomeBtn){gameScreenHomeBtn.addEventListener('click',()=>{
        if(rVState.activeReplay) { fnPS('click'); fnSQC(); }
        else if(gameModeActive && gameRunning){ fnPS('click'); fnSQC(); }
        else{ fnPS('click'); fnSS('home');}
    });}
    if(confirmQuitBtn)confirmQuitBtn.addEventListener('click',()=>{
        fnPS('click');
        if(gameModeActive && gameRunning){gameRunning=false;gamePaused=false;if(animationFrameId)cancelAnimationFrame(animationFrameId); if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;}
        else if (rVState.activeReplay) { fnStopRP(); }
        fnSS('home');gPausedByConf=false;
    });
    if(cancelQuitBtn)cancelQuitBtn.addEventListener('click',fnHQC);

    confirmDeleteReplayBtn.addEventListener('click', ()=>{fnPS('click'); fnCDR();});
    cancelDeleteReplayBtn.addEventListener('click', fnHDRC);

    document.getElementById('deleteAllReplaysBtn').addEventListener('click', ()=>{fnPS('click'); fnShowDeleteAllConf();});
    confirmDeleteAllReplaysBtn.addEventListener('click', ()=>{fnPS('click'); fnCDAR();});
    cancelDeleteAllReplaysBtn.addEventListener('click', fnHDARC);

    copyExportReplayBtn.addEventListener('click', fnCopyExportedReplay);
    closeExportReplayBtn.addEventListener('click', () => { fnPS('click'); exportReplayDialog.style.display = 'none'; });
    importReplayAndPlayBtn.addEventListener('click', fnImportAndPlayReplay);
    cancelImportReplayBtn.addEventListener('click', () => { fnPS('click'); importReplayDialog.style.display = 'none';});


    replayPlayPauseBtn.addEventListener('click', () => {
        if (!rVState.activeReplay) return;
        fnPS('click');
        if (!rVState.isPlaying && rVState.currentTimeMs >= rVState.totalDurationMs && rVState.totalDurationMs > 0) {
            rVState.currentTimeMs = 0;
            fnAREUTT(0, true);
            rVState.isPlaying = true;
            fnSetReplayButtonIcon(true);
            lastTime = performance.now();
            if(rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = requestAnimationFrame(fnRGL);
        } else {
            rVState.isPlaying = !rVState.isPlaying;
            fnSetReplayButtonIcon(rVState.isPlaying);
            if (rVState.isPlaying) {
                if(!rAnimId) lastTime = performance.now();
                if (rVState.isSeeking) {
                    const seekTimeMs = (parseFloat(replaySeekBar.value) / 100) * rVState.totalDurationMs;
                    rVState.currentTimeMs = seekTimeMs;
                }
                rVState.isSeeking = false;
                if(rAnimId) cancelAnimationFrame(rAnimId);
                rAnimId = requestAnimationFrame(fnRGL);
            } else {
                if(rAnimId) cancelAnimationFrame(rAnimId);
                rAnimId = null;
            }
        }
    });

    replaySeekBar.addEventListener('input', () => {
        if (!rVState.activeReplay) return;

        if (!rVState.isSeeking) {
            rVState.wasPlayingBeforeSeek = rVState.isPlaying;
        }
        rVState.isSeeking = true;

        if (rVState.isPlaying) {
            rVState.isPlaying = false;
            fnSetReplayButtonIcon(false);
            if(rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = null;
        }

        const seekTimeMs = (parseFloat(replaySeekBar.value) / 100) * rVState.totalDurationMs;
        rVState.currentTimeMs = seekTimeMs;
        fnAREUTT(seekTimeMs, true);
        redrawStaticFrame();
        fnURUI();
    });
            replaySeekBar.addEventListener('change', () => {
        if (!rVState.activeReplay) return;

        if (!rVState.isSeeking) return;

        fnPS('click');
        rVState.isSeeking = false;

        if (rVState.wasPlayingBeforeSeek) {
            rVState.isPlaying = true;
            fnSetReplayButtonIcon(true);
            lastTime = performance.now();
            if(rAnimId) cancelAnimationFrame(rAnimId);
            rAnimId = requestAnimationFrame(fnRGL);
        } else {
            redrawStaticFrame();
            fnURUI();
        }
    });

    if(pauseOverlay)pauseOverlay.addEventListener('click',fnRG);
    window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); if (lstnKey) { fnSK(key); return; } const isReplayActive = rVState.activeReplay !== null && screens.game.classList.contains('active') && replayControlsContainerElem.style.display === 'flex'; const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) { if (key === 'escape') { fnPS('click'); if(quitConfirmationDialog?.style.display !== 'none') fnHQC(); else if(deleteReplayConfirmationDialog?.style.display !== 'none') fnHDRC(); else if(deleteAllReplaysConfirmationDialog?.style.display !== 'none') fnHDARC(); else if(exportReplayDialog?.style.display !== 'none') exportReplayDialog.style.display = 'none'; else if(importReplayDialog?.style.display !== 'none') importReplayDialog.style.display = 'none'; else if(modeSelectionDialogElem?.style.display !== 'none') fnHMSD(); } return; } if (key === 'escape') { fnPS('click'); let currentActiveScreen = ''; for (const sn_iterator in screens) { if (screens[sn_iterator]?.classList.contains('active')) { currentActiveScreen = sn_iterator; break;}} if (isReplayActive) { fnStopRP(); const lastNavigableScreen = screenStack.length > 0 ? screenStack[screenStack.length - 1] : 'home'; fnSS(lastNavigableScreen); } else if (gameModeActive && gameRunning) { fnSQC(); } else if (currentActiveScreen === 'home') { return; } else { if (screenStack.length > 1) { screenStack.pop(); const targetScreen = screenStack[screenStack.length - 1]; fnSS(targetScreen); } else { fnSS('home'); }} return; } if (gameModeActive && gameRunning) { if (key === keybindPause) { fnTP(); } else if (!gamePaused) { if (!keysPressed[key] && cRepData) { cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'keydown', key: key });} keysPressed[key] = true; }} else if (isReplayActive) { if (key === ' ') { e.preventDefault(); replayPlayPauseBtn.click(); } } });
    window.addEventListener('keyup',(e)=>{ const key=e.key.toLowerCase(); if(lstnKey)return; const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return; if(gameModeActive && gameRunning && !gamePaused){ if(keysPressed[key] && cRepData){ cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'keyup', key: key });} keysPressed[key]=false; } });
    document.addEventListener('mousemove',(e)=>{
        if(gameModeActive && gameRunning && !gamePaused && playerCursor){
            const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return;
            const rect=gameCanvas.getBoundingClientRect();
            playerCursor.x=e.clientX-rect.left;
            playerCursor.y=e.clientY-rect.top;
        }
    });
}

function fnRMP() { 
    if (gameModeActive && gameRunning && !gamePaused && playerCursor && cRepData) { 
        cRepData.events.push({ 
            t: parseFloat(elapsedGameTimeMs.toFixed(1)), 
            type: 'mouse', 
            x: parseFloat(playerCursor.x.toFixed(1)), 
            y: parseFloat(playerCursor.y.toFixed(1)) 
        }); 
    } 
}

function fnLS() {
    const sv = localStorage.getItem('masterVolume');
    if (sv !== null) masterVolume = parseFloat(sv);
    if (volumeSlider) volumeSlider.value = masterVolume * 100;
    if (volumeValueDisplay) volumeValueDisplay.textContent = Math.round(masterVolume * 100);

    const ss = localStorage.getItem('bucketSensitivity');
    if (ss) _BS = parseInt(ss);
    if (sensitivitySlider) sensitivitySlider.value = _BS;
    if (sensitivityValueDisplay) sensitivityValueDisplay.textContent = _BS;

    const skl_val = localStorage.getItem('keybindLeft');
    if (skl_val) keybindLeft = skl_val;
    else keybindLeft = 'a'; 
    if (typeof keybindLeft !== 'string') keybindLeft = 'a'; 
    if (keybindLeftBtn) keybindLeftBtn.textContent = keybindLeft.toUpperCase();

    const skr_val = localStorage.getItem('keybindRight');
    if (skr_val) keybindRight = skr_val;
    else keybindRight = 'd';
    if (typeof keybindRight !== 'string') keybindRight = 'd';
    if (keybindRightBtn) keybindRightBtn.textContent = keybindRight.toUpperCase();

    const skms_val = localStorage.getItem('keybindMaxSpeed');
    if (skms_val) keybindMaxSpeed = skms_val;
    else keybindMaxSpeed = 'w';
    if (typeof keybindMaxSpeed !== 'string') keybindMaxSpeed = 'w';
    if (keybindMaxSpeedBtn) keybindMaxSpeedBtn.textContent = keybindMaxSpeed.toUpperCase();

    const skp_val = localStorage.getItem('keybindPause');
    if (skp_val) keybindPause = skp_val;
    else keybindPause = 'p';
    if (typeof keybindPause !== 'string') keybindPause = 'p';
    if (keybindPauseBtn) keybindPauseBtn.textContent = keybindPause.toUpperCase();

    const savedQuality = localStorage.getItem('graphicsQuality');
    if (savedQuality && QUALITY_SETTINGS_MAP[savedQuality]) {
        currentQualitySetting = savedQuality;
    } else {
        currentQualitySetting = 'high'; 
    }
    if (qualitySelectElement) {
        qualitySelectElement.value = currentQualitySetting;
    }

    const ar_val = localStorage.getItem('autosaveReplays');
    if (ar_val === 'yes' || ar_val === 'no') autosaveReplays = ar_val;
    else autosaveReplays = 'no';
    if (autosaveReplaysSelect) autosaveReplaysSelect.value = autosaveReplays;

    const at_val = localStorage.getItem('autosaveThreshold');
    if (at_val !== null && !isNaN(parseInt(at_val))) autosaveThreshold = parseInt(at_val);
    else autosaveThreshold = 100;
    if (autosaveThresholdBtn) autosaveThresholdBtn.textContent = autosaveThreshold;

    const autosaveThresholdElements = document.getElementById('autosaveThresholdElements'); // Get reference if not already global
    if (autosaveThresholdElements) {
                autosaveThresholdElements.style.display = (autosaveReplays === 'yes') ? 'flex' : 'none';
    }
}

function fnSVS(){
    localStorage.setItem('masterVolume',masterVolume);
    localStorage.setItem('graphicsQuality', currentQualitySetting);
    localStorage.setItem('bucketSensitivity',_BS);
    localStorage.setItem('keybindLeft',keybindLeft);
    localStorage.setItem('keybindRight',keybindRight);
    localStorage.setItem('keybindMaxSpeed',keybindMaxSpeed);
    localStorage.setItem('keybindPause',keybindPause);
    localStorage.setItem('autosaveReplays', autosaveReplays);
    localStorage.setItem('autosaveThreshold', autosaveThreshold);
}
function fnSLFK(type) {
    fnPS('click');
    lstnKey = type;
    let btnToChange;
    if (type === 'left') btnToChange = keybindLeftBtn;
    else if (type === 'right') btnToChange = keybindRightBtn;
    else if (type === 'maxSpeed') btnToChange = keybindMaxSpeedBtn;
    else if (type === 'pause') btnToChange = keybindPauseBtn;

    if (btnToChange) btnToChange.textContent = 'Press key...';

    // Array of all elements to disable/enable
    const elementsToToggle = [
        keybindLeftBtn, keybindRightBtn, keybindMaxSpeedBtn, keybindPauseBtn,
        volumeSlider, sensitivitySlider,
        qualitySelectElement, // Graphics Quality select
        autosaveReplaysSelect, // Autosave Replays select
        autosaveThresholdBtn   // Above score button
    ];

    elementsToToggle.forEach(el => {
        if (el && el !== btnToChange) {
            el.disabled = true;
            if (el.style) {
                el.style.cursor = 'not-allowed';
                if (el === qualitySelectElement || el === autosaveReplaysSelect) {
                    el.style.backgroundColor = '#555';
                    el.style.opacity = '1';
                } else if (el.tagName === 'BUTTON' && el.classList.contains('keybindBtn')) {
                    el.style.opacity = '1'; // Rely on CSS :disabled for background
                } else if (el.tagName === 'INPUT' && el.type === 'range') {
                    el.style.opacity = '0.6';
                }
            }
        }
    });
}
function fnSK(key) {
    if (!lstnKey) return;

    if (key.toLowerCase() === 'escape') {
        fnPS('click'); // Play sound for escape/cancel
    } else {
        if (lstnKey === 'left') keybindLeft = key.toLowerCase();
        else if (lstnKey === 'right') keybindRight = key.toLowerCase();
        else if (lstnKey === 'maxSpeed') keybindMaxSpeed = key.toLowerCase();
        else if (lstnKey === 'pause') keybindPause = key.toLowerCase();
        fnSVS(); // Save all settings (including new keybind)
        fnPS('click'); // Play sound for successful keybind set
    }

    // Update button text content
    if (keybindLeftBtn) keybindLeftBtn.textContent = keybindLeft.toUpperCase();
    if (keybindRightBtn) keybindRightBtn.textContent = keybindRight.toUpperCase();
    if (keybindMaxSpeedBtn) keybindMaxSpeedBtn.textContent = keybindMaxSpeed.toUpperCase();
    if (keybindPauseBtn) keybindPauseBtn.textContent = keybindPause.toUpperCase();

    lstnKey = null; // Reset listening state

    // Array of all elements to re-enable
    const elementsToToggle = [
        keybindLeftBtn, keybindRightBtn, keybindMaxSpeedBtn, keybindPauseBtn,
        volumeSlider, sensitivitySlider,
        qualitySelectElement,    // Graphics Quality select
        autosaveReplaysSelect,   // Autosave Replays select
        autosaveThresholdBtn     // Above score button
    ];

    elementsToToggle.forEach(el => {
        if (el) {
            el.disabled = false;
            if (el.style) {
                el.style.cursor = 'pointer';
                el.style.removeProperty('opacity'); // Remove opacity override
                if (el === qualitySelectElement || el === autosaveReplaysSelect) {
                    el.style.removeProperty('background-color'); // Restore original background
                }
            }
        }
    });
}

function fnGHS(){const s=localStorage.getItem('highScores');return s?JSON.parse(s):[];}
function fnSHS(newScore, timeStr, gameEndTimeMs) {
    let allScoresStored = fnGHS();
    const newEntry = {
        score: newScore,
        time: timeStr,
        timestamp: gameEndTimeMs, 
        date: new Date(gameEndTimeMs).toLocaleDateString(), 
        mode: currentGameMode,
        replayId: null, // Initially, no replay is linked by fnSHS
        note: ""
    };

    allScoresStored.push(newEntry);

    let classicScoresAll = allScoresStored.filter(s => s.mode === 'classic');
    let hardcoreScoresAll = allScoresStored.filter(s => s.mode === 'hardcore');

    classicScoresAll.sort((a, b) => b.score - a.score);
    const top100Classic = classicScoresAll.slice(0, 100);

    hardcoreScoresAll.sort((a, b) => b.score - a.score);
    const top100Hardcore = hardcoreScoresAll.slice(0, 100);
    
    const finalScoresToStore = [...top100Classic, ...top100Hardcore];
    localStorage.setItem('highScores', JSON.stringify(finalScoresToStore));

    const modeScoresForChecking = (currentGameMode === 'classic' ? top100Classic : top100Hardcore);
    let isNewHighScoreForMode = false;

    if (modeScoresForChecking.length > 0) {
        const newEntryIndexInModeScores = modeScoresForChecking.findIndex(
            hs => hs.score === newEntry.score && 
                  hs.timestamp === newEntry.timestamp && 
                  hs.mode === newEntry.mode
        );

        if (newEntryIndexInModeScores !== -1) { 
            if (newEntry.score > ( (modeScoresForChecking[0]?.score === newEntry.score && modeScoresForChecking[0]?.timestamp === newEntry.timestamp) ? -1 : (modeScoresForChecking[0]?.score || 0) ) ) {
                 isNewHighScoreForMode = true; 
            } else if (newEntryIndexInModeScores === 0 && modeScoresForChecking.length === 1) {
                 isNewHighScoreForMode = true; 
            } else if (newEntryIndexInModeScores === 0 && newEntry.score >= (modeScoresForChecking[1]?.score || 0) ) {
                 isNewHighScoreForMode = true; 
            }
        }
    } else { 
        if ( (currentGameMode === 'classic' && top100Classic.some(hs => hs.timestamp === newEntry.timestamp)) ||
             (currentGameMode === 'hardcore' && top100Hardcore.some(hs => hs.timestamp === newEntry.timestamp)) ) {
            isNewHighScoreForMode = true;
        }
    }
    return isNewHighScoreForMode;
}

function createItemListItem(itemData, isReplayScreen, rank = null) {
    const li = document.createElement('li');
    // ... (initial li and itemContentBox setup as before) ...

    let scoreToDisplay, timeStringToDisplay, itemTimestamp, itemMode, replayIdForLookup, initialNote; // itemTimestamp and itemMode are key for shared notes
    const willHaveExternalRank = (rank !== null && !isReplayScreen);

    const itemContentBox = document.createElement('div');
    itemContentBox.classList.add('item-content-box');

    const noteContainer = document.createElement('div');
    noteContainer.classList.add('item-note-container');


    if (isReplayScreen) {
        li.classList.add('replay-list-entry');
        scoreToDisplay = itemData.fs;    // Final Score from replay
        timeStringToDisplay = fnFT(itemData.ft); // Final Time from replay
        itemTimestamp = itemData.ts;     // Timestamp from replay data (game end time)
        replayIdForLookup = itemData.i;  // Replay's own unique ID
        itemMode = R_GM_REV_MAP[itemData.gm] || 'classic'; // Game mode from replay

        initialNote = getSharedNote(itemTimestamp, itemMode); // <<< USE SHARED FUNCTION

        // ... (rest of itemContentBox population for Replay as before) ...
        const itemInfoDiv = document.createElement('div');
        itemInfoDiv.classList.add('item-info');
        const line1 = document.createElement('div');
        line1.innerHTML = `<strong>${scoreToDisplay} pts</strong> (${timeStringToDisplay})`;
        const line2 = document.createElement('div');
        const itemDate = new Date(itemTimestamp);
        const dateStr = itemDate.toLocaleDateString();
        const timeStrVal = itemDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        line2.textContent = `${dateStr} - ${timeStrVal}`;
        itemInfoDiv.appendChild(line1);
        itemInfoDiv.appendChild(line2);
        itemContentBox.appendChild(itemInfoDiv);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('item-actions');
        let replayForThisItemCompact = null;
         if (replayIdForLookup) { // This is itemData.i from replay
             replayForThisItemCompact = sReps.find(r => r.i === replayIdForLookup);
         }
         if (replayForThisItemCompact) {
             // ... (Play, Export, Delete buttons for replay - logic remains same) ...
             const playBtn = document.createElement('button');
             playBtn.title = 'Play Replay';
             playBtn.classList.add('play-btn-geom');
             playBtn.innerHTML = `<svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path></svg>`;
             playBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnSRP(replayForThisItemCompact); };
             actionsDiv.appendChild(playBtn);

             const exportBtn = document.createElement('button');
             exportBtn.title = 'Export Replay';
             exportBtn.classList.add('export-btn-geom');
             exportBtn.innerHTML = `<svg viewBox="0 0 24 24" class="export-svg-icon" xmlns="http://www.w3.org/2000/svg">
                 <line x1="12" y1="15" x2="12" y2="5" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
                 <polyline points="8 9 12 5 16 9" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 </svg>`;
             exportBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnShowExportDialog(replayForThisItemCompact); };
             actionsDiv.appendChild(exportBtn);

             const deleteBtn = document.createElement('button');
             deleteBtn.title = 'Delete Replay';
             deleteBtn.classList.add('delete-btn-geom');
             deleteBtn.innerHTML = `<svg viewBox="0 0 10 10" class="delete-svg-icon" xmlns="http://www.w3.org/2000/svg"><line x1="1.5" y1="1.5" x2="8.5" y2="8.5"/><line x1="8.5" y1="1.5" x2="1.5" y2="8.5"/></svg>`;
             // For deleting a replay, we also need to delete its shared note
             deleteBtn.onclick = (e) => {
                 e.stopPropagation();
                 fnPS('click');
                 // Pass timestamp and mode to fnSDRC if it's going to handle shared note deletion
                 // Otherwise, delete shared note here before calling fnSDRC or after in fnCDR
                 fnSDRC(replayForThisItemCompact.i, itemTimestamp, itemMode); // Pass more info
             };
             actionsDiv.appendChild(deleteBtn);
         }
        itemContentBox.appendChild(actionsDiv);
        li.appendChild(itemContentBox);
        li.appendChild(noteContainer);

    } else { // Personal Best Screen
        li.classList.add('score-list-entry');
        li.classList.add('score-list-entry-ranked');

        scoreToDisplay = itemData.score;
        timeStringToDisplay = itemData.time;
        itemTimestamp = itemData.timestamp; // Timestamp from personal best data (game end time)
        replayIdForLookup = itemData.replayId; // Might be null if no replay linked
        itemMode = itemData.mode;          // Game mode from personal best

        initialNote = getSharedNote(itemTimestamp, itemMode); // <<< USE SHARED FUNCTION

        // ... (rest of itemContentBox and wrapper setup for Personal Best as before) ...
         if (willHaveExternalRank) {
             const rankSpan = document.createElement('span');
             rankSpan.classList.add('score-rank');
             rankSpan.textContent = `${rank}.`;
             li.appendChild(rankSpan);
         }

         const contentAndNoteWrapper = document.createElement('div');
         contentAndNoteWrapper.style.display = 'flex';
         contentAndNoteWrapper.style.flexDirection = 'column';
         contentAndNoteWrapper.style.flexGrow = '1';
         contentAndNoteWrapper.style.minWidth = '0';

         const itemInfoDiv = document.createElement('div');
         itemInfoDiv.classList.add('item-info');
         const line1 = document.createElement('div');
         line1.innerHTML = `<strong>${scoreToDisplay} pts</strong> (${timeStringToDisplay})`;
         const line2 = document.createElement('div');
         const itemDate = new Date(itemTimestamp);
         const dateStr = itemDate.toLocaleDateString();
         const timeStrVal = itemDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
         line2.textContent = `${dateStr} - ${timeStrVal}`;
         itemInfoDiv.appendChild(line1);
         itemInfoDiv.appendChild(line2);
         itemContentBox.appendChild(itemInfoDiv);

         const actionsDiv = document.createElement('div');
         actionsDiv.classList.add('item-actions');
         let replayForThisItemCompactHS = null;
         if (replayIdForLookup) {
             replayForThisItemCompactHS = sReps.find(r => r.i === replayIdForLookup);
         }
         if (replayForThisItemCompactHS) {
             // ... (Play, Export, Delete buttons for high score's replay link - logic remains same) ...
             // Note: Deleting a replay via high score should also delete its shared note
             const playBtn = document.createElement('button');
             playBtn.title = 'Play Replay';
             playBtn.classList.add('play-btn-geom');
             playBtn.innerHTML = `<svg viewBox="0 0 24 24" class="play-svg-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.4086 9.35258C23.5305 10.5065 23.5305 13.4935 21.4086 14.6474L8.59662 21.6145C6.53435 22.736 4 21.2763 4 18.9671L4 5.0329C4 2.72368 6.53435 1.26402 8.59661 2.38548L21.4086 9.35258Z" fill="#ffffff"></path></svg>`;
             playBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnSRP(replayForThisItemCompactHS); };
             actionsDiv.appendChild(playBtn);

             const exportBtn = document.createElement('button');
             exportBtn.title = 'Export Replay';
             exportBtn.classList.add('export-btn-geom');
             exportBtn.innerHTML = `<svg viewBox="0 0 24 24" class="export-svg-icon" xmlns="http://www.w3.org/2000/svg">
                 <line x1="12" y1="15" x2="12" y2="5" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
                 <polyline points="8 9 12 5 16 9" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 <polyline points="4 17 4 21 20 21 20 17" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                 </svg>`;
             exportBtn.onclick = (e) => { e.stopPropagation(); fnPS('click'); fnShowExportDialog(replayForThisItemCompactHS); };
             actionsDiv.appendChild(exportBtn);

             const deleteBtn = document.createElement('button');
             deleteBtn.title = 'Delete Replay';
             deleteBtn.classList.add('delete-btn-geom');
             deleteBtn.innerHTML = `<svg viewBox="0 0 10 10" class="delete-svg-icon" xmlns="http://www.w3.org/2000/svg"><line x1="1.5" y1="1.5" x2="8.5" y2="8.5"/><line x1="8.5" y1="1.5" x2="1.5" y2="8.5"/></svg>`;
             deleteBtn.onclick = (e) => {
                 e.stopPropagation();
                 fnPS('click');
                 // If deleting replay from HS list, we need its original timestamp & mode to delete the shared note
                 const replayToDelete = sReps.find(r => r.i === replayIdForLookup);
                 if (replayToDelete) {
                     fnSDRC(replayIdForLookup, replayToDelete.ts, R_GM_REV_MAP[replayToDelete.gm]);
                 } else {
                     fnSDRC(replayIdForLookup); // Fallback if replay somehow not found
                 }
             };
             actionsDiv.appendChild(deleteBtn);
         }
         itemContentBox.appendChild(actionsDiv);
         contentAndNoteWrapper.appendChild(itemContentBox);
         contentAndNoteWrapper.appendChild(noteContainer);
         li.appendChild(contentAndNoteWrapper);
    }

    // --- Note Handling Logic (functionality remains the same, but uses saveSharedNote) ---
    const placeholderText = "Click to add note...";

    function showNoteDisplay(text) { /* ... same as before ... */
         noteContainer.innerHTML = '';
         if (text) {
             const noteTextSpan = document.createElement('span');
             noteTextSpan.textContent = text;
             noteContainer.appendChild(noteTextSpan);
         } else {
             const placeholderSpan = document.createElement('span');
             placeholderSpan.classList.add('note-placeholder-text');
             placeholderSpan.textContent = placeholderText;
             noteContainer.appendChild(placeholderSpan);
         }
         noteContainer.classList.add('visible');
    }

    function showEditableNote(currentText) { /* ... same as before ... */
         noteContainer.innerHTML = '';
         const editableArea = document.createElement('div');
         editableArea.classList.add('note-editable-area');
         editableArea.contentEditable = "true";
         editableArea.textContent = (currentText === placeholderText || currentText === "") ? "" : currentText;
         noteContainer.appendChild(editableArea);
         editableArea.focus();

         if (currentText !== placeholderText && currentText !== "") {
             const range = document.createRange();
             range.selectNodeContents(editableArea);
             const sel = window.getSelection();
             sel.removeAllRanges();
             sel.addRange(range);
         }
         editableArea.dataset.editing = "true";

         function saveAndExitEditing() {
             if (editableArea.dataset.editing !== "true") return;
             editableArea.dataset.editing = "false";

             const newNoteText = editableArea.textContent.trim();
             // itemTimestamp and itemMode are already correctly set for both HS and Replay contexts
             saveSharedNote(itemTimestamp, itemMode, newNoteText); // <<< USE SHARED FUNCTION
             initialNote = newNoteText;

             if (newNoteText) {
                 showNoteDisplay(newNoteText);
             } else {
                 showNoteDisplay("");
                 if (!li.matches(':hover')) {
                     noteContainer.classList.remove('visible');
                 }
             }
         }
         // ... (blur and keydown listeners for editableArea remain the same) ...
         editableArea.addEventListener('blur', () => {
             setTimeout(saveAndExitEditing, 50);
         });

         editableArea.addEventListener('keydown', (e) => {
             if (e.key === 'Enter' && !e.shiftKey) {
                 e.preventDefault();
                 saveAndExitEditing();
             } else if (e.key === 'Escape') {
                 e.preventDefault();
                 editableArea.dataset.editing = "false";
                 showNoteDisplay(initialNote || "");
                  if (!initialNote && !li.matches(':hover')) {
                      noteContainer.classList.remove('visible');
                  }
             }
         });
    }
     // ... (initial display and li mouseenter/mouseleave for notes remain the same) ...
     if (initialNote) {
         showNoteDisplay(initialNote);
     }

     li.addEventListener('mouseenter', () => {
         if (!noteContainer.querySelector('.note-editable-area')) {
             if (initialNote) {
                 showNoteDisplay(initialNote);
             } else {
                 showNoteDisplay("");
             }
         }
     });

     li.addEventListener('mouseleave', () => {
         if (!noteContainer.querySelector('.note-editable-area')) {
             if (!initialNote) {
                 noteContainer.classList.remove('visible');
                 noteContainer.innerHTML = '';
             }
         }
     });

    noteContainer.addEventListener('click', (e) => { /* ... same as before ... */
         e.stopPropagation();
         fnPS('click');
         if (!noteContainer.querySelector('.note-editable-area')) {
             const currentDisplayedText = noteContainer.textContent;
             showEditableNote(currentDisplayedText);
         }
    });
    // noteContainer is appended within the if/else blocks now

    return li;
}

function fnDHS() { 
    const scores = fnGHS(); 
    const cl = document.getElementById('classicHighScoresList');
    const hl = document.getElementById('hardcoreHighScoresList');
    if (!cl || !hl) { console.error("Personal best list elements not found!"); return; }
    cl.innerHTML = ''; hl.innerHTML = '';

    const classicScores = scores.filter(s => s.mode === 'classic').sort((a, b) => b.score - a.score).slice(0, 100);
    const hardcoreScores = scores.filter(s => s.mode === 'hardcore').sort((a, b) => b.score - a.score).slice(0, 100);

    if (classicScores.length === 0) {
        const li = document.createElement('li');
        li.classList.add('score-list-entry'); 
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box'); 
        contentBox.style.justifyContent = 'center'; 
        contentBox.textContent = 'No classic scores yet!';
        li.appendChild(contentBox);
        cl.appendChild(li);
    } else {
        classicScores.forEach((score, index) => cl.appendChild(createItemListItem(score, false, index + 1)));
    }

    if (hardcoreScores.length === 0) {
        const li = document.createElement('li');
        li.classList.add('score-list-entry'); 
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box'); 
        contentBox.style.justifyContent = 'center'; 
        contentBox.textContent = 'No hardcore scores yet!';
        li.appendChild(contentBox);
        hl.appendChild(li);
    } else {
        hardcoreScores.forEach((score, index) => hl.appendChild(createItemListItem(score, false, index + 1)));
    }
}


function fnDRpsL() {
    const classicListEl = document.getElementById('classicReplaysList');
    const hardcoreListEl = document.getElementById('hardcoreReplaysList');
    const classicHeaderEl = classicListEl.previousElementSibling;
    const hardcoreHeaderEl = hardcoreListEl.previousElementSibling;

    classicListEl.innerHTML = '';
    hardcoreListEl.innerHTML = '';

    const MAX_REPLAYS_PER_MODE = 50;

    const classicReplays = sReps.filter(r => r.gm === R_GM_MAP.classic);
    const hardcoreReplays = sReps.filter(r => r.gm === R_GM_MAP.hardcore);

    classicReplays.sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());
    hardcoreReplays.sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());

    if (classicHeaderEl) classicHeaderEl.textContent = `Classic Mode (${classicReplays.length}/${MAX_REPLAYS_PER_MODE})`;
    if (classicReplays.length === 0) {
        const li = document.createElement('li');
        li.classList.add('replay-list-entry');
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box');
        contentBox.style.justifyContent = 'center';
        contentBox.textContent = 'No classic replays!';
        li.appendChild(contentBox);
        classicListEl.appendChild(li);
    } else {
        const classicFragment = document.createDocumentFragment();
        classicReplays.forEach(r => {
            const listItem = createItemListItem(r, true);
            classicFragment.appendChild(listItem);
        });
        classicListEl.appendChild(classicFragment);
    }

    if (hardcoreHeaderEl) hardcoreHeaderEl.textContent = `Hardcore Mode (${hardcoreReplays.length}/${MAX_REPLAYS_PER_MODE})`;
    if (hardcoreReplays.length === 0) {
        const li = document.createElement('li');
        li.classList.add('replay-list-entry');
        const contentBox = document.createElement('div');
        contentBox.classList.add('item-content-box');
        contentBox.style.justifyContent = 'center';
        contentBox.textContent = 'No hardcore replays!';
        li.appendChild(contentBox);
        hardcoreListEl.appendChild(li);
    } else {
        const hardcoreFragment = document.createDocumentFragment();
        hardcoreReplays.forEach(r => {
            const listItem = createItemListItem(r, true);
            hardcoreFragment.appendChild(listItem);
        });
        hardcoreListEl.appendChild(hardcoreFragment);
    }
}

function fnShowDeleteAllConf() { fnPS('click'); deleteAllReplaysConfirmationDialog.style.display = 'flex'; }
function fnHDARC() { deleteAllReplaysConfirmationDialog.style.display = 'none'; fnPS('click'); }
function fnCDAR() {
    sReps = [];
    localStorage.removeItem('colorfallReplays');
    // localStorage.removeItem('colorfallReplayNotes'); // OLD, if you had this
    localStorage.removeItem('colorfallSharedNotes'); // <<< REMOVE ALL SHARED NOTES

    let highScores = fnGHS();
    highScores = highScores.map(hs => ({ ...hs, replayId: null, note: "" })); // Clear notes from HS too
    localStorage.setItem('highScores', JSON.stringify(highScores));

    fnDRpsL();
    fnHDARC();
    fnPS('click');
}

function fnShowExportDialog(compactReplayData) { 
    exportReplayTextArea.value = JSON.stringify(compactReplayData);
    exportReplayDialog.style.display = 'flex';
}
function fnCopyExportedReplay() {
    exportReplayTextArea.select();
    exportReplayTextArea.setSelectionRange(0, exportReplayTextArea.value.length);

    const buttonTextSpan = copyExportReplayBtn.querySelector('.btn-text-dynamic');

    try {
        document.execCommand('copy');

        if (buttonTextSpan) {
            buttonTextSpan.textContent = 'Copied!';
        }
        copyExportReplayBtn.classList.add('copied-success');


        setTimeout(() => {
            if (buttonTextSpan) {
                buttonTextSpan.textContent = 'Copy';
            }
            copyExportReplayBtn.classList.remove('copied-success');

            if (exportReplayDialog) {
                exportReplayDialog.style.display = 'none';
            }
        }, 800); 
    } catch (err) {
        console.error('Failed to copy replay code: ', err);
        if (buttonTextSpan) {
            buttonTextSpan.textContent = 'Copy Failed';
        }
        setTimeout(() => {
            if (buttonTextSpan) {
                buttonTextSpan.textContent = 'Copy';
            }
        }, 2000);
    }
    fnPS('click'); // Play click sound on initial button press
}

function fnShowImportDialog() {
    importReplayTextArea.value = '';
    importReplayError.textContent = '';
    importReplayDialog.style.display = 'flex';
    fnPS('click');
}
function fnImportAndPlayReplay() {
    fnPS('click');
    const code = importReplayTextArea.value;
    if (!code.trim()) {
        importReplayError.textContent = "Paste code first!";
        return;
    }
    try {
        let importedReplay = JSON.parse(code);
        
        if (importedReplay && typeof importedReplay.v === 'number' && (importedReplay.i || importedReplay.id) && (importedReplay.gs !== undefined || importedReplay.gameSeed !== undefined)) {
            
            
            
            
            
            const verboseReplayForPlayback = fnDecodeReplayData(importedReplay); 
            if (!verboseReplayForPlayback) {
                 importReplayError.textContent = "Invalid or unsupported replay format!";
                 return;
            }

            importReplayDialog.style.display = 'none';
            
            
            
            
            
            

            fnSRP(verboseReplayForPlayback, true); 
        } else {
            importReplayError.textContent = "Invalid Replay Code Structure!";
        }
    } catch (e) {
        console.error("Error parsing imported replay:", e);
        importReplayError.textContent = "Invalid Replay Code Format!";
    }
}

function fnEncodeReplayData(verboseData) {
    if (!verboseData || !verboseData.events || verboseData.v === REPLAY_FORMAT_VERSION) {
        return verboseData; 
    }

    const compact = {
        v: REPLAY_FORMAT_VERSION,
        i: verboseData.id,
        gs: verboseData.gameSeed,
        gm: R_GM_MAP[verboseData.gameMode], 
        ts: verboseData.timestamp,
        fs: verboseData.finalScore,
        ft: parseFloat(verboseData.finalTimeMs.toFixed(1)),
        ogw: verboseData.originalGameWidth,    
        ogh: verboseData.originalGameHeight,   
        c: { 
            cw: verboseData.cosmetics && verboseData.cosmetics.colorWheel !== undefined ? verboseData.cosmetics.colorWheel : R_COSMETIC_DEFAULTS.colorWheel,
            b: verboseData.cosmetics && verboseData.cosmetics.bucket !== undefined ? verboseData.cosmetics.bucket : R_COSMETIC_DEFAULTS.bucket
        },
        e: []
    };

    if (typeof compact.gm !== 'number') {
        // console.warn(`fnEncodeReplayData: compact.gm is not a number (value: ${compact.gm}). Defaulting to classic (0). verboseData.gameMode was: '${verboseData.gameMode}'. Replay ID: ${verboseData.id}`); // Optional
        compact.gm = R_GM_MAP.classic; 
    }

    verboseData.events.forEach(event => {
        const t = parseFloat(event.t.toFixed(1));
        let compactEvent = [t];
        switch (event.type) {
            case 'mouse':
                compactEvent.push(R_EV_TYPES.MOUSE, parseFloat(event.x.toFixed(1)), parseFloat(event.y.toFixed(1)));
                break;
            case 'keydown':
                compactEvent.push(R_EV_TYPES.KEYDOWN, event.key);
                break;
            case 'keyup':
                compactEvent.push(R_EV_TYPES.KEYUP, event.key);
                break;
            case 'scoreLivesUpdate':
                compactEvent.push(R_EV_TYPES.SCORE_LIVES, event.score, event.lives);
                break;
            case 'powerupActivate':
                const puTypeAct = R_PU_TYPES[event.powerupType];
                const endTime = parseFloat(event.endTime.toFixed(1));
                let oneColorCode = null;
                if (event.powerupType === 'oneColor' && event.color) {
                    oneColorCode = R_COLOR_CODES[event.color];
                }
                compactEvent.push(R_EV_TYPES.POWERUP_ACT, puTypeAct, endTime, oneColorCode, event.collectedBallId !== undefined ? event.collectedBallId : null);
                break;
            case 'powerupDeactivate':
                const puTypeDeact = R_PU_TYPES[event.powerupType];
                compactEvent.push(R_EV_TYPES.POWERUP_DEACT, puTypeDeact);
                break;
            case 'ballSpawn':
                const colorCode = event.isPowerup ? R_COLOR_CODES.powerup : R_COLOR_CODES[event.colorName];
                compactEvent.push(R_EV_TYPES.BALL_SPAWN,
                    event.id, event.dropperId, event.isPowerup ? 1 : 0, colorCode,
                    parseFloat(event.fallSpeedFactor.toFixed(5)), parseFloat(event.sizeMultiplier.toFixed(5)),
                    parseFloat(event.swayTime.toFixed(5)), event.vx_sway_direction === 1 ? 1 : 0
                );
                break;
            case 'ballDespawn':
                compactEvent.push(R_EV_TYPES.BALL_DESPAWN, event.ballId, R_DESPAWN_REASONS[event.reason]);
                break;
            case 'gameEnd':
                compactEvent.push(R_EV_TYPES.GAME_END);
                break;
            default: return; 
        }
        compact.e.push(compactEvent);
    });
    return compact;
}

function fnDecodeReplayData(dataToDecode) {
    if (!dataToDecode || typeof dataToDecode.v !== 'number') {
        console.error("Invalid data for decoding: 'v' (version) property is missing or not a number.", dataToDecode);
        return null;
    }

    if (dataToDecode.v === REPLAY_FORMAT_VERSION) { 
        if (dataToDecode.e && Array.isArray(dataToDecode.e)) {
            const verbose = {
                v: dataToDecode.v,
                id: dataToDecode.i,
                gameSeed: dataToDecode.gs,
                gameMode: R_GM_REV_MAP[dataToDecode.gm] || 'classic',
                timestamp: dataToDecode.ts,
                finalScore: dataToDecode.fs,
                finalTimeMs: dataToDecode.ft,
                finalTimeStr: fnFT(dataToDecode.ft),
                originalGameWidth: dataToDecode.ogw,    
                originalGameHeight: dataToDecode.ogh,   
                cosmetics: {
                    colorWheel: "default",
                    bucket: "default"
                },
                events: []
            };

            dataToDecode.e.forEach(eventArr => {
                const t = eventArr[0];
                const typeCode = eventArr[1];
                const typeStr = R_REV_EV_TYPES[typeCode];
                let verboseEvent = { t: t, type: typeStr };

                switch (typeCode) {
                    case R_EV_TYPES.MOUSE:
                        verboseEvent.x = eventArr[2];
                        verboseEvent.y = eventArr[3];
                        break;
                    case R_EV_TYPES.KEYDOWN:
                    case R_EV_TYPES.KEYUP:
                        verboseEvent.key = eventArr[2];
                        break;
                    case R_EV_TYPES.SCORE_LIVES:
                        verboseEvent.score = eventArr[2];
                        verboseEvent.lives = eventArr[3];
                        break;
                    case R_EV_TYPES.POWERUP_ACT:
                        verboseEvent.powerupType = R_PU_REV_TYPES[eventArr[2]];
                        verboseEvent.endTime = eventArr[3];
                        if (eventArr[4] !== null && eventArr[4] !== undefined) {
                            verboseEvent.color = R_REV_COLOR_NAMES[eventArr[4]];
                        }
                        if (eventArr[5] !== null && eventArr[5] !== undefined) {
                            verboseEvent.collectedBallId = eventArr[5];
                        }
                        break;
                    case R_EV_TYPES.POWERUP_DEACT:
                        verboseEvent.powerupType = R_PU_REV_TYPES[eventArr[2]];
                        break;
                    case R_EV_TYPES.BALL_SPAWN:
                        verboseEvent.id = eventArr[2];
                        verboseEvent.dropperId = eventArr[3];
                        verboseEvent.isPowerup = eventArr[4] === 1;
                        const colorNameSpawn = R_REV_COLOR_NAMES[eventArr[5]];
                        verboseEvent.colorName = colorNameSpawn;
                        if (verboseEvent.isPowerup) verboseEvent.colorHex = POWERUP_BALL_COLOR_HEX;
                        else if (colorNameSpawn === 'white') verboseEvent.colorHex = WHITE_BALL_COLOR_HEX;
                        else verboseEvent.colorHex = BALL_COLORS[R_COLOR_CODES[colorNameSpawn]];
                        verboseEvent.fallSpeedFactor = eventArr[6];
                        verboseEvent.sizeMultiplier = eventArr[7];
                        verboseEvent.swayTime = eventArr[8];
                        verboseEvent.vx_sway_direction = eventArr[9] === 1 ? 1 : -1;
                        break;
                    case R_EV_TYPES.BALL_DESPAWN:
                        verboseEvent.ballId = eventArr[2];
                        verboseEvent.reason = R_REV_DESPAWN_REASONS[eventArr[3]];
                        break;
                    case R_EV_TYPES.GAME_END:
                        break;
                    default: return;
                }
                verbose.events.push(verboseEvent);
            });
            return verbose;
        } else if (dataToDecode.events && Array.isArray(dataToDecode.events)) {
            console.warn("Replay tagged as V3/V4 but missing 'e' (compact events) array; 'events' (verbose events) array found. Attempting to parse as V2 verbose format.");
            const parsedData = { ...dataToDecode };
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
            if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                 parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800); 
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);
            if (typeof parsedData.gameMode === 'number') { 
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gameMode] || 'classic';
            } else if (typeof parsedData.gm === 'number') { 
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
                 delete parsedData.gm;
            } else if (!parsedData.gameMode) { 
                parsedData.gameMode = 'classic';
            }

            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error("Invalid V3/V4 replay data: 'e' (compact events) and 'events' (verbose events) properties are missing or not valid arrays.", dataToDecode);
            return null;
        }
    } else if (dataToDecode.v === 2) {
        if (dataToDecode.events && Array.isArray(dataToDecode.events)) {
            const parsedData = { ...dataToDecode };
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
            if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800); 
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);
            if (!parsedData.gameMode && typeof parsedData.gm === 'number') {
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
            } else if (!parsedData.gameMode) {
                parsedData.gameMode = 'classic';
            }

            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error("Invalid V2 replay data: 'events' property is missing or not an array.", dataToDecode);
            return null;
        }
    } else {
        console.warn(`Replay version ${dataToDecode.v} is not V2, V3 or V4. Attempting to treat as pass-through verbose if 'events' array exists.`);
        if (dataToDecode.events && Array.isArray(dataToDecode.events)) {
            const parsedData = { ...dataToDecode };
            parsedData.finalTimeMs = parseFloat(parsedData.finalTimeMs);
             if (isNaN(parsedData.finalTimeMs) && parsedData.events.length > 0) {
                parsedData.finalTimeMs = parsedData.events[parsedData.events.length-1].t || 0;
            }
            parsedData.originalGameWidth = parsedData.originalGameWidth || (gameCanvas ? gameCanvas.width / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 800); 
            parsedData.originalGameHeight = parsedData.originalGameHeight || (gameCanvas ? gameCanvas.height / (QUALITY_SETTINGS_MAP[currentQualitySetting] || (window.devicePixelRatio || 1)) : 450);
            if (!parsedData.gameMode && typeof parsedData.gm === 'number') {
                 parsedData.gameMode = R_GM_REV_MAP[parsedData.gm] || 'classic';
            } else if (!parsedData.gameMode) {
                parsedData.gameMode = 'classic';
            }

            parsedData.events = parsedData.events.map(e => ({
                ...e,
                t: parseFloat(e.t),
                ...(e.x !== undefined && { x: parseFloat(e.x) }),
                ...(e.y !== undefined && { y: parseFloat(e.y) }),
                ...(e.endTime !== undefined && { endTime: parseFloat(e.endTime) }),
                ...(e.fallSpeedFactor !== undefined && { fallSpeedFactor: parseFloat(e.fallSpeedFactor) }),
                ...(e.sizeMultiplier !== undefined && { sizeMultiplier: parseFloat(e.sizeMultiplier) }),
                ...(e.swayTime !== undefined && { swayTime: parseFloat(e.swayTime) }),
            }));
            return parsedData;
        } else {
            console.error(`Unsupported replay version ${dataToDecode.v} or 'events' array missing for pass-through.`, dataToDecode);
            return null;
        }
    }
}

function fnSRP(replayDataToPlay, isFromImport = false) {
    if (!replayDataToPlay) return;

    let verboseReplay = fnDecodeReplayData(replayDataToPlay);

    if (!verboseReplay) {
        console.error("Failed to decode replay for playback in fnSRP.");
        fnSS('home');
        return;
    }

    fnSS('replayViewer');
    rVState.activeReplay = verboseReplay;
    rVState.isPlaying = false;
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    rVState.currentTimeMs = 0;
    rVState.totalDurationMs = verboseReplay.finalTimeMs || (verboseReplay.events.length > 0 ? verboseReplay.events[verboseReplay.events.length - 1].t : 0);
    if (rVState.totalDurationMs === 0 && verboseReplay.events.length > 0) {
        rVState.totalDurationMs = verboseReplay.events[verboseReplay.events.length - 1].t;
    }
    rVState.keysPressedReplay = {};
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;

    fnAREUTT(0, true);

    fnSetReplayButtonIcon(false);
    replaySeekBar.max = 100;
    replaySeekBar.value = 0;

    redrawStaticFrame();
    fnURUI();
    fnUPI();
}


function fnRecordBallSpawnEvent(ballData) {
    if (cRepData && !rVState.activeReplay) {
        
        const roundedBallData = { ...ballData };
        roundedBallData.fallSpeedFactor = parseFloat(ballData.fallSpeedFactor.toFixed(5));
        roundedBallData.sizeMultiplier = parseFloat(ballData.sizeMultiplier.toFixed(5));
        roundedBallData.swayTime = parseFloat(ballData.swayTime.toFixed(5));
        
        cRepData.events.push({
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: 'ballSpawn',
            ...roundedBallData 
        });
    }
}

function fnRecordBallDespawnEvent(ballId, despawnTime, reason) {
    if (cRepData && !rVState.activeReplay) {
        cRepData.events.push({
            t: parseFloat(despawnTime.toFixed(1)),
            type: 'ballDespawn',
            ballId: ballId,
            reason: reason 
        });
    }
}


function fnSCR() {
    const MAX_REPLAYS_PER_MODE = 50;
    const btnTextSpan = saveReplayBtnElem.querySelector('.btn-text');
    let currentButtonText = btnTextSpan ? btnTextSpan.textContent : saveReplayBtnElem.textContent;

    // console.log("--------------------------------------------------");
    // console.log("fnSCR: ENTERED for a save attempt.");
    // console.log("fnSCR: Current saveReplayBtn text:", currentButtonText, "ClassList:", saveReplayBtnElem.classList.toString());
    // if (cRepData) {
    //     console.log("fnSCR: cRepData at entry: Game Mode=", cRepData.gameMode, "Score=", cRepData.finalGameScore, "HS Timestamp=", cRepData.gameEndTimestampForHS, "Events count=", cRepData.events.length);
    // } else {
    //     console.warn("fnSCR: cRepData is NULL at entry!");
    // }
    // console.log("fnSCR: lastSavedReplayId at entry:", lastSavedReplayId);
    // console.log("--------------------------------------------------");

    if (saveReplayBtnElem.classList.contains('saved')) {
        // console.log("fnSCR: Button has 'saved' class. Exiting to prevent re-save of already processed game.");
        return;
    }

    if (!cRepData || !cRepData.events || cRepData.events.length === 0) {
        // console.warn("fnSCR: CRITICAL - cRepData is null or has no events after 'saved' class check. Cannot save replay."); // Optional to keep for rare cases
        if (!currentButtonText.includes("Limit Reached")) { 
            updateButtonText(saveReplayBtnElem, "No Data to Save");
            setTimeout(() => {
                const updatedBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (updatedBtnText.includes("No Data to Save") && !updatedBtnText.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                    updateButtonText(saveReplayBtnElem, "Save Replay");
                }
            }, 2000);
        }
        return; 
    }

    const modeForSaveAttempt = cRepData.gameMode;
    const gameModeCompactCode = R_GM_MAP[modeForSaveAttempt];
    const existingReplaysInMode = sReps.filter(r => r.gm === gameModeCompactCode).length;

    if (existingReplaysInMode >= MAX_REPLAYS_PER_MODE) {
        const modeNameReadable = modeForSaveAttempt.charAt(0).toUpperCase() + modeForSaveAttempt.slice(1);
        fnShowReplayLimitNotification(`${modeNameReadable} Replays Full! (${MAX_REPLAYS_PER_MODE}/${MAX_REPLAYS_PER_MODE})`);
        currentButtonText = btnTextSpan ? btnTextSpan.textContent : saveReplayBtnElem.textContent; 
        if (!currentButtonText.includes("Limit Reached")) {
            updateButtonText(saveReplayBtnElem, "Limit Reached");
            saveReplayBtnElem.classList.remove('saved');
        }
        return; 
    }

    const replayIdForThisSave = Date.now() + '_S_FN_' + Math.floor(fnSRnd() * 100000); 
    lastSavedReplayId = replayIdForThisSave; 

    const verboseReplay = {
        v: -1, 
        id: replayIdForThisSave,
        gameSeed: cRepData.seed,
        gameMode: cRepData.gameMode,
        timestamp: cRepData.gameEndTimestampForHS, 
        finalScore: cRepData.finalGameScore,
        finalTimeMs: cRepData.finalTimeMs,
        finalTimeStr: fnFT(cRepData.finalTimeMs),
        originalGameWidth: gameWidth,
        originalGameHeight: gameHeight,
        cosmetics: cRepData.cosmetics,
        events: cRepData.events
    };

    const compactReplay = fnEncodeReplayData(verboseReplay);
    sReps.push(compactReplay);
    let replaySaveError = false;
    try {
        localStorage.setItem('colorfallReplays', JSON.stringify(sReps));
    } catch (e) {
        console.error("fnSCR: Error writing replays to localStorage:", e); // Keep
        replaySaveError = true;
        sReps.pop(); 
        lastSavedReplayId = null; 
    }

    if (!replaySaveError) {
        let highScores = fnGHS();
        const scoreToMatch = cRepData.finalGameScore;
        const modeToMatch = cRepData.gameMode;
        const timestampToMatch = cRepData.gameEndTimestampForHS;
        
        let foundHsIndex = -1;
        for (let i = 0; i < highScores.length; i++) {
            const hsEntry = highScores[i];
            if (hsEntry.mode === modeToMatch &&
                hsEntry.score === scoreToMatch &&
                hsEntry.timestamp === timestampToMatch && 
                hsEntry.replayId === null 
            ) {
                foundHsIndex = i;
                break; 
            }
        }

        if (foundHsIndex !== -1) {
            highScores[foundHsIndex].replayId = lastSavedReplayId; 
            try {
                localStorage.setItem('highScores', JSON.stringify(highScores));
            } catch (e) { 
                console.error("fnSCR: Error updating HS with replayId in localStorage:", e); // Keep
            }
        } else {
            // console.warn(`fnSCR: Matching HS not found to update replayId. Search criteria: mode=${modeToMatch}, score=${scoreToMatch}, timestamp=${timestampToMatch}, replayId=null.`); // Optional
        }

        updateButtonText(saveReplayBtnElem, "Replay Saved!");
        saveReplayBtnElem.classList.add('saved');
        // console.log("fnSCR: SUCCESSFUL SAVE. Nullifying cRepData. Old HS Timestamp was:", cRepData ? cRepData.gameEndTimestampForHS : "N/A"); // REMOVED
        cRepData = null; 
    } else { 
        updateButtonText(saveReplayBtnElem, "Save Failed");
        saveReplayBtnElem.classList.remove('saved');
        setTimeout(() => {
            const updatedBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
            if (updatedBtnText.includes("Save Failed") && !updatedBtnText.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                 updateButtonText(saveReplayBtnElem, "Save Replay");
            }
        }, 2000);
    }
    // console.log("--------------------------------------------------");
    // console.log("fnSCR: EXITING. lastSavedReplayId is now:", lastSavedReplayId, "cRepData is now:", cRepData ? "Exists (HS Timestamp: " + cRepData.gameEndTimestampForHS + ")" : "NULL");
    // console.log("--------------------------------------------------");
}

function fnLRS() {
    const sr = localStorage.getItem('colorfallReplays');
    sReps = []; 

    if (sr) {
        try {
            let parsedReplays = JSON.parse(sr);
            if (Array.isArray(parsedReplays)) {
                parsedReplays.forEach(r_compact => {
                    if (r_compact && 
                        typeof r_compact.v === 'number' &&
                        (r_compact.i || r_compact.id) &&   
                        typeof r_compact.gs === 'number' && 
                        typeof r_compact.gm === 'number' && 
                        typeof r_compact.ts === 'number' && 
                        typeof r_compact.fs === 'number' && 
                        typeof r_compact.ft === 'number' && 
                        Array.isArray(r_compact.e)          
                        ) {
                        sReps.push(r_compact); 
                    } else {
                        // console.warn("fnLRS: Filtering out invalid or incomplete replay object from localStorage:", r_compact); // Optional: Keep if you want to see these warnings
                    }
                });
            } else {
                console.error("fnLRS: Parsed data from localStorage is not an array:", parsedReplays); // Keep for critical errors
            }
        } catch (e) {
            console.error("fnLRS: Error parsing replays from localStorage:", e); // Keep for critical errors
            sReps = []; 
        }
    }
}

let rDelData = null; // Store more than just ID
function fnSDRC(replayId, replayTimestamp, replayMode) { // <<< MODIFIED SIGNATURE
    rDelData = { id: replayId, timestamp: replayTimestamp, mode: replayMode }; // <<< STORE MORE INFO
    deleteReplayConfirmationDialog.style.display = 'flex';
    fnPS('click');
}
 
function fnHDRC() {
    deleteReplayConfirmationDialog.style.display = 'none';
    rDelData = null; // NEW
    fnPS('click');
}

function fnCDR() {
    // if (rDelId !== null) { // OLD
    if (rDelData !== null && rDelData.id !== null) { // NEW
        // sReps = sReps.filter(r => r.i !== rDelId); // OLD
        sReps = sReps.filter(r => r.i !== rDelData.id); // NEW
        try {
            localStorage.setItem('colorfallReplays', JSON.stringify(sReps));

            // Delete the shared note using its original timestamp and mode
            if (rDelData.timestamp !== undefined && rDelData.mode !== undefined) { // <<< ADDED CHECK
                saveSharedNote(rDelData.timestamp, rDelData.mode, ""); // Save empty note to delete it
            } else {
                // Fallback: try to find the replay again if timestamp/mode weren't passed (less ideal)
                // This part might be redundant if createItemListItem always passes timestamp/mode
                const deletedReplay = sReps.find(r => r.i === rDelData.id); // This find will fail as it's already filtered
                                                                            // We need to find it BEFORE filtering sReps or rely on passed data.
                                                                            // For now, rely on rDelData.timestamp and rDelData.mode being correct.
                console.warn("Attempting to delete shared note for replay but timestamp/mode missing from rDelData. Note might persist if not directly cleared via fnSDRC params.");
            }


            let highScores = fnGHS();
            highScores = highScores.map(hs => {
                // if (hs.replayId === rDelId) { // OLD
                if (hs.replayId === rDelData.id) { // NEW
                    return { ...hs, replayId: null };
                }
                return hs;
            });
            localStorage.setItem('highScores', JSON.stringify(highScores));

        } catch (e) {
            console.error("Error saving after delete:", e);
        }
        if (screens.replays.classList.contains('active')) {
            fnDRpsL();
        } else if (screens.highScores.classList.contains('active')) {
            fnDHS();
        }
    }
    fnHDRC();
}

function fnRecordScoreLivesUpdate() {
    if (cRepData && !rVState.activeReplay) { 
        cRepData.events.push({
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: 'scoreLivesUpdate',
            score: score,
            lives: lives
        });
    }
}

function fnRecordPowerupEvent(type, powerupData) {
    if (cRepData && !rVState.activeReplay) {
        const eventData = {
            t: parseFloat(elapsedGameTimeMs.toFixed(1)),
            type: type, 
            ...powerupData
        };
        if (powerupData.endTime) {
            eventData.endTime = parseFloat(powerupData.endTime.toFixed(1));
        }
        cRepData.events.push(eventData);
    }
}

function fnACWP(x, y) {
    colorWheelParticles.push({
        x: x + (fnSRnd() - 0.5) * _PCOR * 0.5,
        y: y + (fnSRnd() - 0.5) * _PCOR * 0.5,
        radius: fnSRnd() * 2 + 1,
        alpha: 1, 
        color: `rgba(220,220,255,${0.3 + fnSRnd() * 0.3})`, 
        vx: (fnSRnd() - 0.5) * 0.5,
        vy: (fnSRnd() - 0.5) * 0.5
    });
}
function fnUCWP(d){for(let i=colorWheelParticles.length-1;i>=0;i--){const p=colorWheelParticles[i];p.x+=p.vx;p.y+=p.vy;p.alpha-=d*2;if(p.alpha<=0)colorWheelParticles.splice(i,1);}}
function fnDCWP(ctx){ // DrawColorWheelParticles
    if (!playerCursor) return; // Add a guard for playerCursor

    colorWheelParticles.forEach(p=>{
        const dx = p.x - playerCursor.x;
        const dy = p.y - playerCursor.y;
        const distSq = dx*dx + dy*dy;

        // Only draw the particle if its squared distance from the cursor's center
        // is greater than the squared outer radius of the color wheel.
        if (distSq > _PCOR * _PCOR) { 
            ctx.beginPath();
            ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
            // Ensure p.color and p.alpha are valid before using them
            if (p.color && typeof p.alpha === 'number') {
                 ctx.fillStyle=p.color.replace(/[^,]+(?=\))/,p.alpha.toFixed(2));
            } else {
                 ctx.fillStyle='rgba(200,200,255,0.5)'; // Default fallback color
            }
            ctx.fill();
        }
    });
}

function fnAPGP(x, y) {
    powerupGlowParticles.push({
        x: x,
        y: y,
        radius: fnSRnd() * 1.5 + 0.5,
        alpha: 0.8,
        color: `rgba(255,235,59,${0.5 + fnSRnd() * 0.3})`, 
        vx: (fnSRnd() - 0.5) * 20,
        vy: (fnSRnd() - 0.5) * 20,
        life: 0.5 + fnSRnd() * 0.3 
    });
}
function fnUPGP(d){for(let i=powerupGlowParticles.length-1;i>=0;i--){const p=powerupGlowParticles[i];p.x+=p.vx*d;p.y+=p.vy*d;p.alpha-=d/p.life;if(p.alpha<=0)powerupGlowParticles.splice(i,1);}}
function fnDPGP(ctx){powerupGlowParticles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color.replace(/[^,]+(?=\))/,p.alpha.toFixed(2));ctx.fill();});}

function fnIAP(){atmosphericParticles.length=0;const mR=0.5,xR=2.0,sMR=2.0,sXR=0.5;for(let i=0;i<_NAP;i++){const r=fnSRnd()*(xR-mR)+mR;const nR=(r-mR)/(xR-mR);const sM=sMR+(sXR-sMR)*nR;atmosphericParticles.push({x:fnSRnd()*gameWidth,y:fnSRnd()*gameHeight,radius:r,alpha:fnSRnd()*0.3+0.1,color:`rgba(200,220,255,1)`,vx:(fnSRnd()-0.5)*8,vy:(fnSRnd()-0.5)*8,speedMultiplier:sM});}}
function fnUAP(d){atmosphericParticles.forEach(p=>{p.vx+=(fnSRnd()-0.5)*_APAS*d;p.vy+=(fnSRnd()-0.5)*_APAS*d;const iMS=_APMSC*p.speedMultiplier;p.vx=Math.max(-iMS,Math.min(iMS,p.vx));p.vy=Math.max(-iMS,Math.min(iMS,p.vy));p.x+=p.vx*d;p.y+=p.vy*d;if(p.x<-p.radius)p.x=gameWidth+p.radius;if(p.x>gameWidth+p.radius)p.x=-p.radius;if(p.y<-p.radius)p.y=gameHeight+p.radius;if(p.y>gameHeight+p.radius)p.y=-p.radius;});}
function fnDAP(ctx){atmosphericParticles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color.replace(/[^,]+(?=\))/,p.alpha.toFixed(2));ctx.fill();});}

function fnITP(){textureParticles.length=0;for(let i=0;i<_NTP;i++){textureParticles.push({x:fnSRnd()*gameWidth,y:fnSRnd()*gameHeight,radius:fnSRnd()*0.8+0.2,alpha:fnSRnd()*0.04+0.01});}}
function fnDTP(ctx){textureParticles.forEach(p=>{ctx.fillStyle=`rgba(210,210,225,${p.alpha.toFixed(3)})`;ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fill();});}

function fnAPU(determinedPowerupTypeOrEventType, isProcessingRecordedEvent, recordedEventData) {
    const cST = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const currentModeForPowerup = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;

    if (currentModeForPowerup === 'hardcore' && determinedPowerupTypeOrEventType !== 'extraLives') {
        return;
    }

    let pT = "";
    let actualPowerupTypeToActivate;
    let oneColorValue = null;
    let calculatedEndTime;
    let powerupDetailsToRecord = {};

    if (isProcessingRecordedEvent && recordedEventData) {
        actualPowerupTypeToActivate = recordedEventData.powerupType;
        calculatedEndTime = recordedEventData.endTime;
        if (actualPowerupTypeToActivate === 'oneColor' && recordedEventData.color) {
            oneColorValue = recordedEventData.color;
        }
    } else {
        actualPowerupTypeToActivate = determinedPowerupTypeOrEventType;
        calculatedEndTime = cST + _PUDM;

        powerupDetailsToRecord.powerupType = actualPowerupTypeToActivate;
        powerupDetailsToRecord.endTime = calculatedEndTime;

        if (actualPowerupTypeToActivate === 'oneColor') {
            const rCI = Math.floor(fnSRnd() * BALL_COLOR_NAMES.length);
            oneColorValue = BALL_COLOR_NAMES[rCI];
            powerupDetailsToRecord.color = oneColorValue;
        }
        if (recordedEventData && recordedEventData.collectedBallId !== undefined) {
             powerupDetailsToRecord.collectedBallId = recordedEventData.collectedBallId;
        }

        if (!rVState.activeReplay) {
            fnPS('powerupCollect');
            if (actualPowerupTypeToActivate !== 'extraLives') {
                 fnRecordPowerupEvent('powerupActivate', powerupDetailsToRecord);
            }
            lastCollectedPowerupType = actualPowerupTypeToActivate;
        }
    }

    switch (actualPowerupTypeToActivate) {
        case 'slowFall':
            activePowerups.slowFall.active = true; activePowerups.slowFall.endTime = calculatedEndTime; pT = "Slow Fall";
            balls.forEach(b => { if (b.originalVy) { b.vy = b.originalVy * _SFSM; } }); cBllSS = _OBSS * _SFSM; break;
        case 'wideBucket':
            activePowerups.wideBucket.active = true; activePowerups.wideBucket.endTime = calculatedEndTime; pT = "Wide Bucket";
            cBktWR = _BBWRW; if (bucket) bucket.baseWidth = gameWidth * cBktWR; break;
        case 'oneColor':
            activePowerups.oneColor.active = true; activePowerups.oneColor.endTime = calculatedEndTime;
            activePowerups.oneColor.color = oneColorValue; pT = "One Color"; break;
        case 'doublePoints':
            activePowerups.doublePoints.active = true; activePowerups.doublePoints.endTime = calculatedEndTime; pT = "Double Points";
            if(isProcessingRecordedEvent && rVState.activeReplay) rVState.isReplayDoublePointsActive = true;
            break;
        case 'extraLives':
            if (!isProcessingRecordedEvent && !rVState.activeReplay) {
                lives += 3; fnRecordScoreLivesUpdate();
            }
            pT = "+3 Lives"; break;
        case 'whiteBallMagnet':
            activePowerups.whiteBallMagnet.active = true; activePowerups.whiteBallMagnet.endTime = calculatedEndTime; pT = "Magnet"; break;
    }

    if (pT && !rVState.activeReplay && !isProcessingRecordedEvent) {
        fnDPT(pT);
    }
    fnUPI();
}
function fnCP(currentTime) {
    const currentModeForPowerup = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    if (currentModeForPowerup === 'hardcore') return;

    let changed = false;
    for (const type in activePowerups) {
        const p = activePowerups[type];
        if (p.active && p.endTime && currentTime >= p.endTime) {
            p.active = false;
            changed = true;

            if (!rVState.activeReplay) {
                fnRecordPowerupEvent('powerupDeactivate', { powerupType: type });
            }
            if (type === 'wideBucket') {
                cBktWR = _BBWRN;
                if (bucket) bucket.baseWidth = gameWidth * cBktWR;
            }
            if (type === 'slowFall') {
                balls.forEach(b => { if (b.originalVy) { b.vy = b.originalVy; } });
                cBllSS = _OBSS;
            }
            if (type === 'oneColor') {
                p.color = null;
            }
            if (type === 'doublePoints' && rVState.activeReplay) {
                rVState.isReplayDoublePointsActive = false;
            }
        }
    }
    if (changed) {
        fnUPI();
    }
}
function fnGRPUT(){
    const allPowerupTypes = ['slowFall','wideBucket','oneColor','doublePoints','extraLives','whiteBallMagnet'];
    let availablePowerups = allPowerupTypes;

    if (lastCollectedPowerupType !== null) {
        availablePowerups = allPowerupTypes.filter(type => type !== lastCollectedPowerupType);
    }

    if (availablePowerups.length === 0) {
        availablePowerups = allPowerupTypes;
    }

    return availablePowerups[Math.floor(fnSRnd() * availablePowerups.length)];
}

function fnUPI(){ 
    const cST = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const currentModeForIcons = rVState.activeReplay ? (R_GM_REV_MAP[rVState.activeReplay.gm] || 'classic') : currentGameMode;
    
    if (currentModeForIcons === 'hardcore') {
        if(powerupIconsContainerElem) powerupIconsContainerElem.style.display = 'none';
        return;
    }
    if(powerupIconsContainerElem) powerupIconsContainerElem.style.display = 'flex';

    for (const type in powerupIconElems) {
        const iconElem = powerupIconElems[type];
        if (!iconElem) continue;
        const p = activePowerups[type];
        if (p && p.active) {
            iconElem.classList.add('active');
            if (p.endTime && (p.endTime - cST) <= _PUFTM) {
                iconElem.classList.add('flashing');
            } else {
                iconElem.classList.remove('flashing');
            }
        } else {
            iconElem.classList.remove('active', 'flashing');
        }
    }
}

function fnDPT(text){const tE=document.createElement('div');tE.className='powerup-text-display';tE.textContent=text;const cA=document.getElementById('canvasArea');if(cA)cA.appendChild(tE);setTimeout(()=>{if(tE.parentNode)tE.parentNode.removeChild(tE);},1000);}

function fnSG(clickEvent){
    if (screenStack.length > 0 && screenStack[screenStack.length - 1] !== 'home') {
        screenStack = ['home'];
    } else if (screenStack.length === 0) {
        screenStack = ['home'];
    }

    if(!audioCtx){if(!initAudio()){}}
    if(audioCtx?.state==='suspended'){audioCtx.resume();}
    gameModeActive = true;
    if(rVState.activeReplay) fnStopRP();
    if(gameCanvas)gameCanvas.style.cursor='none';
    for(const k in keysPressed){delete keysPressed[k];}

    gSeed = Math.floor(Math.random() * 0xFFFFFFFF);
    nextBallId = 0;
    fnIPRNG(gSeed);

    lastSavedReplayId = null; 
    cRepData = { 
        seed: gSeed,
        gameMode: currentGameMode,
        cosmetics: { colorWheel: "default", bucket: "default" },
        events: [],
        finalGameScore: 0,
        finalTimeMs: 0,
        gameEndTimestampForHS: 0 
    };
    // console.log("fnSG: NEW cRepData initialized. Game Mode:", cRepData.gameMode, "Seed:", cRepData.seed, "Initial HS Timestamp (0):", cRepData.gameEndTimestampForHS);

    // ***** NEW: Reset saveReplayBtnElem state at the start of a new game *****
    if (saveReplayBtnElem) {
        updateButtonText(saveReplayBtnElem, "Save Replay");
        saveReplayBtnElem.classList.remove('saved');
        // We don't need to specifically remove a "Limit Reached" class if it's just text,
        // as updateButtonText will overwrite it.
    }
    // ***** END NEW *****

    fnSS('game');
    fnRGSR(false); 

    let initialCursorX = gameWidth / 2;
    let initialCursorY = gameHeight / 2;

    if (clickEvent && gameCanvas) {
        const rect = gameCanvas.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            initialCursorX = clickEvent.clientX - rect.left;
            initialCursorY = clickEvent.clientY - rect.top;
            initialCursorX = Math.max(0, Math.min(gameWidth, initialCursorX));
            initialCursorY = Math.max(0, Math.min(gameHeight, initialCursorY));
        }
    }
    playerCursor = { x: initialCursorX, y: initialCursorY, outerRadius: _PCOR, ringThickness: _PCRT };

    fnUPI(); 
    fnUUI(); 

    lastTime=performance.now();
    timePausedStarted=0;
    if(animationFrameId)cancelAnimationFrame(animationFrameId);
    animationFrameId=requestAnimationFrame(fnGL);
    if(mRecIntId) clearInterval(mRecIntId);
    mRecIntId = setInterval(fnRMP, _RMRIM);
}

function fnRGSR(isForReplayOrSim) {
    if (!isForReplayOrSim) {
        score = 0;
        lives = currentGameMode === 'hardcore' ? 1 : 3;
        elapsedGameTimeMs = 0;
        gameRunning = true;
        gamePaused = false;
        gPausedByConf = false;
        if (cRepData) fnRecordScoreLivesUpdate();
        nextBallId = 0;
        lastCollectedPowerupType = null;
    } else {
        rVState.score = 0;
        const replayGameMode = rVState.activeReplay.gameMode;
        rVState.lives = (replayGameMode === 'hardcore' ? 1 : 3);
        nextBallId = 0;
        rVState.isReplayDoublePointsActive = false;
        playerCursor = { x: gameWidth / 2, y: gameHeight / 2, outerRadius: _PCOR, ringThickness: _PCRT };
    }

    balls.length = 0;
    colorWheelParticles.length = 0;
    powerupGlowParticles.length = 0;
    if (newHighScoreTextElem) newHighScoreTextElem.style.display = 'none';
    cBllSS = _OBSS;

    const cM = isForReplayOrSim ? rVState.activeReplay.gameMode : currentGameMode;
    if (powerupIconsContainerElem) { // This line directly sets visibility based on mode
        powerupIconsContainerElem.style.display = (cM === 'hardcore') ? 'none' : 'flex';
    }

    for (const type in activePowerups) {
        activePowerups[type].active = false;
        activePowerups[type].endTime = 0;
        if (type === 'oneColor') activePowerups.oneColor.color = null;
    }
    if (!isForReplayOrSim && cM === 'classic' && cRepData) {
        for (const type in activePowerups) {
             fnRecordPowerupEvent('powerupDeactivate', { powerupType: type });
        }
    }

    cBktWR = _BBWRN;
    fnUBS();

    const createDropper = (isRightMoving, dropperNum) => ({
        id: dropperNum,
        x: gameWidth / 2 - DROPPER_WIDTH_BOTTOM / 2,
        y: 0,
        width: DROPPER_WIDTH_BOTTOM,
        height: DROPPER_HEIGHT,
        topWidth: DROPPER_WIDTH_BOTTOM * DROPPER_TOP_WIDTH_RATIO,
        speed: (gameWidth - DROPPER_WIDTH_BOTTOM) / _IDTPS,
        direction: isRightMoving ? 1 : -1,
        currentDropIntervalMs: _IBDIM,
        timeSinceLastDrop: 0,
        isMaxSpeedOverride: false
    });
    dropper1 = createDropper(true, 1);
    dropper2 = createDropper(false, 2);

    const iBW = gameWidth * cBktWR;
    bucket = {
        baseWidth: iBW, height: BUCKET_HEIGHT, y: gameHeight - BUCKET_HEIGHT - (BUCKET_LINE_WIDTH / 2),
        x: (gameWidth / 2) - (iBW / 2),
        get sideRise() { return this.height; },
        get sideRun() { return this.height / Math.tan(BUCKET_SIDE_ANGLE); },
        get P1() { return { x: this.x - this.sideRun, y: this.y }; },
        get P2() { return { x: this.x, y: this.y + this.height }; },
        get P3() { return { x: this.x + this.baseWidth, y: this.y + this.height }; },
        get P4() { return { x: this.x + this.baseWidth + this.sideRun, y: this.y }; }
    };

    fnIAP();
    fnITP();
    if (aCtx) aCtx.clearRect(0,0,gameWidth,gameHeight);fnDTP(aCtx);

}

function fnEG() {
    gameModeActive = false;
    if (gameCanvas) gameCanvas.style.cursor = 'default';
    for (const k in keysPressed) { delete keysPressed[k]; }
    gameRunning = false; gamePaused = false; gPausedByConf = false;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (mRecIntId) clearInterval(mRecIntId); mRecIntId = null;

    const gameEndTimestampForHS = Date.now();
    let autoSaveAttemptedAndSuccessful = false;
    const MAX_REPLAYS_PER_MODE = 50;

    const currentReplayGameModeForEG = cRepData ? cRepData.gameMode : currentGameMode;
    const gameModeCompactCode = R_GM_MAP[currentReplayGameModeForEG];
    const existingReplaysInMode = sReps.filter(r => r.gm === gameModeCompactCode).length;

    const finalGameTimeStr = fnFT(elapsedGameTimeMs);
    const isNewHighScoreOverall = fnSHS(score, finalGameTimeStr, gameEndTimestampForHS); 

    if (cRepData) {
        cRepData.events.push({ t: parseFloat(elapsedGameTimeMs.toFixed(1)), type: 'gameEnd' });
        cRepData.finalGameScore = score;
        cRepData.finalTimeMs = elapsedGameTimeMs;
        cRepData.gameEndTimestampForHS = gameEndTimestampForHS;

        saveReplayBtnElem.style.display = 'inline-block';

        if (autosaveReplays === 'yes' && score > autosaveThreshold) {
            if (existingReplaysInMode < MAX_REPLAYS_PER_MODE) {
                const currentBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (!currentBtnText.includes("Limit Reached")) {
                    updateButtonText(saveReplayBtnElem, "Save Replay"); 
                    saveReplayBtnElem.classList.remove('saved');     
                }
                fnSCR(); 
                if (saveReplayBtnElem.classList.contains('saved')) {
                    autoSaveAttemptedAndSuccessful = true;
                }
            } else {
                updateButtonText(saveReplayBtnElem, "Limit Reached");
                saveReplayBtnElem.classList.remove('saved');
                fnShowReplayLimitNotification(`${currentReplayGameModeForEG.charAt(0).toUpperCase() + currentReplayGameModeForEG.slice(1)} Replays Full! (${MAX_REPLAYS_PER_MODE}/${MAX_REPLAYS_PER_MODE})`);
            }
        }

        if (!autoSaveAttemptedAndSuccessful) {
            if (existingReplaysInMode >= MAX_REPLAYS_PER_MODE) {
                updateButtonText(saveReplayBtnElem, "Limit Reached");
                saveReplayBtnElem.classList.remove('saved');
            } else {
                 const currentBtnText = saveReplayBtnElem.querySelector('.btn-text') ? saveReplayBtnElem.querySelector('.btn-text').textContent : saveReplayBtnElem.textContent;
                if (!currentBtnText.includes("Limit Reached") && !saveReplayBtnElem.classList.contains('saved')) {
                    updateButtonText(saveReplayBtnElem, "Save Replay");
                    saveReplayBtnElem.classList.remove('saved');
                }
            }
        }
    } else {
        saveReplayBtnElem.style.display = 'none';
    }

    const gOT = document.getElementById('gameOverTitle');
    if (gOT) {
        if (currentGameMode === 'classic') gOT.textContent = "Classic Mode";
        else if (currentGameMode === 'hardcore') gOT.textContent = "Hardcore Mode";
        else gOT.textContent = "Game Over";
    }
    if (finalScoreDisplay) finalScoreDisplay.textContent = score;
    if (finalTimeDisplay) finalTimeDisplay.textContent = finalGameTimeStr;

    if (isNewHighScoreOverall && newHighScoreTextElem) newHighScoreTextElem.style.display = 'block';
    else if (newHighScoreTextElem) newHighScoreTextElem.style.display = 'none';

    fnSS('gameOver');
    fnPS('loseLife');
}

function fnUUI(){ const dSc=rVState.activeReplay?rVState.score:score; const dTm=rVState.activeReplay?rVState.currentTimeMs:elapsedGameTimeMs; const dLv=rVState.activeReplay?rVState.lives:lives; if(scoreDisplay)scoreDisplay.textContent=dSc; if(timeDisplay)timeDisplay.textContent=fnFT(dTm); if(livesDisplay)livesDisplay.textContent='❤'.repeat(Math.max(0,dLv)); if(rVState.activeReplay&&replayTimeDisplayElem){replayTimeDisplayElem.textContent=`${fnFT(rVState.currentTimeMs)} / ${fnFT(rVState.totalDurationMs)}`;} if(rVState.activeReplay&&replaySeekBar){if(rVState.totalDurationMs>0){replaySeekBar.value=(rVState.currentTimeMs/rVState.totalDurationMs)*100;}else{replaySeekBar.value=0;}}}
function fnFT(ms){let s=Math.floor(ms/1000),m=Math.floor(s/60);s%=60;let t=Math.floor((ms%1000)/100);return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${t}`;}

function fnUGP(dTS, currentTimeForLogic) { 
    const effectiveTime = rVState.activeReplay ? currentTimeForLogic : elapsedGameTimeMs;
    if (!rVState.activeReplay) {
        elapsedGameTimeMs += dTS * 1000;
    }
    const p = Math.min(1, effectiveTime / _MST);
    const updateDropperProgression = (dr) => {
        if (!dr) return;
        const currentKeys = rVState.activeReplay ? rVState.keysPressedReplay : keysPressed;
        const maxSpeedActive = currentKeys[keybindMaxSpeed.toLowerCase()];
        dr.isMaxSpeedOverride = maxSpeedActive;
        if (maxSpeedActive) {
            dr.speed = (gameWidth - dr.width) / _FDTP;
            dr.currentDropIntervalMs = _FBDIM;
        } else {
            const dynamicTimePerScreenS = _IDTPS - (_IDTPS - _FDTP) * p;
            dr.speed = (gameWidth - dr.width) / dynamicTimePerScreenS;
            dr.currentDropIntervalMs = _IBDIM - (_IBDIM - _FBDIM) * p;
        }
    };
    updateDropperProgression(dropper1);
    updateDropperProgression(dropper2);
    fnCP(effectiveTime); 
}

function fnUBS(){const tTT=_XBTTS-((_BS-1)/9)*(_XBTTS-_MBTTS);cBktSPS=gameWidth/tTT;}
function fnDarkC(h,p){h=h.replace(/^#/,'');if(h.length===3)h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2];let r=parseInt(h.substring(0,2),16),g=parseInt(h.substring(2,4),16),b=parseInt(h.substring(4,6),16);r=Math.max(0,Math.floor(r*(1-p/100)));g=Math.max(0,Math.floor(g*(1-p/100)));b=Math.max(0,Math.floor(b*(1-p/100)));return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;}
function fnR2H(r,g,b){r/=255,g/=255,b/=255;let x=Math.max(r,g,b),n=Math.min(r,g,b);let h,s,l=(x+n)/2;if(x==n)h=s=0;else{let d=x-n;s=l>0.5?d/(2-x-n):d/(x+n);switch(x){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;}h/=6;}return [h,s,l];}
function fnH2R(h,s,l){let r,g,b;if(s==0)r=g=b=l;else{function q(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}let q2=l<0.5?l*(1+s):l+s-l*s;let p2=2*l-q2;r=q(p2,q2,h+1/3);g=q(p2,q2,h);b=q(p2,q2,h-1/3);}return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];}
function fnRA2Hex(a){return "#"+a.map(c=>{const h=c.toString(16);return h.length==1?"0"+h:h;}).join('');}

function fnUSD(drpr, deltaTimeS, isPrimaryDropper) {
    if (!drpr) return;
    drpr.x += drpr.speed * drpr.direction * deltaTimeS;
    if (drpr.x + drpr.width > gameWidth) { drpr.x = gameWidth - drpr.width; drpr.direction *= -1; }
    if (drpr.x < 0) { drpr.x = 0; drpr.direction *= -1; }
    
    
    const isV3Replay = rVState.activeReplay && rVState.activeReplay.v === REPLAY_FORMAT_VERSION;
    if (isV3Replay) { 
        drpr.timeSinceLastDrop += deltaTimeS * 1000;
        if (drpr.timeSinceLastDrop >= drpr.currentDropIntervalMs) {
            drpr.timeSinceLastDrop = 0; 
        }
        return;
    }
    
    drpr.timeSinceLastDrop += deltaTimeS * 1000;
    const cM = rVState.activeReplay ? rVState.activeReplay.gameMode : currentGameMode; 
    const currentSimTime = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;

    if (drpr.timeSinceLastDrop >= drpr.currentDropIntervalMs) {
        drpr.timeSinceLastDrop = 0;
        
        let ballParams = {}; 
        ballParams.id = nextBallId++; 
        ballParams.dropperId = drpr.id;

        if (cM === 'hardcore') {
            ballParams.isPowerup = false;
            const cRnd = fnSRnd();
            if (cRnd < 0.3333) { ballParams.colorHex = BALL_COLORS[0]; ballParams.colorName = BALL_COLOR_NAMES[0]; }
            else if (cRnd < 0.6666) { ballParams.colorHex = BALL_COLORS[1]; ballParams.colorName = BALL_COLOR_NAMES[1]; }
            else { ballParams.colorHex = BALL_COLORS[2]; ballParams.colorName = BALL_COLOR_NAMES[2]; }
        } else { 
            let bTRnd = fnSRnd();
            if (isPrimaryDropper) {
                if (bTRnd < 0.025) { ballParams.isPowerup = true; ballParams.colorHex = POWERUP_BALL_COLOR_HEX; ballParams.colorName = 'powerup'; }
                else {
                    ballParams.isPowerup = false; 
                    if (activePowerups.oneColor.active && activePowerups.oneColor.color) {
                        ballParams.colorName = activePowerups.oneColor.color; ballParams.colorHex = BALL_COLORS[BALL_COLOR_NAMES.indexOf(ballParams.colorName)];
                    } else {
                        let cRnd = fnSRnd();
                        if (cRnd < 0.33) { ballParams.colorHex = BALL_COLORS[0]; ballParams.colorName = BALL_COLOR_NAMES[0]; }
                        else if (cRnd < 0.66) { ballParams.colorHex = BALL_COLORS[1]; ballParams.colorName = BALL_COLOR_NAMES[1]; }
                        else { ballParams.colorHex = BALL_COLORS[2]; ballParams.colorName = BALL_COLOR_NAMES[2]; }
                    }
                }
            } else { 
                if (bTRnd < 0.025) { ballParams.isPowerup = true; ballParams.colorHex = POWERUP_BALL_COLOR_HEX; ballParams.colorName = 'powerup'; }
                else { ballParams.isPowerup = false; ballParams.colorHex = WHITE_BALL_COLOR_HEX; ballParams.colorName = 'white'; }
            }
        }
        ballParams.fallSpeedFactor = _MBFTS + fnSRnd() * (_XBFTS - _MBFTS);
        ballParams.sizeMultiplier = _MINBSM + fnSRnd() * (_MAXBSM - _MINBSM);
        ballParams.swayTime = fnSRnd() * Math.PI * 2;
        ballParams.vx_sway_direction = (fnSRnd() < 0.5 ? -1 : 1);

        if (!rVState.activeReplay) { 
            fnRecordBallSpawnEvent(ballParams); 
        }
        
        const newBall = {
            id: ballParams.id,
            x: drpr.x + drpr.width / 2,
            y: drpr.y + drpr.height,
            radius: BALL_RADIUS_BASE * ballParams.sizeMultiplier,
            colorHex: ballParams.colorHex,
            colorName: ballParams.colorName,
            originalVy: gameHeight / ballParams.fallSpeedFactor,
            isPowerup: ballParams.isPowerup,
            swayOffset: 0,
            swayTime: ballParams.swayTime,
            vx_sway_direction: ballParams.vx_sway_direction,
            spawnTimeMs: currentSimTime 
        };
        newBall.vy = (cM === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
        balls.push(newBall);

        if (!rVState.activeReplay) fnPS('drop');
    }
}


function fnDSD(ctx,drpr){if(drpr){ctx.fillStyle=DROPPER_COLOR;ctx.beginPath();const tO=(drpr.width-drpr.topWidth)/2;ctx.moveTo(drpr.x+tO,drpr.y);ctx.lineTo(drpr.x+drpr.width-tO,drpr.y);ctx.lineTo(drpr.x+drpr.width,drpr.y+drpr.height);ctx.lineTo(drpr.x,drpr.y+drpr.height);ctx.closePath();ctx.fill();}}
function fnLCC(p1,p2,cC,r){let d={x:p2.x-p1.x,y:p2.y-p1.y};let pTC={x:cC.x-p1.x,y:cC.y-p1.y};let t=(pTC.x*d.x+pTC.y*d.y)/(d.x*d.x+d.y*d.y);t=Math.max(0,Math.min(1,t));let cP={x:p1.x+d.x*t,y:p1.y+d.y*t};let dSq=(cC.x-cP.x)**2+(cC.y-cP.y)**2;return dSq<=r**2;}

function fnUB(dTS) { 
    const currentSimTime = rVState.activeReplay ? rVState.currentTimeMs : elapsedGameTimeMs;
    const cM = rVState.activeReplay ? rVState.activeReplay.gameMode : currentGameMode;
    const isV3Replay = rVState.activeReplay && rVState.activeReplay.v === REPLAY_FORMAT_VERSION;


    for (let i = balls.length - 1; i >= 0; i--) {
        const b = balls[i];
        b.y += b.vy * dTS;
        b.swayTime += cBllSS * dTS * b.vx_sway_direction;
        b.swayOffset = Math.sin(b.swayTime) * gameWidth * _BSAR;
        let dX = b.x + b.swayOffset;

        if (b.colorName === 'white' && cM === 'classic' && activePowerups.whiteBallMagnet.active && playerCursor) {
            const mTX = playerCursor.x, mTY = playerCursor.y;
            let dTCX = mTX - dX, dTCY = mTY - b.y;
            let distTC = Math.sqrt(dTCX * dTCX + dTCY * dTCY);
            if (distTC > 1) {
                let pS = (_MBPP + _MPI / (distTC + 10)) * dTS;
                pS = Math.min(pS, distTC);
                let pXC = (dTCX / distTC) * pS, pYC = (dTCY / distTC) * pS;
                b.x += pXC; b.y += pYC; dX = b.x + b.swayOffset;
            }
        }

        if (dX - b.radius < 0) { dX = b.radius; b.x = dX - b.swayOffset; b.vx_sway_direction *= -1; if (gameWidth * _BSAR !== 0) b.swayTime = Math.asin(Math.max(-1, Math.min(1, (dX - b.x) / (gameWidth * _BSAR)))); }
        else if (dX + b.radius > gameWidth) { dX = gameWidth - b.radius; b.x = dX - b.swayOffset; b.vx_sway_direction *= -1; if (gameWidth * _BSAR !== 0) b.swayTime = Math.asin(Math.max(-1, Math.min(1, (dX - b.x) / (gameWidth * _BSAR))));}

        if (b.isPowerup && cM === 'classic') fnAPGP(dX, b.y); 

        if (playerCursor) {
            const dCX = dX - playerCursor.x, dCY = b.y - playerCursor.y;
            const distC = Math.sqrt(dCX * dCX + dCY * dCY);
            
            if (distC < b.radius + _PCOR) { 
                if (b.isPowerup) {
                    if (!rVState.activeReplay) { 
                        let powerupTypeDetermined = fnGRPUT(); 
                        fnAPU(powerupTypeDetermined, false, { collectedBallId: b.id }); 
                        fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedPowerupWheel'); 
                        balls.splice(i, 1); continue;
                    } else if (!isV3Replay) { 
                        balls.splice(i,1); 
                        continue; 
                    } 
                }
                
                let pointsMultiplier = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive)) ) ? 2 : 1;
                let soundToPlay = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive))) ? 'collectGoodDouble' : 'collectGood';

                if (b.colorName === 'white') {
                    if (!rVState.activeReplay) { score += 3 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS(soundToPlay); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelWhite');}
                    if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
                    continue;
                }

                const ang = (Math.atan2(dCY, dCX) + 2 * Math.PI) % (2 * Math.PI);
                let segmentHit = null;
                function isAngleInSegment(targetAngle, segmentStart, segmentEnd) { return segmentStart < segmentEnd ? (targetAngle >= segmentStart && targetAngle < segmentEnd) : (targetAngle >= segmentStart || targetAngle < segmentEnd); }
                if (isAngleInSegment(ang, _PCSA.green.start, _PCSA.green.end)) segmentHit = 'green';
                else if (isAngleInSegment(ang, _PCSA.red.start, _PCSA.red.end)) segmentHit = 'red';
                else if (isAngleInSegment(ang, _PCSA.blue.start, _PCSA.blue.end)) segmentHit = 'blue';

                if (segmentHit) {
                    if (!rVState.activeReplay) { 
                        if (segmentHit === b.colorName) { score += 3 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS(soundToPlay); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelCorrect');}
                        else { lives--; fnRecordScoreLivesUpdate(); fnPS('loseLife'); fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedWheelWrong');}
                    }
                    if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
                    continue;
                }
            }
        }

        if (bucket && (fnLCC(bucket.P1, bucket.P2, { x: dX, y: b.y }, b.radius) ||
                       fnLCC(bucket.P2, bucket.P3, { x: dX, y: b.y }, b.radius) ||
                       fnLCC(bucket.P3, bucket.P4, { x: dX, y: b.y }, b.radius))) {
            if (b.isPowerup) {
                if (!rVState.activeReplay) {
                    let powerupTypeDetermined = fnGRPUT();
                    fnAPU(powerupTypeDetermined, false, { collectedBallId: b.id });
                    fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedPowerupBucket');
                }
            } else {
                if (!rVState.activeReplay) {
                    let pointsMultiplier = (cM === 'classic' && (activePowerups.doublePoints.active || (rVState.activeReplay && rVState.isReplayDoublePointsActive)) ) ? 2 : 1;
                    score += 1 * pointsMultiplier; fnRecordScoreLivesUpdate(); fnPS('collectBucket');
                    fnRecordBallDespawnEvent(b.id, currentSimTime, 'collectedBucket');
                }
            }
            if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
            continue;
        }

        if (b.y - b.radius > gameHeight) { 
            if (!rVState.activeReplay) {
                let reason = 'missedOffScreen';
                if (cM === 'hardcore' || (!b.isPowerup && b.colorName !== 'white')) {
                    lives--; fnRecordScoreLivesUpdate(); fnPS('loseLife');
                    reason = 'missedOffScreen_LifeLoss';
                }
                fnRecordBallDespawnEvent(b.id, currentSimTime, reason);
            }
            if (!rVState.activeReplay || !isV3Replay) balls.splice(i, 1); 
            continue;
        }
    }
}


function fnDB(ctx){
    const whiteBallsToDraw = [];
    const powerupBallsToDraw = [];
    const rgbBallsToDraw = [];

    balls.forEach(b => {
        if (b.isPowerup) {
            powerupBallsToDraw.push(b);
        } else if (b.colorName === 'white') {
            whiteBallsToDraw.push(b);
        } else {
            rgbBallsToDraw.push(b);
        }
    });

    const drawBallType = (ballArray) => {
        ballArray.forEach(b => {
            const dX=b.x+b.swayOffset,bY=b.y,lCX=dX-b.radius*0.30,lCY=bY-b.radius*0.30,bHC=b.colorHex,gSM=1.9,aGOR=b.radius*gSM;
            const gGC=ctx.createRadialGradient(dX,bY,b.radius,dX,bY,aGOR);
            let rGS=parseInt(bHC.slice(1,3),16),gGS=parseInt(bHC.slice(3,5),16),bGS=parseInt(bHC.slice(5,7),16);
            const gOAS=0.3;
            gGC.addColorStop(0,`rgba(${rGS},${gGS},${bGS},${gOAS})`);
            gGC.addColorStop(1,`rgba(${rGS},${gGS},${bGS},0)`);
            ctx.fillStyle=gGC;
            ctx.beginPath();
            ctx.arc(dX,bY,aGOR,0,Math.PI*2);
            ctx.fill();
            const bG=ctx.createRadialGradient(lCX,lCY,b.radius*0.00,dX,bY,b.radius*2.0);
            if(b.colorName==='white'){
                bG.addColorStop(0,'#FFFFFF');
                bG.addColorStop(0.25,'#FAFAFA');
                bG.addColorStop(0.5,'#F0F0F0');
                bG.addColorStop(0.75,'#E0E0E0');
                bG.addColorStop(1,'#D0D0D0');
            }else{
                let rB=parseInt(bHC.slice(1,3),16),gB=parseInt(bHC.slice(3,5),16),bB=parseInt(bHC.slice(5,7),16);
                let [h,s,l]=fnR2H(rB,gB,bB);
                const lIF=0.20;
                let lA=Math.min(1,l+lIF);
                lA=Math.max(0,lA);
                let [rM,gM,bM]=fnH2R(h,s,lA);
                const mCIG=fnRA2Hex([rM,gM,bM]);
                const hC='#FFFFFF';
                const sC=fnDarkC(mCIG,40);
                bG.addColorStop(0,hC);
                bG.addColorStop(0.4,mCIG);
                bG.addColorStop(0.8,mCIG);
                bG.addColorStop(1,sC);
            }
            ctx.fillStyle=bG;
            ctx.beginPath();
            ctx.arc(dX,bY,b.radius,0,Math.PI*2);
            ctx.fill();
        });
    };

    drawBallType(whiteBallsToDraw);
    drawBallType(powerupBallsToDraw);
    drawBallType(rgbBallsToDraw);
}
function fnUBkt(dTS){ if(!bucket)return; const cK=rVState.activeReplay?rVState.keysPressedReplay:keysPressed; if(cK[keybindLeft]){bucket.x-=cBktSPS*dTS;} if(cK[keybindRight]){bucket.x+=cBktSPS*dTS;} if(bucket.x+bucket.baseWidth+bucket.sideRun<0){bucket.x=gameWidth+bucket.sideRun;} else if(bucket.x-bucket.sideRun>gameWidth){bucket.x=-bucket.baseWidth-bucket.sideRun;}}
function fnDBkt(ctx){if(!bucket)return;ctx.strokeStyle=BUCKET_COLOR;ctx.lineWidth=BUCKET_LINE_WIDTH;ctx.lineCap='round';ctx.beginPath();ctx.moveTo(bucket.P1.x,bucket.P1.y);ctx.lineTo(bucket.P2.x,bucket.P2.y);ctx.stroke();ctx.beginPath();ctx.moveTo(bucket.P4.x,bucket.P4.y);ctx.lineTo(bucket.P3.x,bucket.P3.y);ctx.stroke();ctx.lineCap='butt';ctx.beginPath();ctx.moveTo(bucket.P2.x,bucket.P2.y);ctx.lineTo(bucket.P3.x,bucket.P3.y);ctx.stroke();}

function fnDPC(ctx){ // ctx is gameCtx
    if(!playerCursor)return;

    const dprMultiplier = QUALITY_SETTINGS_MAP[currentQualitySetting];
    const cOR = _PCOR; // Logical outer radius

    const tempCanvas = document.createElement('canvas');
    // Ensure integer dimensions for the temporary canvas
    tempCanvas.width = Math.ceil(cOR * 2 * dprMultiplier);
    tempCanvas.height = Math.ceil(cOR * 2 * dprMultiplier);
    const tempCtx = tempCanvas.getContext('2d');

    // Scale first, then translate by logical center
    tempCtx.scale(dprMultiplier, dprMultiplier);
    tempCtx.translate(cOR, cOR); // (0,0) in drawing now refers to logical center

    const cBB=0.45,eDF=0.15,gTS=0.65,gTE=0.65; // Styling constants for dS

    // dS takes target context, logical centerX, logical centerY, logical outerRadius
    const dS = (targetCtx, currentCX, currentCY, currentOR, bHC, sK) => {
        const sA=_PCSA[sK],bSA=sA.start,bEA=sA.end;
        let rB=parseInt(bHC.slice(1,3),16),gB=parseInt(bHC.slice(3,5),16),bB=parseInt(bHC.slice(5,7),16);
        let [h,s,lO]=fnR2H(rB,gB,bB);
        let lBr=Math.min(1,lO+cBB);
        lBr=Math.max(0,lBr);
        const bSC=fnRA2Hex(fnH2R(h,s,lBr));
        const lIF=0.20;
        let lN=Math.min(1,lO+lIF);
        lN=Math.max(0,lN);
        const nSC=fnRA2Hex(fnH2R(h,s,lN));
        let lDa=Math.min(1,lO-eDF);
        lDa=Math.max(0,lDa);
        const dSC=fnRA2Hex(fnH2R(h,s,lDa));
        const grad=targetCtx.createRadialGradient(currentCX,currentCY,0,currentCX,currentCY,currentOR);
        grad.addColorStop(0,bSC);
        grad.addColorStop(gTS,nSC);
        grad.addColorStop(gTE,nSC);
        grad.addColorStop(1,dSC);
        targetCtx.beginPath();
        targetCtx.moveTo(currentCX, currentCY);
        targetCtx.arc(currentCX, currentCY, currentOR, bSA, bEA, false);
        // Removed targetCtx.lineTo(currentCX, currentCY); as closePath() handles this.
        targetCtx.closePath(); 
        targetCtx.fillStyle=grad;
        targetCtx.fill();
    };

    // Draw segments onto tempCtx, centered at logical (0,0) with logical radius cOR
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[0],'red');
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[2],'blue');
    dS(tempCtx, 0, 0, cOR, PLAYER_CURSOR_OUTLINE_COLORS[1],'green');

    // Draw separators onto tempCtx
    const sepA=[_PCSA.red.start,_PCSA.blue.start,_PCSA.green.start];
    let logicalLineWidth = Math.max(1, cOR / 4.0); // Logical line width
    tempCtx.lineWidth = logicalLineWidth; // Set line width in logical units
    tempCtx.strokeStyle='rgba(0,0,0,1)';
    tempCtx.globalCompositeOperation='destination-out';
    tempCtx.lineCap='butt';
    sepA.forEach(a=>{
        tempCtx.beginPath();
        tempCtx.moveTo(0,0); // Logical center
        // Extend line slightly (0.5 logical pixel for a clean cutout)
        const lL= cOR + tempCtx.lineWidth / 2 + 0.5; 
        tempCtx.lineTo(0 + lL*Math.cos(a), 0 + lL*Math.sin(a));
        tempCtx.stroke();
    });
    tempCtx.globalCompositeOperation='source-over'; // Reset composite operation

    // Draw the temporary canvas onto the main game canvas (ctx)
    // Position using playerCursor's logical coordinates, draw with logical dimensions
    const smoothingEnabled = ctx.imageSmoothingEnabled; // Store current state
    ctx.imageSmoothingEnabled = false;
    // ctx.mozImageSmoothingEnabled = false; // Firefox
    // ctx.webkitImageSmoothingEnabled = false; // Chrome/Safari
    // ctx.msImageSmoothingEnabled = false; // IE/Edge

    ctx.drawImage(tempCanvas, playerCursor.x - cOR, playerCursor.y - cOR, cOR * 2, cOR * 2);

    ctx.imageSmoothingEnabled = smoothingEnabled; // Restore original state
    // ctx.mozImageSmoothingEnabled = smoothingEnabled;
    // ctx.webkitImageSmoothingEnabled = smoothingEnabled;
    // ctx.msImageSmoothingEnabled = smoothingEnabled;
}
function fnGL(timestamp){
    if(!gameRunning||!gameModeActive)return;
    if(gamePaused){animationFrameId=requestAnimationFrame(fnGL);return;}
    const dTS=(timestamp-lastTime)/1000;
    lastTime=timestamp;

    fnUGP(dTS, elapsedGameTimeMs);
    if(dropper1)fnUSD(dropper1,dTS,true);
    if(dropper2)fnUSD(dropper2,dTS,false);
    if(bucket)fnUBkt(dTS);
    fnUB(dTS);

    if (playerCursor) {
        fnACWP(playerCursor.x, playerCursor.y);
    }
    fnUCWP(dTS);

    if(currentGameMode==='classic'){fnUPGP(dTS);fnUPI();}
    fnUAP(dTS);

    gameCtx.clearRect(0,0,gameWidth,gameHeight);
    fnDAP(gameCtx);
    // Draw Bucket first (it's generally behind balls and droppers)
    if(bucket)fnDBkt(gameCtx,bucket);

    // Draw Player Cursor and its particles (often central, can be under balls or over, depends on preference - let's keep it before balls for now)
    fnDCWP(gameCtx);
    if(playerCursor)fnDPC(gameCtx);

    // Draw Balls NEXT
    fnDB(gameCtx);

    // Draw Droppers AFTER Balls
    if(dropper1)fnDSD(gameCtx,dropper1);
    if(dropper2)fnDSD(gameCtx,dropper2);

    // Draw Power-up Glow Particles last (they should be on top of balls)
    if(currentGameMode==='classic'){fnDPGP(gameCtx);}
    fnUUI();
    if(lives<=0){fnEG();return;}
    animationFrameId=requestAnimationFrame(fnGL);
}

function fnSRP(replayDataToPlay, isFromImport = false) { 
    if (!replayDataToPlay) return;

    let verboseReplay;
    if (isFromImport || replayDataToPlay.v === REPLAY_FORMAT_VERSION) { 
        verboseReplay = fnDecodeReplayData(replayDataToPlay);
        if (!verboseReplay) {
            console.error("Failed to decode replay for playback.");
            fnSS('home'); 
            return;
        }
    } else { 
        verboseReplay = replayDataToPlay;
    }
    
    fnSS('replayViewer');
    rVState.activeReplay = verboseReplay; 
    rVState.isPlaying = false; 
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    rVState.currentTimeMs = 0;
    rVState.totalDurationMs = verboseReplay.events[verboseReplay.events.length - 1]?.t || 0;
    if (rVState.totalDurationMs === 0 && verboseReplay.finalTimeMs) { 
        rVState.totalDurationMs = verboseReplay.finalTimeMs;
    }
    rVState.keysPressedReplay = {};
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null; 
    
    fnAREUTT(0, true); 

    fnSetReplayButtonIcon(false);
    replaySeekBar.max = 100;
    replaySeekBar.value = 0;
    
    redrawStaticFrame(); 
    fnURUI(); 
    fnUPI(); 
}

function fnStopRP() { 
    if(rAnimId)cancelAnimationFrame(rAnimId); rAnimId=null; 
    rVState.activeReplay=null; rVState.isPlaying=false; 
    rVState.isSeeking = false;
    rVState.wasPlayingBeforeSeek = false;
    uiOverlayElem.classList.remove('replay-mode'); 
    powerupIconsContainerElem.classList.remove('replay-mode'); 
    replayControlsContainerElem.style.display='none'; 
    fnSetReplayButtonIcon(false);
    gameModeActive=false;
    if(mRecIntId) clearInterval(mRecIntId); mRecIntId = null;
    balls.length = 0; 
    for (const type in activePowerups) {
        activePowerups[type].active = false;
        activePowerups[type].endTime = 0;
        if (type === 'oneColor') activePowerups.oneColor.color = null;
    }
    cBktWR = _BBWRN; 
    cBllSS = _OBSS; 
    rVState.isReplayDoublePointsActive = false;
    fnUPI(); 
}

function fnAREUTT(targetTimeMs, fullReset = false) {
    if (!rVState.activeReplay) return;

    const allowSoundAtReplayEndCondition = rVState.activeReplay && !rVState.isPlaying && !rVState.isSeeking && (targetTimeMs >= rVState.totalDurationMs);

    if (fullReset) {
        fnIPRNG(rVState.activeReplay.gameSeed);
        fnRGSR(true);

        rVState.nextEventIndex = 0;
        rVState.lastProcessedMouseTime = -1; // Used to ensure we don't go "backwards" on mouse events during a single scan

        const firstMouseEvent = rVState.activeReplay.events.find(e => e.type === 'mouse');
        const initialMouseX = firstMouseEvent ? firstMouseEvent.x : (playerCursor?.x || gameWidth / 2);
        const initialMouseY = firstMouseEvent ? firstMouseEvent.y : (playerCursor?.y || gameHeight / 2);

        rVState.prevReplayMouse = { x: initialMouseX, y: initialMouseY, t: 0 };
        // Find the first actual mouse event for nextReplayMouse, or copy prev if none early
        let foundNextMouse = false;
        for (let i = 0; i < rVState.activeReplay.events.length; i++) {
            if (rVState.activeReplay.events[i].type === 'mouse') {
                rVState.nextReplayMouse = { ...rVState.activeReplay.events[i] }; // Spread to avoid modifying original event
                foundNextMouse = true;
                break;
            }
        }
        if (!foundNextMouse) {
            rVState.nextReplayMouse = { ...rVState.prevReplayMouse };
        }


        rVState.keysPressedReplay = {};
        rVState.isReplayDoublePointsActive = false;

        let simulatedTimeMs = 0;
        let currentReplayEventStreamIndex = 0;

        while (simulatedTimeMs < targetTimeMs) {
            const deltaTimeMs = Math.min(REPLAY_SIM_STEP_MS, targetTimeMs - simulatedTimeMs);
            const deltaTimeS = deltaTimeMs / 1000;
            const nextSimulatedTimeMs = simulatedTimeMs + deltaTimeMs;

            rVState.currentTimeMs = simulatedTimeMs;

            for (let i = currentReplayEventStreamIndex; i < rVState.activeReplay.events.length; i++) {
                const event = rVState.activeReplay.events[i];
                if (event.t >= nextSimulatedTimeMs) {
                    currentReplayEventStreamIndex = i;
                    break;
                }
                if (event.t >= simulatedTimeMs) {
                    if (event.type === 'mouse') {
                        if (event.t >= rVState.lastProcessedMouseTime ) {
                             rVState.prevReplayMouse = { x: event.x, y: event.y, t: event.t };
                             rVState.lastProcessedMouseTime = event.t;
                             // Find the next mouse event for nextReplayMouse
                             rVState.nextReplayMouse = { ...rVState.prevReplayMouse }; // Default to current if no more
                             for (let j = i + 1; j < rVState.activeReplay.events.length; j++) {
                                 if (rVState.activeReplay.events[j].type === 'mouse') {
                                     rVState.nextReplayMouse = { ...rVState.activeReplay.events[j] };
                                     break;
                                 }
                             }
                        }
                    } else if (event.type === 'keydown') {
                        rVState.keysPressedReplay[event.key] = true;
                    } else if (event.type === 'keyup') {
                        rVState.keysPressedReplay[event.key] = false;
                    } else if (event.type === 'scoreLivesUpdate') {
                        if (event.lives < rVState.lives) {
                            let prevEvent = rVState.activeReplay.events[i-1];
                            let alreadyPlayedSoundForDespawn = false;
                            if (prevEvent && prevEvent.type === 'ballDespawn' && Math.abs(prevEvent.t - event.t) < REPLAY_SIM_STEP_MS*2) {
                                if (prevEvent.reason === 'collectedWheelWrong' || prevEvent.reason === 'missedOffScreen_LifeLoss') {
                                    alreadyPlayedSoundForDespawn = true;
                                }
                            }
                            if (!alreadyPlayedSoundForDespawn) {
                                if (rVState.isPlaying || rVState.isSeeking || (allowSoundAtReplayEndCondition && event.lives < rVState.lives)) {
                                    fnPS('loseLife');
                                }
                            }
                        }
                        rVState.score = event.score;
                        rVState.lives = event.lives;
                    } else if (event.type === 'powerupActivate') {
                        const typesFromGRPUT = ['slowFall', 'wideBucket', 'oneColor', 'doublePoints', 'extraLives', 'whiteBallMagnet'];
                        if (typesFromGRPUT.includes(event.powerupType)) fnSRnd();
                        if (event.powerupType === 'oneColor') fnSRnd();
                        fnAPU(event.powerupType, true, event);
                    } else if (event.type === 'powerupDeactivate') {
                        if(activePowerups[event.powerupType]) {
                            activePowerups[event.powerupType].active = false;
                            if (event.powerupType === 'wideBucket') { cBktWR = _BBWRN; if(bucket) bucket.baseWidth = gameWidth * cBktWR; }
                            if (event.powerupType === 'slowFall') {
                                balls.forEach(b => { if(b.originalVy) b.vy = b.originalVy; });
                                cBllSS = _OBSS;
                            }
                            if (event.powerupType === 'oneColor') { activePowerups.oneColor.color = null; }
                            if (event.powerupType === 'doublePoints') rVState.isReplayDoublePointsActive = false;
                        }
                    } else if (event.type === 'ballSpawn' && rVState.activeReplay.v >= 2) {
                        if (rVState.isPlaying || rVState.isSeeking) fnPS('drop');
                        const mode = rVState.activeReplay.gameMode;
                        const isPrimary = (event.dropperId === dropper1.id);

                        if (mode === 'hardcore') { fnSRnd(); }
                        else { fnSRnd();
                            if (isPrimary && event.isPowerup === false && (!activePowerups.oneColor.active || !activePowerups.oneColor.color)) {
                               fnSRnd();
                            }
                        }
                        fnSRnd(); fnSRnd(); fnSRnd(); fnSRnd();

                        const spawningDropper = event.dropperId === dropper1.id ? dropper1 : dropper2;
                        if (!spawningDropper) continue;

                        const newBall = {
                            id: event.id,
                            x: spawningDropper.x + spawningDropper.width / 2,
                            y: spawningDropper.y + spawningDropper.height,
                            radius: BALL_RADIUS_BASE * event.sizeMultiplier,
                            colorHex: event.colorHex,
                            colorName: event.colorName,
                            originalVy: gameHeight / event.fallSpeedFactor,
                            isPowerup: event.isPowerup,
                            swayOffset: 0,
                            swayTime: event.swayTime,
                            vx_sway_direction: event.vx_sway_direction,
                            spawnTimeMs: event.t
                        };
                        newBall.vy = (mode === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
                        balls.push(newBall);

                    } else if (event.type === 'ballDespawn' && rVState.activeReplay.v >= 2) {
                        const ballIndex = balls.findIndex(b => b.id === event.ballId);
                        if (ballIndex !== -1) {
                            balls.splice(ballIndex, 1);
                            if (rVState.isPlaying || rVState.isSeeking || allowSoundAtReplayEndCondition) {
                                switch(event.reason) {
                                    case 'collectedWheelCorrect': case 'collectedWheelWhite': fnPS(rVState.isReplayDoublePointsActive ? 'collectGoodDouble' : 'collectGood'); break;
                                    case 'collectedBucket': fnPS('collectBucket'); break;
                                    case 'collectedPowerupWheel': case 'collectedPowerupBucket': fnPS('powerupCollect'); break;
                                    case 'collectedWheelWrong': fnPS('loseLife'); break;
                                    case 'missedOffScreen_LifeLoss': fnPS('loseLife'); break;
                                }
                            }
                        }
                    }
                }
                if (i === rVState.activeReplay.events.length - 1) currentReplayEventStreamIndex = i + 1;
            }
            rVState.nextEventIndex = currentReplayEventStreamIndex;

            fnIMFR();

            fnUGP(deltaTimeS, simulatedTimeMs);
            if (dropper1) fnUSD(dropper1, deltaTimeS, true);
            if (dropper2) fnUSD(dropper2, deltaTimeS, false);
            if (bucket) fnUBkt(deltaTimeS);
            fnUB(deltaTimeS);

            if (playerCursor) { fnACWP(playerCursor.x, playerCursor.y); }
            fnUCWP(deltaTimeS);
            if (rVState.activeReplay.gameMode === 'classic') { fnUPGP(deltaTimeS); }
            fnUAP(deltaTimeS);
            fnUPI();

            simulatedTimeMs = nextSimulatedTimeMs;
        }
        rVState.currentTimeMs = targetTimeMs;
        fnIMFR();
        fnUPI();

    } else { // Not a full reset, just advancing time
        for (let i = rVState.nextEventIndex; i < rVState.activeReplay.events.length; i++) {
            const event = rVState.activeReplay.events[i];
            if (event.t > targetTimeMs) {
                rVState.nextEventIndex = i; break;
            }
            if (event.type === 'mouse') {
                // When advancing, the previous mouse event becomes the one we just passed
                rVState.prevReplayMouse = { x: event.x, y: event.y, t: event.t };
                // And we look for the next one
                rVState.nextReplayMouse = { ...rVState.prevReplayMouse }; // Default to current if no more
                for (let j = i + 1; j < rVState.activeReplay.events.length; j++) {
                    if (rVState.activeReplay.events[j].type === 'mouse') {
                        rVState.nextReplayMouse = { ...rVState.activeReplay.events[j] };
                        break;
                    }
                }
                rVState.lastProcessedMouseTime = event.t; // Not strictly needed here but good for consistency
            }
            else if (event.type === 'keydown') rVState.keysPressedReplay[event.key] = true;
            else if (event.type === 'keyup') rVState.keysPressedReplay[event.key] = false;
            else if (event.type === 'scoreLivesUpdate') {
                if (event.lives < rVState.lives) {
                    let prevEvent = rVState.activeReplay.events[i-1];
                    let alreadyPlayedSoundForDespawn = false;
                     if (prevEvent && prevEvent.type === 'ballDespawn' && Math.abs(prevEvent.t - event.t) < REPLAY_SIM_STEP_MS*2) {
                        if (prevEvent.reason === 'collectedWheelWrong' || prevEvent.reason === 'missedOffScreen_LifeLoss') {
                            alreadyPlayedSoundForDespawn = true;
                        }
                    }
                    if (!alreadyPlayedSoundForDespawn) {
                        if (rVState.isPlaying || rVState.isSeeking || (allowSoundAtReplayEndCondition && event.lives < rVState.lives)) {
                            fnPS('loseLife');
                        }
                    }
                }
                rVState.score = event.score; rVState.lives = event.lives;
            }
            else if (event.type === 'powerupActivate') {
                const typesFromGRPUT = ['slowFall','wideBucket','oneColor','doublePoints','extraLives','whiteBallMagnet'];
                if(typesFromGRPUT.includes(event.powerupType)) fnSRnd();
                if(event.powerupType === 'oneColor') fnSRnd();
                fnAPU(event.powerupType, true, event);
            } else if (event.type === 'powerupDeactivate') {
                 if(activePowerups[event.powerupType]) {
                    activePowerups[event.powerupType].active = false;
                    if (event.powerupType === 'wideBucket') { cBktWR = _BBWRN; if(bucket) bucket.baseWidth = gameWidth * cBktWR; }
                    if (event.powerupType === 'slowFall') { balls.forEach(b => { if(b.originalVy) b.vy = b.originalVy; }); cBllSS = _OBSS; }
                    if (event.powerupType === 'oneColor') { activePowerups.oneColor.color = null; }
                    if (event.powerupType === 'doublePoints') rVState.isReplayDoublePointsActive = false;
                }
            } else if (event.type === 'ballSpawn' && rVState.activeReplay.v >=2) {
                if (rVState.isPlaying || rVState.isSeeking) fnPS('drop');
                const mode = rVState.activeReplay.gameMode;
                const isPrimary = (event.dropperId === dropper1.id);
                if (mode === 'hardcore') { fnSRnd(); }
                else { fnSRnd();
                    if (isPrimary && event.isPowerup === false && (!activePowerups.oneColor.active || !activePowerups.oneColor.color)) {
                        fnSRnd();
                    }
                }
                fnSRnd(); fnSRnd(); fnSRnd(); fnSRnd();

                const spawningDropper = event.dropperId === dropper1.id ? dropper1 : dropper2;
                if (!spawningDropper) continue;

                const newBall = { id: event.id, x: spawningDropper.x + spawningDropper.width / 2, y: spawningDropper.y + spawningDropper.height, radius: BALL_RADIUS_BASE * event.sizeMultiplier, colorHex: event.colorHex, colorName: event.colorName, originalVy: gameHeight / event.fallSpeedFactor, isPowerup: event.isPowerup, swayOffset: 0, swayTime: event.swayTime, vx_sway_direction: event.vx_sway_direction, spawnTimeMs: event.t };
                newBall.vy = (mode === 'classic' && activePowerups.slowFall.active) ? newBall.originalVy * _SFSM : newBall.originalVy;
                balls.push(newBall);
            } else if (event.type === 'ballDespawn' && rVState.activeReplay.v >= 2) {
                const ballIndex = balls.findIndex(b => b.id === event.ballId);
                if (ballIndex !== -1) {
                     balls.splice(ballIndex, 1);
                    if (rVState.isPlaying || rVState.isSeeking || allowSoundAtReplayEndCondition) {
                        switch(event.reason) {
                            case 'collectedWheelCorrect': case 'collectedWheelWhite': fnPS(rVState.isReplayDoublePointsActive ? 'collectGoodDouble' : 'collectGood'); break;
                            case 'collectedBucket': fnPS('collectBucket'); break;
                            case 'collectedPowerupWheel': case 'collectedPowerupBucket': fnPS('powerupCollect'); break;
                            case 'collectedWheelWrong': fnPS('loseLife'); break;
                            case 'missedOffScreen_LifeLoss': fnPS('loseLife'); break;
                        }
                    }
                }
            }
            if (i === rVState.activeReplay.events.length - 1) { rVState.nextEventIndex = i + 1; }
        }
    }
    fnIMFR(); // Call after processing events to update cursor based on new prev/next mouse states
}


function fnIMFR() {
    if (!rVState.activeReplay || !playerCursor) return;

    const cT = rVState.currentTimeMs;
    const p = rVState.prevReplayMouse; 
    const n = rVState.nextReplayMouse; 

    if (!p || !n) { 
        if (playerCursor && gameWidth && gameHeight) {
            playerCursor.x = gameWidth / 2;
            playerCursor.y = gameHeight / 2;
        }
        return;
    }

    let rawX, rawY;

    if (cT <= p.t) {
        rawX = p.x;
        rawY = p.y;
    } else if (cT >= n.t) {
        rawX = n.x;
        rawY = n.y;
    } else {
        const timeDiff = n.t - p.t;
        if (timeDiff <= 0) { 
            rawX = p.x;
            rawY = p.y;
        } else {
            const factor = (cT - p.t) / timeDiff;
            rawX = p.x + (n.x - p.x) * factor;
            rawY = p.y + (n.y - p.y) * factor;
        }
    }

    if (rVState.activeReplay.originalGameWidth && rVState.activeReplay.originalGameHeight) {
        const scaleX = gameWidth / rVState.activeReplay.originalGameWidth;
        const scaleY = gameHeight / rVState.activeReplay.originalGameHeight;
        playerCursor.x = rawX * scaleX;
        playerCursor.y = rawY * scaleY;
    } else {
        playerCursor.x = rawX;
        playerCursor.y = rawY;
    }
    
    playerCursor.x = Math.max(0, Math.min(gameWidth, playerCursor.x));
    playerCursor.y = Math.max(0, Math.min(gameHeight, playerCursor.y));
}

function fnURUI() { if(!rVState.activeReplay)return; fnUUI(); }

function fnRGL(timestamp) {
    if (!rVState.activeReplay || !rVState.isPlaying) {
        if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null; return;
    }
    const dTS = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    const newCurrentTimeMs = rVState.currentTimeMs + dTS * 1000;

    if (newCurrentTimeMs >= rVState.totalDurationMs) {
        rVState.currentTimeMs = rVState.totalDurationMs;
        rVState.isPlaying = false;
        fnSetReplayButtonIcon(false);
        fnAREUTT(rVState.currentTimeMs, false);
    } else {
        rVState.currentTimeMs = newCurrentTimeMs;
        fnAREUTT(rVState.currentTimeMs, false);
    }

    fnIMFR();

    fnUGP(dTS, rVState.currentTimeMs - (dTS*1000));
    if (dropper1) fnUSD(dropper1, dTS, true);
    if (dropper2) fnUSD(dropper2, dTS, false);
    if (bucket) fnUBkt(dTS);
    fnUB(dTS);

    if (playerCursor) { fnACWP(playerCursor.x, playerCursor.y); }
    fnUCWP(dTS);

    if (rVState.activeReplay.gameMode === 'classic') { fnUPGP(dTS); fnUPI(); } else { fnUPI(); }
    fnUAP(dTS);

    gameCtx.clearRect(0, 0, gameWidth, gameHeight);
    fnDAP(gameCtx);

    // Draw Bucket first
    if (bucket) fnDBkt(gameCtx, bucket);

    // Draw Player Cursor and its particles
    fnDCWP(gameCtx);
    if (playerCursor) fnDPC(gameCtx);

    // Draw Balls NEXT
    fnDB(gameCtx);

    // Draw Droppers AFTER Balls
    if (dropper1) fnDSD(gameCtx, dropper1);
    if (dropper2) fnDSD(gameCtx, dropper2);

    // Draw Power-up Glow Particles
    if (rVState.activeReplay.gameMode === 'classic') { fnDPGP(gameCtx); }
    fnURUI();

    if (rVState.isPlaying) {
        rAnimId = requestAnimationFrame(fnRGL);
    } else {
        if (rAnimId) cancelAnimationFrame(rAnimId); rAnimId = null;
        redrawStaticFrame();
    }
}

function getSharedNote(timestamp, mode) {
    if (timestamp === undefined || mode === undefined) return "";
    const notes = JSON.parse(localStorage.getItem('colorfallSharedNotes') || '{}');
    const compositeKey = `${mode}_${timestamp}`;
    return notes[compositeKey] || "";
}

function saveSharedNote(timestamp, mode, noteText) {
    if (timestamp === undefined || mode === undefined) return;
    let notes = JSON.parse(localStorage.getItem('colorfallSharedNotes') || '{}');
    const compositeKey = `${mode}_${timestamp}`;

    if (noteText.trim() === "") {
        delete notes[compositeKey]; // Remove note if empty
    } else {
        notes[compositeKey] = noteText;
    }
    try {
        localStorage.setItem('colorfallSharedNotes', JSON.stringify(notes));
    } catch (e) {
        console.error("Error saving shared note to localStorage:", e);
    }
}

window.onload=()=>{
    canvasArea = document.getElementById('canvasArea'); gameCanvas=document.getElementById('gameCanvas'); gameCtx=gameCanvas.getContext('2d'); aCvs=document.getElementById('atmosphericCanvas'); aCtx=aCvs.getContext('2d');
    qualitySelectElement = document.getElementById('qualitySelect');
    screens.home=document.getElementById('homeScreen'); screens.game=document.getElementById('gameScreen');
    screens.settings=document.getElementById('settingsScreen'); screens.highScores=document.getElementById('highScoresScreen');
    screens.howToPlay=document.getElementById('howToPlayScreen'); screens.replays=document.getElementById('replaysScreen');
    screens.appearance=document.getElementById('appearanceScreen');

    gameOverScreen = document.getElementById('gameOverScreen');
    pauseOverlay = document.getElementById('pauseOverlay');

    uiOverlayElem = document.getElementById('uiOverlay'); powerupIconsContainerElem = document.getElementById('powerupIconsContainer'); replayControlsContainerElem = document.getElementById('replayControlsContainer');
    scoreDisplay=document.getElementById('scoreDisplay'); timeDisplay=document.getElementById('timeDisplay'); livesDisplay=document.getElementById('livesDisplay'); finalScoreDisplay=document.getElementById('finalScoreDisplay'); finalTimeDisplay=document.getElementById('finalTimeDisplay'); gameOverQuitBtn=document.getElementById('gameOverQuitBtn'); saveReplayBtnElem = document.getElementById('saveReplayBtn');
    volumeSlider=document.getElementById('volumeSlider'); volumeValueDisplay=document.getElementById('volumeValueDisplay'); sensitivitySlider=document.getElementById('sensitivitySlider'); sensitivityValueDisplay=document.getElementById('sensitivityValueDisplay');
    keybindLeftBtn=document.getElementById('keybindLeftBtn'); keybindRightBtn=document.getElementById('keybindRightBtn'); keybindMaxSpeedBtn=document.getElementById('keybindMaxSpeedBtn'); keybindPauseBtn=document.getElementById('keybindPauseBtn');
    newHighScoreTextElem=document.getElementById('newHighScoreText'); powerupIconElems.slowFall=document.getElementById('slowFallIcon');powerupIconElems.wideBucket=document.getElementById('wideBucketIcon');powerupIconElems.oneColor=document.getElementById('oneColorIcon');powerupIconElems.doublePoints=document.getElementById('doublePointsIcon');powerupIconElems.whiteBallMagnet=document.getElementById('magnetIcon');
    quitConfirmationDialog=document.getElementById('quitConfirmationDialog'); confirmQuitBtn=document.getElementById('confirmQuitBtn'); cancelQuitBtn=document.getElementById('cancelQuitBtn'); gameScreenHomeBtn=document.getElementById('gameScreenHomeBtnInOverlay');
    modeSelectionDialogElem=document.getElementById('modeSelectionDialog');
    deleteReplayConfirmationDialog = document.getElementById('deleteReplayConfirmationDialog'); confirmDeleteReplayBtn = document.getElementById('confirmDeleteReplayBtn'); cancelDeleteReplayBtn = document.getElementById('cancelDeleteReplayBtn');
    deleteAllReplaysConfirmationDialog = document.getElementById('deleteAllReplaysConfirmationDialog'); confirmDeleteAllReplaysBtn = document.getElementById('confirmDeleteAllReplaysBtn'); cancelDeleteAllReplaysBtn = document.getElementById('cancelDeleteAllReplaysBtn');
    exportReplayDialog = document.getElementById('exportReplayDialog'); exportReplayTextArea = document.getElementById('exportReplayTextArea'); copyExportReplayBtn = document.getElementById('copyExportReplayBtn'); closeExportReplayBtn = document.getElementById('closeExportReplayBtn');
    importReplayDialog = document.getElementById('importReplayDialog'); importReplayTextArea = document.getElementById('importReplayTextArea'); importReplayError = document.getElementById('importReplayError'); importReplayAndPlayBtn = document.getElementById('importReplayAndPlayBtn'); cancelImportReplayBtn = document.getElementById('cancelImportReplayBtn');

    autosaveReplaysSelect = document.getElementById('autosaveReplaysSelect');
    autosaveThresholdElements = document.getElementById('autosaveThresholdElements');
    autosaveThresholdBtn = document.getElementById('autosaveThresholdBtn');

    replayPlayPauseBtn = document.getElementById('replayPlayPauseBtn'); replaySeekBar = document.getElementById('replaySeekBar'); replayTimeDisplayElem = document.getElementById('replayTimeDisplay');

    screenStack = [];

    fnLRS();
    initAudio();
    fnLS();
    handleResize();
    fnUBS();
    fnSEL();
    fnSS('home');
    isInitialLoad = false;

    document.addEventListener('visibilitychange',fnHVC);
    window.addEventListener('blur',fnHFC);
    window.addEventListener('focus',fnHFC);
    window.addEventListener('resize',handleResize);
    document.addEventListener('mousemove',(e)=>{
        lastKnownMouseX = e.clientX;
        lastKnownMouseY = e.clientY;

        if(gameModeActive && gameRunning && !gamePaused && playerCursor){
            const dialogOpen = [quitConfirmationDialog, deleteReplayConfirmationDialog, deleteAllReplaysConfirmationDialog, exportReplayDialog, importReplayDialog, modeSelectionDialogElem].some(d => d?.style.display !== 'none'); if (dialogOpen) return;
            const rect=gameCanvas.getBoundingClientRect();
            playerCursor.x=e.clientX-rect.left;
            playerCursor.y=e.clientY-rect.top;
        }
    });

    if (aCtx) {
        aCtx.clearRect(0,0,gameWidth,gameHeight);
        fnDTP(aCtx);
    }
};
</script>
</body>
</html>
